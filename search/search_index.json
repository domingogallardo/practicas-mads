{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>Pr\u00e1cticas de la asignatura Metodolog\u00edas \u00c1giles de Desarrollo de Software de la Universidad de Alicante.</p> <ul> <li>Pr\u00e1ctica 1<ul> <li>Enunciado de la pr\u00e1ctica</li> <li>Introducci\u00f3n a Spring Boot</li> <li>Resumen de comandos Git</li> </ul> </li> <li>Pr\u00e1ctica 2</li> <li>Pr\u00e1ctica 3</li> <li>Pr\u00e1ctica 4</li> <li>Pr\u00e1ctica 5</li> </ul>"},{"location":"index.html#construido-con-mkdocs","title":"Construido con MkDocs","text":"<p>Versi\u00f3n HTML compilada usando el tema Material de MkDocs.</p> <p>Repositorio en GitHub.</p>"},{"location":"01-intro-spring-boot/comandos-git.html","title":"Resumen de comandos Git","text":"<p>Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2.</p> <p>Al final del documento se incluyen enlaces a apartados del libro Pro Git. Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi).</p>"},{"location":"01-intro-spring-boot/comandos-git.html#1-comandos-basicos","title":"1. Comandos b\u00e1sicos","text":"<ul> <li> <p>Configurar el usuario y direcci\u00f3n de correo en git:</p> <pre><code>$ git config --global user.name \"John Doe\"\n$ git config --global user.email johndoe@example.com\n</code></pre> </li> <li> <p>Inicializar git en un directorio:</p> <pre><code>$ cd /ruta/a/mi/directorio\n$ git config --global user.name &lt;nombre-usuario&gt;\n$ git config --global user.email &lt;email&gt;\n$ git init\n$ git add .\n$ git commit -m \"Versi\u00f3n inicial\"\n</code></pre> </li> <li> <p>Publicar por primera vez el repositorio local en el remoto (en GitHub):</p> <pre><code>$ git remote add origin &lt;url-repo&gt;.git\n$ git push -u origin main\n</code></pre> <p>El nombre del repositorio remoto ser\u00e1 <code>origin</code> (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama <code>main</code> (la rama por defecto que se crea al inicializar el repositorio local).</p> </li> <li> <p>Comprobar el estado del repositorio local: </p> <pre><code>$ git status\n</code></pre> </li> <li> <p>Comprobar las diferencias entre los ficheros modificados en el   directorio de trabajo y el \u00faltimo commit:</p> <pre><code>$ git diff\n</code></pre> </li> <li> <p>A\u00f1adir un fichero al   stage   (a\u00f1adirlo para el pr\u00f3ximo commit):</p> <pre><code>$ git add &lt;fichero o directorio&gt;\n</code></pre> <p>El \u00e1rea de stage tambi\u00e9n se llama el index. Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento:</p> <p></p> </li> <li> <p>Hacer un commit de los ficheros en el stage:</p> <pre><code>$ git commit -m \"Mensaje\"\n</code></pre> </li> <li> <p>Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final   decidimos no a\u00f1adirlo en el siguiente commit):</p> <pre><code>$ git reset HEAD &lt;fichero&gt;\n</code></pre> </li> <li> <p>Se puede combinar en un \u00fanico comando el <code>add</code> y el <code>commit</code> en   ficheros ya a\u00f1adidos al control de versiones:</p> <pre><code>$ git commit -a -m \"Mensaje\"\n</code></pre> <p>Se puede abreviar como </p> <pre><code>$ git commit -am \"Mensaje\"`\n</code></pre> </li> <li> <p>Deshacer un commit (sin perder los cambios que se han introducido en \u00e9l):</p> <pre><code>$ git reset HEAD^\n</code></pre> <p>Los ficheros modificados seguir\u00e1n estando en el directorio, con las modificaciones incluidas, pero fuera del \u00e1rea de stage. Para hacer un nuevo commit hay que volver a a\u00f1adirlos haciendo <code>add</code>.</p> </li> <li> <p>Eliminar todos los cambios realizados en el directorio, volviendo al   \u00faltimo commit (\u00a1Peligroso: perdemos todos los cambios del \u00faltimo commit!)</p> <pre><code>$ git reset --hard HEAD\n$ git clean -fd (si se ha a\u00f1adido alg\u00fan fichero)\n</code></pre> </li> <li> <p>Publicar los cambios en el repositorio remoto:</p> <pre><code>$ git push\n</code></pre> </li> <li> <p>Si hay commits en el repositorio remoto que queremos eliminar y cambiarlos por   los commits en el directorio local:</p> <pre><code>$ git push --force\n</code></pre> </li> <li> <p>Consultar los mensajes de los commits (toda la historia de la rama   actual). La opci\u00f3n <code>--oneline</code> muestra s\u00f3lo la primera l\u00ednea del   mensaje, la opci\u00f3n <code>--graph</code> muestra el grafo de dependencias y la   opci\u00f3n <code>--all</code>muestra el grafo completo, no s\u00f3lo aquel en el que   estamos (<code>HEAD</code>).</p> <pre><code>$ git log [--oneline] [--graph] [--all]\n</code></pre> </li> <li> <p>Comprobar las diferencias entre dos commits:</p> <pre><code>$ git diff &lt;hash-previo&gt; &lt;hash-nuevo&gt;\n</code></pre> <p>Devuelve las cambios que se han introducido desde el commit identificado por  y hasta el ."},{"location":"01-intro-spring-boot/comandos-git.html#2-ramas","title":"2. Ramas","text":"<p>Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia <code>HEAD</code> la rama actual.</p> <p></p> <ul> <li> <p>Crear una rama nueva:</p> <pre><code>$ git checkout -b nueva-rama\nM   hola.txt (si hay cambios en el espacio de trabajo se llevan a la nueva rama)\nSwitched to a new branch 'nueva-rama'\n</code></pre> </li> <li> <p>Listar todas las ramas de un repositorio (incluyendo ramas remotas)</p> <pre><code>$ git branch -av\nmain\n* nueva-rama\n$ git commit -a -m \"Confirmamos los cambios en la nueva rama\"\n</code></pre> </li> <li> <p>Moverse a otra rama:</p> <pre><code>$ git checkout main\nSwitched to branch 'main'\n</code></pre> </li> <li> <p>Mostrar un fichero de una rama (o commit) dado:</p> <pre><code>$ git show &lt;commit o rama&gt;:&lt;nombre-fichero&gt;\n</code></pre> </li> <li> <p>Comparar dos ramas:</p> <pre><code>$ git diff main nueva-rama\n</code></pre> <p>El comando <code>git diff main nueva-rama</code> devuelve las diferencias entre las ramas <code>main</code> y <code>nueva-rama</code>: las modificaciones que resultar\u00edan de mezclar la rama <code>nueva-rama</code> en la rama <code>main</code>.</p> </li> <li> <p>Merge de ramas: Mezclar la rama <code>nueva-rama</code> en la rama <code>main</code> (a\u00f1ade a la <code>main</code> los commits adicionales de la rama <code>nueva-rama</code>):</p> <pre><code>$ git checkout main\n$ git merge [--no-ff] nueva-rama -m \"Mensaje de commit\"\n</code></pre> <p>La opci\u00f3n <code>--no-ff</code> no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio.</p> </li> <li> <p>Si en la rama que se mezcla y en la actual hay cambios que afectan a   las mismas l\u00edneas de un fichero, git detecta un conflicto y combina   esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n   de la procedencia. Debemos resolver el conflicto: editarlos a mano y   volver a hacer add y commit.</p> <pre><code>$ git merge nueva-rama\nCONFLICT (content): Merge conflict in hola.txt  \nAutomatic merge failed; fix conflicts and then commit the result.  \n# editar a mano el fichero con conflictos\n$ git commit -a -m \"Arreglado el conflicto en el merge\"\n$ git merge nueva-rama\n</code></pre> <p>El comando <code>git status</code> despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente.</p> </li> <li> <p>Rebase de una rama. Si la rama main ha avanzado despu\u00e9s de   separar una rama alternativa y queremos incorporar esos cambios en   la rama alternativa podemos hacer un <code>git rebase</code>:</p> <pre><code>$ git checkout -b experiment\n# hacemos cambios\n$ git commit -m \"Cambios en experiment\"\n$ git checkout main  \n# hacemos cambios  \n$ git commit -a -m \"Cambios en main\"  \n$ git checkout experiment\n$ git rebase main  \nFirst, rewinding head to replay your work on top of it...  \nApplying: Corregido bug1  \nApplying: Corregido bug2\n</code></pre> <p></p> <p>El comando cambia la historia de la rama: primero la mueve al final de la rama main (rewind head) y a partir de ah\u00ed aplica los cambios propios de la rama.</p> <p>\u00a1Cuidado!</p> <p>No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos.</p> <p>Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama <code>main</code> y tener una historia lineal:</p> <pre><code>$ git checkout main\n$ git merge nueva-rama\n# Borramos la rama una vez mezclada\n$ git branch -d nueva-rama\n</code></pre> </li> <li> <p>Igual que en el merge, al hacer un rebase pueden aparecer   conflictos al hacer el rebase, basta con modificar los ficheros   con conflictos, a\u00f1adirlos y continuar el rebase:</p> <pre><code>$ git rebase main\nCONFLICT (content): Merge conflict in &lt;some-file&gt;\n# hacemos git status para comprobar donde est\u00e1n los conflictos\n$ git status\n# Unmerged paths:\n# (use \"git reset HEAD &lt;some-file&gt;...\" to unstage)\n# (use \"git add/rm &lt;some-file&gt;...\" as appropriate to mark resolution)\n#\n# Editamos los ficheros para corregir los conflictos\n$ git add &lt;some-file&gt;\n$ git rebase --continue\n</code></pre> <p>Nota</p> <p>Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase. Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento.</p> </li> <li> <p>Log en forma de grafo:</p> <pre><code>$ git log --graph --oneline \n</code></pre> </li> <li> <p>Borrar una rama:</p> <pre><code>$ git branch -d nueva-rama  \nDeleted branch nueva-rama (was c241d7b)\n</code></pre> <p>S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras.</p> </li> <li> <p>Borrar una rama descartando sus commits:</p> <pre><code>$ git branch -D rama\n</code></pre> </li> <li> <p>Subir una rama al repositorio remoto:</p> <pre><code>$ git push -u origin &lt;rama&gt;\n</code></pre> </li> <li> <p>Descargar una rama del repositorio remoto (origin, por ejemplo, el   repositorio remoto por defecto)</p> <pre><code>$ git fetch \n$ git checkout -b &lt;rama&gt; origin/&lt;rama&gt;\n</code></pre> </li> <li> <p>Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo)</p> <pre><code>$ git remote show origin\n</code></pre> </li> <li> <p>Subir todas las ramas y etiquetas:</p> <pre><code>$ git push -u -all origin\n</code></pre> <p>Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer <code>git push</code> para subir los cambios en cualquiera de las ramas presentes.</p> </li> <li> <p>Borrar una rama en repositorio remoto:</p> <pre><code>$ git push origin --delete &lt;branchName&gt;\n</code></pre> </li> </ul>"},{"location":"01-intro-spring-boot/comandos-git.html#3-modificar-la-historia","title":"3. Modificar la historia","text":"<ul> <li> <p>Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el   que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a   mano:</p> <pre><code>$ git commit --amend [--m \"Nuevo mensaje\"]\n</code></pre> </li> <li> <p>Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage):</p> <pre><code>$ git reset --soft HEAD^\n</code></pre> </li> <li> <p>Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge:</p> <pre><code>$ git reset --merge ORIG_HEAD\n</code></pre> </li> <li> <p>Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una   nueva rama all\u00ed (o no) y volver al commit actual:</p> <pre><code>$ git checkout &lt;hash&gt; (o tag, por ejemplo v2.0)\nYou are in 'detached HEAD' state.\n# Ahora est\u00e1s en un detached HEAD\n$ git branch\n* (HEAD detached at 594b606)\nmain\n$ git checkout -b v2.0.1\nSwitched to a new branch 'v2.0.1'\n$ git branch\nmain\n* v2.0.1\n$ git checkout main\n</code></pre> </li> <li> <p>Movernos atr\u00e1s a un commit pasado, descartando todos los commits   realizados despu\u00e9s (peligroso)</p> <pre><code>$ git reset --hard &lt;hash&gt;\n</code></pre> </li> </ul>"},{"location":"01-intro-spring-boot/comandos-git.html#4-mas-informacion","title":"4. M\u00e1s informaci\u00f3n","text":"<p>Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos:</p> <ul> <li>Pro Git - Recording Changes to the Repository</li> <li>Pro Git - Basic Branching and Merging</li> <li>Pro Git - Git Branching - Rebasing</li> <li>Tutorial de Atlassian - Merging vs. Rebasing</li> <li>Pro Git - Reset Demystified</li> </ul>"},{"location":"01-intro-spring-boot/intro-spring-boot.html","title":"Introducci\u00f3n a Spring Boot","text":"<p>Vamos a trabajar con la versi\u00f3n 2.7.14 de Spring Boot. Se puede consultar toda la documentaci\u00f3n oficial sobre esta versi\u00f3n en este enlace. </p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#1-aplicacion-ejemplo","title":"1. Aplicaci\u00f3n ejemplo","text":"<p>Es muy sencillo crear aplicaciones de Spring Boot desde cero usando la web Spring initializr. En esa p\u00e1gina puedes configurar los metadatos del proyecto y sus dependencias y descargar el proyecto como un ZIP con la estructura de directorios y el POM ya configurados. </p> <p>Nosotros vamos a hacerlo m\u00e1s f\u00e1cil todav\u00eda usando una aplicaci\u00f3n ejemplo en GitHub domingogallardo/spring-boot-demoapp. </p> <p>La aplicaci\u00f3n es un sencillo <code>Hola mundo</code>. En los siguientes apartados explicamos c\u00f3mo lanzarla y c\u00f3mo funciona.</p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#2-ejecucion-de-aplicaciones-spring-boot","title":"2. Ejecuci\u00f3n de aplicaciones Spring Boot","text":"<p>Spring Boot permite ejecutar aplicaciones Spring de forma standalone, sin necesidad de un servidor de aplicaciones. Una aplicaci\u00f3n Spring Boot lleva incluido un servidor web embebido (Tomcat) que se pone en marcha al lanzar la aplicaci\u00f3n y sirve todas las p\u00e1ginas de la aplicaci\u00f3n web.</p> <p>Para lanzar una aplicaci\u00f3n Spring Boot es suficiente tener instalados:</p> <ul> <li>JDK Java (8 en adelante)</li> <li>Maven</li> </ul> <p>Maven incluso no es necesario si la aplicaci\u00f3n Spring Boot lo tiene ya instalado utilizando Maven Wrapper, como es el caso de la aplicaci\u00f3n ejemplo.</p> <p>Desde el directorio donde est\u00e1 la aplicaci\u00f3n que queremos lanzar podemos arrancarla como una aplicaci\u00f3n Java. Podemos llamar a <code>mvn</code> si tenemos instalado Maven o a <code>./mvnw</code> para usar Maven Wrapper:</p> <pre><code>$ ./mvnw package\n$ java -jar target/demoapp-0.0.1-SNAPSHOT.jar \n</code></pre> <p>Tambi\u00e9n podemos lanzarla usando el plugin <code>spring-boot</code> de Maven:</p> <pre><code>$ ./mvnw spring-boot:run\n</code></pre> <p>La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio.</p> <p>En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas:</p> <ul> <li>http://localhost:8080</li> <li>http://localhost:8080/saludo/Pepito</li> <li>http://localhost:8080/saludoplantilla/Pepito</li> <li>http://localhost:8080/saludoform</li> </ul>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#3-desarrollo-y-ejecucion-con-intellij","title":"3. Desarrollo y ejecuci\u00f3n con IntelliJ","text":"<p>Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate. Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA.</p> <p>Para abrir un proyecto Spring Boot en IntelliJ basta con abrir el directorio donde se encuentre el fichero <code>pom.xml</code>. Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Open o usando la opci\u00f3n File &gt; Open\" o \"File &gt; New &gt; Project from Existing Sources. </p> <p>IntelliJ abre el proyecto correctamente:</p> <p></p> <p>Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n:</p> <p></p> <p>Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc:</p> <p></p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#github-copilot","title":"GitHub Copilot","text":"<p>Es recomendable instalar el plugin GithHub Copilot para JetBrains para trabajar con este asistente de IA como ayudante de c\u00f3digo. Tras instalar el plugin deber\u00e1s activarlo introduciendo tu usuario de GitHub.</p> <p>Puedes trabajar de forma gratuita con GitHub Copilot d\u00e1ndote de alta en el GitHub Student Developer Pack.</p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#4-conceptos-de-spring-boot","title":"4. Conceptos de Spring Boot","text":""},{"location":"01-intro-spring-boot/intro-spring-boot.html#estructura-de-la-aplicacion","title":"Estructura de la aplicaci\u00f3n","text":"<p>Estructura de directorios t\u00edpica de los proyectos Java construidos con Maven:</p> <p></p> <p>El fichero <code>pom.xml</code> declara las dependencias. Spring Boot proporciona starters que agrupan un conjunto de dependencias comunes.</p> <p>Fichero <code>pom.xml</code></p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n         https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n&lt;groupId&gt;es.ua.mads&lt;/groupId&gt;\n&lt;artifactId&gt;demoapp&lt;/artifactId&gt;\n&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n&lt;name&gt;demoapp&lt;/name&gt;\n\n&lt;parent&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n&lt;version&gt;2.6.10&lt;/version&gt;\n&lt;/parent&gt;\n\n&lt;properties&gt;\n&lt;java.version&gt;1.8&lt;/java.version&gt;\n&lt;/properties&gt;\n\n&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n&lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n&lt;build&gt;\n&lt;plugins&gt;\n&lt;plugin&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n&lt;/plugin&gt;\n&lt;plugin&gt;\n&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n&lt;configuration&gt;\n&lt;argLine&gt;-Dfile.encoding=UTF8&lt;/argLine&gt;\n&lt;/configuration&gt;\n&lt;/plugin&gt;\n&lt;/plugins&gt;\n&lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <p>En el panel de Maven de IntelliJ se puede consultar las librer\u00edas concretas que se han descargado:</p> <p></p> <p>En el fichero de configuraci\u00f3n de la aplicaci\u00f3n se definen propiedades que configuran distintos aspectos de la misma, como la base de datos con la que se va a trabajar o el puerto en el que debe ejecutarse. Conforme necesitemos configurar estas propiedades iremos a\u00f1adiendo elementos al fichero.</p> <p>Fichero <code>resources/application.properties</code></p> <pre><code>spring.application.name = demoapp\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#controladores","title":"Controladores","text":"<p>Los controladores definen el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Son clases que se suelen colocar en el paquete <code>controller</code> y est\u00e1n anotadas con <code>@Controller</code>.</p> <p>Vemos un ejemplo en la clase <code>SaludoController</code>.</p> <p>Fichero <code>src/main/java/demoapp/controller/SaludoController.java</code>:</p> <pre><code>package demoapp.controller;\n\nimport demoapp.service.SaludoService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n\n@Controller\npublic class SaludoController {\n\n@Autowired\nprivate SaludoService service;\n\n@RequestMapping(\"/saludo/{nombre}\")\npublic @ResponseBody String saludo(@PathVariable(value=\"nombre\") String nombre) {\nreturn service.saluda(nombre);\n}\n\n}\n</code></pre> <p>Los m\u00e9todos en los que se definen las respuestas a las peticiones HTTP est\u00e1n anotados con anotaciones en las que se indica el tipo de petici\u00f3n y la URL a la que se responde.</p> <p>Por ejemplo, en la clase anterior el m\u00e9todo <code>saludo</code> contesta a las peticiones dirigida a la URL <code>/saludo/Ana</code>. La cadena <code>Ana</code> en la URL es decodificada y pasada en el par\u00e1metro <code>nombre</code> al m\u00e9todo.</p> <p>El m\u00e9todo devuelve la respuesta HTTP. La anotaci\u00f3n <code>@ResponseBody</code> construye autom\u00e1ticamente esta respuesta, a\u00f1adiendo como contenido de la misma la cadena devuelta por el servicio. </p> <p>En este caso la respuesta es:</p> <pre><code>HTTP/1.1 200 \nContent-Type: text/plain;charset=UTF-8\nContent-Length: 8\nDate: Mon, 02 Sep 2019 14:59:04 GMT\n\nHola Ana\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#clases-de-servicio","title":"Clases de Servicio","text":"<p>Es recomendable definir clases de servicio en las que se implementa la l\u00f3gica de negocio de la aplicaci\u00f3n. Las clases controller llaman a las clases servicio, que son las que realmente realizan todo el procesamiento.</p> <p>De esta forma se separan las responsabilidades. Las clases controller se encargan de procesar las peticiones y las respuestas HTTP y las clases de servicio son las que realmente realizan la l\u00f3gica de negocio y devuelven el contenido de las respuestas. Si en alg\u00fan momento hay que a\u00f1adir una nueva capa de presentaci\u00f3n en la que, por ejemplo, se trabaje con objetos JSON, no ser\u00e1 necesario cambiar la capa de servicios, s\u00f3lo a\u00f1adir nuevas clases controller.</p> <p>La separaci\u00f3n de la l\u00f3gica de negocio en las clases de servicio permite tambi\u00e9n realizar tests que trabajan sobre objetos Java, independientes de los formatos de entrada/salida manejados por los controladores. </p> <p>Fichero <code>src/main/java/demoapp/service/SaludoService.java</code></p> <pre><code>package demoapp.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class SaludoService {\npublic String saluda(String nombre) {\nreturn \"Hola \" + nombre;\n}\n}\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#inyeccion-de-dependencias-en-spring","title":"Inyecci\u00f3n de dependencias en Spring","text":"<p>Spring Boot utiliza la anotaci\u00f3n <code>@Autowired</code> para inyectar en la variable anotada un objeto nuevo del tipo indicado. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. Hemos utilizado la anotaci\u00f3n en las variables de instancia.</p> <p>En los ejemplos anteriores podemos comprobar estas anotaciones. En la aplicaci\u00f3n ejemplo se define un controlador y un servicio que devuelve un saludo. El servicio se anota con la anotaci\u00f3n <code>@Service</code> y esta anotaci\u00f3n le indica a Spring Boot que la clase que va a poder ser inyectada.</p> <p>En el controlador se necesita instanciar un objeto de la clase <code>SaludoService</code> y se hace usando inyecci\u00f3n de dependencias. Spring Boot se encarga de obtener una instancia y de inyectarla en la variable cuando se inicializa el controlador. Lo vemos en el siguiente c\u00f3digo:</p> <pre><code>@Controller\npublic class SaludoController {\n\n@Autowired\nprivate SaludoService service;\n\n@RequestMapping(\"/saludo/{nombre}\")\npublic @ResponseBody String saludo(@PathVariable(value=\"nombre\") String nombre) {\nreturn service.saluda(nombre);\n}\n\n}\n</code></pre> <p>Mediante la inyecci\u00f3n de dependencias el c\u00f3digo es m\u00e1s flexible y es m\u00e1s f\u00e1cil de testear, pudi\u00e9ndose definir mocks que sustituyen los objetos inyectados.</p> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n de Spring Boot Spring Beans and Dependency Injection.</p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#alcance-de-los-objetos-inyectados","title":"Alcance de los objetos inyectados","text":"<p>Por defecto el alcance (scope) de todas las anotaciones de Spring (<code>@service</code>, <code>@controller</code>, <code>@component</code>, etc.) es un Singleton. Existe una \u00fanica instancia de ese objeto que es la que se inyecta en las variables.</p> <p>Al estar funcionando en una aplicaci\u00f3n web, el singleton que hace de controlador recibir\u00e1 m\u00faltiples peticiones concurrentemente. Cada petici\u00f3n ir\u00e1 en su propio hilo de Java, por lo que m\u00faltiples hilos podr\u00e1n estar ejecutando el mismo c\u00f3digo del controlador. </p> <p>Por ello hay que tener cuidado en no definir variables de instancia mutables (con estado) dentro del controlador (con excepci\u00f3n de los objetos inyectados con la anotaci\u00f3n <code>@Autowired</code>), porque podr\u00edan producirse errores debidos a condiciones de carrera (un hilo modifica la misma variable que otro est\u00e1 leyendo). Es conveniente que todos los beans (controladores, servicios, etc.) sean objetos sin estado.</p> <p>Tambi\u00e9n es posible definir otros alcances, como <code>@RequestScope</code> o <code>@SessionScope</code>. En el primer caso se crea una instancia nueva del objeto para cada petici\u00f3n HTTP y en el segundo se crea una instancia nueva en cada sesi\u00f3n HTTP.</p> <p>Puedes encontrar m\u00e1s informaci\u00f3n y ejemplos en este enlace.</p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#plantillas-thymeleaf","title":"Plantillas Thymeleaf","text":"<p>Las p\u00e1ginas HTML devueltas se pueden construir utilizando un lenguaje de plantillas con el framework Thymeleaf. Las plantillas thymeleaf son p\u00e1ginas HTML en las que se introducen objetos Java pasados por los controllers.</p> <p>Las plantillas se incluyen en el directorio <code>resources/templates</code>.</p> <p>Por ejemplo, el siguiente fichero es una sencilla plantilla que muestra un saludo. El objeto <code>mensaje</code> es una cadena que se pasa desde el controller.</p> <p>Fichero <code>src/main/resources/templates/saludo.html</code></p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n    &lt;h1 th:text=\"'Saludo: ' + ${mensaje}\"&gt; &lt;/h1&gt;\n&lt;/html&gt;\n</code></pre> <p>El controller construye la vista devolviendo el nombre de la plantilla. Y pasa a la plantilla los objetos a mostrar usando un diccionario (la variable <code>model</code> que recibe como par\u00e1metro):</p> <p>Fichero <code>src/main/java/demoapp/controller/SaludoControllerPlantilla.java</code></p> <pre><code>package demoapp.controller;\n\nimport demoapp.service.SaludoService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n\n@Controller\npublic class SaludoControllerPlantilla {\n\n@Autowired\nprivate SaludoService service;\n\n@RequestMapping(\"/saludoplantilla/{nombre}\")\npublic String saludo(@PathVariable(value=\"nombre\") String nombre, Model model) {\n// Se a\u00f1ade la respuesta a la clave 'mensaje' que se usa\n// en la plantilla\nmodel.addAttribute(\"mensaje\", service.saluda(nombre));\n// Se llama a la plantilla 'saludo.html'\nreturn \"saludo\";\n}\n}\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#formularios-y-validacion","title":"Formularios y validaci\u00f3n","text":"<p>Spring Boor simplifica la declaraci\u00f3n y validaci\u00f3n de formularios usando clases Java que trabajan como modelos del formulario. Por ejemplo, en la aplicaci\u00f3n se define la clase <code>UserData</code>:</p> <p>Fichero <code>src/main/java/demoapp/controller/UserData.java</code></p> <pre><code>package demoapp.controller;\n\nimport javax.validation.constraints.Size;\n\npublic class UserData {\n@Size(min=3, max=30)\nString nombre;\n\npublic void setNombre(String nombre) {\nthis.nombre = nombre;\n}\n\npublic String getNombre() {\nreturn nombre;\n}\n}\n</code></pre> <p>Se trata de un objeto con el campo <code>nombre</code> de tipo <code>String</code> al que se le ha a\u00f1adido una anotaci\u00f3n de validaci\u00f3n <code>@Size</code> con el tama\u00f1o m\u00ednimo y m\u00e1ximo que debe tener.</p> <p>Puedes encontrar m\u00e1s informaci\u00f3n sobre otros atributos de validaci\u00f3n en este enlace.</p> <p>El formulario HTML propiamente dicho se define con una plantilla thymeleaf en la que se declara un objeto que tiene el mismo nombre que el nombre de la clase modelo, pero con la primera letra en min\u00fascula. En nuestro caso la clase modelo es <code>UserData</code>, por lo que el objeto del formulario debe llamarse <code>userData</code>. En el formulario podemos usar cualquier campo definido en el objeto modelo. En nuestro caso usamos el \u00fanico campo de tipo <code>String</code>, <code>nombre</code>.</p> <p>Fichero <code>src/main/resources/templates/formRegistro.html</code></p> <pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n&lt;body&gt;\n&lt;form th:action=\"@{/saludoform}\" th:object=\"${userData}\" method=\"post\"&gt;\n    &lt;table&gt;\n        &lt;tr&gt;\n            &lt;td&gt;Nombre:&lt;/td&gt;\n            &lt;td&gt;&lt;input type=\"text\" th:field=\"*{nombre}\" /&gt;&lt;/td&gt;\n            &lt;td th:if=\"${#fields.hasErrors('nombre')}\" th:errors=\"*{nombre}\"&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;&lt;button type=\"submit\"&gt;Enviar&lt;/button&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Se define una acci\u00f3n que enviar\u00e1 una petici\u00f3n <code>POST</code> a la URL <code>/saludoform</code> con los datos del formulario. En este caso el nombre.</p> <p>Por \u00faltimo, el controller que lanza el formulario y el que recibe la petici\u00f3n <code>POST</code> con los datos introducidos se definen en el siguiente fichero:</p> <p>Fichero <code>src/main/java/demoapp/controller/SaludoControllerForm.java</code></p> <pre><code>package demoapp.controller;\n\nimport demoapp.service.SaludoService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.validation.Valid;\n\n@Controller\npublic class SaludoControllerForm {\n\n@Autowired\nprivate SaludoService service;\n\n@GetMapping(\"/saludoform\")\n// Hay que declarar un par\u00e1metro con el tipo usado en el modelo del formulario (UserData)\npublic String saludoForm(UserData userData) {\nreturn \"formRegistro\";\n}\n\n@PostMapping(\"/saludoform\")\npublic String checkPersonInfo(@ModelAttribute @Valid UserData userData, BindingResult bindingResult, Model model) {\nif (bindingResult.hasErrors()) {\nreturn \"formRegistro\";\n}\nmodel.addAttribute(\"mensaje\", service.saluda(userData.getNombre()));\nreturn \"saludo\";\n}\n}\n</code></pre> <p>El m\u00e9todo que recibe la petici\u00f3n en <code>/saludoform</code> simplemente devuelve la plantilla con el formulario. </p> <p>Y el m\u00e9todo que recibe los datos es el que responde a la petici\u00f3n <code>POST</code> en la URL <code>/saludoform</code> recibe los datos del formulario en un objeto Java del tipo del modelo del formulario (el par\u00e1metro <code>userData</code>). Las anotaciones <code>@ModelAttribute</code> y <code>@Valid</code> indican que es un objeto recogido en el formulario sobre el que se ha realizado una validaci\u00f3n. Se detecta si ha habido alg\u00fan error en el m\u00e9todo <code>hasErrors()</code> del <code>bindingResult</code> que se recibe tambi\u00e9n como par\u00e1metro. </p> <p>Si ha habido error, se vuelve a devolver el formulario para que se vuelva a completar. Si no ha habido error se obtiene el nombre introducido en el formulario y se pasa a la plantilla del saludo.</p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#tests","title":"Tests","text":"<p>A partir de Spring Boot 2.4 se usa JUnit 5 como librer\u00eda de tests.</p> <p>En la aplicaci\u00f3n de demostraci\u00f3n hay varios ejemplos que muestran posibles formas de realizar pruebas en una aplicaci\u00f3n Spring Boot.</p> <p>Spring Boot incluye el framework AssertJ que permite realizar expresiones de prueba con un lenguaje muy expresivo.</p> <p>Los tests se pueden ejecutar usando el comando t\u00edpico de Maven:</p> <pre><code>$ mvn test\n</code></pre> <p>O tambi\u00e9n, usando el comando de Maven Wrapper:</p> <pre><code>$ ./mvnw test\n</code></pre> <p>Tambi\u00e9n se pueden lanzar desde el propio IntelliJ, pulsando en el panel del proyecto sobre el directorio de tests con el bot\u00f3n derecho. Los tests se lanzar\u00e1n y aparecer\u00e1 un panel en el que se mostrar\u00e1 si pasan correctamente (verde) o no.</p> <p></p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#tests-sobre-clases-de-servicio","title":"Tests sobre clases de servicio","text":"<p>Podemos realizar pruebas sobre la capa de servicio, obteniendo una instancia del servicio mediante inyecci\u00f3n de dependencias.</p> <p>En el siguiente ejemplo se muestra c\u00f3mo se prueba el m\u00e9todo de servicio <code>saluda</code>.</p> <p>Fichero <code>src/test/java/demoapp/ServiceTest.java</code></p> <pre><code>package demoapp;\n\nimport demoapp.service.SaludoService;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@SpringBootTest\npublic class ServiceTest {\n\n@Autowired\nSaludoService saludo;\n\n@Test\npublic void contexLoads() throws Exception {\nassertThat(saludo).isNotNull();\n}\n\n@Test\npublic void serviceSaludo() throws Exception {\nassertThat(saludo.saluda(\"Domingo\")).isEqualTo(\"Hola Domingo\");\n}\n}\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#tests-sobre-capa-web","title":"Tests sobre capa web","text":"<p>Es posible realizar tests sobre la capa de presentaci\u00f3n sin lanzar realmente el servidor web ni ejecutar realmente las peticiones HTTP. Se obtiene por inyecci\u00f3n de dependencias un mock de la clase <code>MockMvc</code> y se usan m\u00e9todos como <code>perform(get(\"/\"))</code> o <code>perform(post(\"/saludoform\").param(\"nombre\", \"Domingo\"))</code>.</p> <p>En el primer test del ejemplo siguiente se comprueba que una petici\u00f3n <code>GET</code> a la URL <code>/</code> devuelve un c\u00f3digo HTTP OK (200) y una p\u00e1gina HTML con la cadena esperada.</p> <p>En este test lo \u00fanico que se moquea es el servidor web, y se ejecuta el c\u00f3digo real del servicio, del controlador y de la plantilla.</p> <p>Se utilizan los m\u00e9todos <code>andDo</code> y <code>andExpect</code> de la propia librer\u00eda de testeo de Spring Framework y el m\u00e9todo <code>conteainsString</code> de la librer\u00eda de testeo Hamcrest.</p> <p>En el segundo test se realiza una petici\u00f3n <code>POST</code> para comprobar que el formulario funciona correctamente.</p> <p>Fichero <code>src/test/demoapp/MockMvcTest.java</code></p> <pre><code>package demoapp;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.hamcrest.Matchers.containsString;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class MockMvcTest {\n\n@Autowired\nprivate MockMvc mockMvc;\n\n// Hacemos una petici\u00f3n GET a un end point y comprobamos que\n// el HTML resultante es correcto\n@Test\npublic void shouldReturnDefaultMessage() throws Exception {\nthis.mockMvc.perform(get(\"/\"))\n.andExpect(status().isOk())\n.andExpect(content().string(containsString(\"Hello World\")));\n}\n\n// Podemos hacer tambi\u00e9n una petici\u00f3n POST y pasar los datos\n// del formulario con el m\u00e9todo .param\n@Test\npublic void postShoudReturnCorrectResponse() throws Exception {\nthis.mockMvc.perform(post(\"/saludoform\")\n.param(\"nombre\", \"Domingo\"))\n.andExpect(status().isOk())\n.andExpect(content().string(containsString(\"Hola Domingo\")));\n}\n}\n</code></pre> <p>Tambi\u00e9n es posible realizar un test \u00fanicamente del controlador y la plantilla de presentaci\u00f3n, moqueando el servicio. Se muestra en el fichero <code>MockServiceTest</code>.</p> <p>Fichero <code>src/test/demoapp/MockServiceTest.java</code></p> <pre><code>package demoapp;\n\nimport demoapp.service.SaludoService;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.mock.mockito.MockBean;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.hamcrest.Matchers.containsString;\nimport static org.mockito.Mockito.when;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class MockServiceTest {\n\n@Autowired\nprivate MockMvc mockMvc;\n\n// Podemos tambi\u00e9n mockear el servicio\n@MockBean\nprivate SaludoService service;\n\n@Test\npublic void greetingShouldReturnMessageFromService() throws Exception {\n\n// Y especificar lo que debe devolver una llamada a uno de sus m\u00e9todos\nwhen(service.saluda(\"Domingo\")).thenReturn(\"Hola Mock Domingo\");\n\nthis.mockMvc.perform(get(\"/saludo/Domingo\"))\n.andExpect(status().isOk())\n.andExpect(content().string(containsString(\"Hola Mock Domingo\")));\n}\n}\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#5-referencias","title":"5. Referencias","text":"<p>Puedes encontrar la documentaci\u00f3n de referencia de Spring Boot y Spring en las siguientes p\u00e1ginas, en la pesta\u00f1a Learn:</p> <ul> <li>Spring Boot</li> <li>Spring </li> </ul> <p>Tambi\u00e9n podemos encontrar tambi\u00e9n una extensa cantidad de tutoriales y gu\u00edas r\u00e1pidas en la web de Spring, en la url https://spring.io/guides.</p> <p>En concreto, hemos usado las siguientes referencias para construir esta primera aplicaci\u00f3n ejemplo:</p> <ul> <li>Building an Application with Spring Boot</li> <li>Serving Web Content with Spring  MVC</li> <li>Handling Form Submission</li> <li>Validating Form Input</li> <li>Spring Boot Reference Guide 2.6.10   (HTML, PDF)</li> </ul>"},{"location":"01-intro-spring-boot/practica1.html","title":"Enunciado de la pr\u00e1ctica","text":""},{"location":"01-intro-spring-boot/practica1.html#practica-1-primera-aplicacion-con-spring-boot","title":"Pr\u00e1ctica 1: Primera aplicaci\u00f3n con Spring Boot","text":"<p>En esta pr\u00e1ctica tendremos un primer contacto con Spring Boot, Git y Docker.</p> <p>Los objetivos principales son:</p> <ul> <li>Empezar a conocer Spring Boot, ejecutando una sencilla aplicaci\u00f3n hola mundo en Spring Boot.</li> <li>Empezar a conocer el framework de plantillas Thymeleaf, realizando   peque\u00f1as modificaciones en la aplicaci\u00f3n que usen un formulario.</li> <li>Trabajar de forma regular, realizando peque\u00f1os commits que se deben   subir al repositorio personal de la asignatura en GitHub.</li> <li>Crear una aplicaci\u00f3n desplegable usando Docker y publicar el contenedor en   DockerHub</li> </ul> <p>La duraci\u00f3n de la pr\u00e1ctica es de 1 semana, la fecha l\u00edmite de entrega es el d\u00eda 19 de septiembre y su puntuaci\u00f3n es de 0,4 puntos en la nota final de la asignatura.</p>"},{"location":"01-intro-spring-boot/practica1.html#1-instalacion-de-software","title":"1. Instalaci\u00f3n de software","text":"<p>Vamos a trabajar bastante con el terminal. En Linux o macOS podemos usar el terminal que viene con el sistema. En Windows se puede usar el terminal Git Bash que se instala en la instalaci\u00f3n de Git para Windows.</p> <p>Es posible desarrollar la pr\u00e1ctica en cualquier sistema operativo. Debemos instalar el siguiente software:</p> <ul> <li>Git</li> <li>Java JDK 8 o posterior</li> <li>IntelliJ Ultimate</li> </ul> <p>No puedo ayudar con posibles problemas en Windows</p> <p>Aunque en los apuntes aparezca informaci\u00f3n sobre c\u00f3mo trabajar desde Windows, no puedo garantizar que las instrucciones funcionen correctamente en todas las posibles configuraciones (aunque deber\u00edan funcionar bien, por estar trabajando con tecnolog\u00eda Java), ni te podr\u00e9 ayudar con posibles problemas, porque no es un sistema operativo que maneje habitualmente. Por tanto, si tienes Windows, te recomiendo que instales una m\u00e1quina virtual Linux y la uses para la pr\u00e1ctica.</p>"},{"location":"01-intro-spring-boot/practica1.html#intellij-ultimate","title":"IntelliJ Ultimate","text":"<p>Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate. Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA.</p>"},{"location":"01-intro-spring-boot/practica1.html#alta-en-github-educativo","title":"Alta en GitHub educativo","text":"<p>Darse de alta en GitHub con el correo de la UA y solicitar el registro como estudiante para obtener beneficios como el uso de GitHub Pro (que incluye Copilot) y poder solicitar el GitHub Student Developer pack con ofertas como $200 en  servidores de Digital Ocean.</p>"},{"location":"01-intro-spring-boot/practica1.html#instalacion-basica","title":"Instalaci\u00f3n b\u00e1sica","text":""},{"location":"01-intro-spring-boot/practica1.html#linux","title":"Linux","text":"<p>Para instalar el software en Linux.</p> <ul> <li>Instalar Git y Java:</li> </ul> <pre><code>$ sudo apt install git\n$ sudo apt install default-jdk\n</code></pre> <ul> <li>Instalar IntelliJ Ultimate</li> </ul>"},{"location":"01-intro-spring-boot/practica1.html#macos","title":"macOS","text":"<ul> <li>Git y Java vienen instalados con el sistema operativo. </li> <li>Instalar IntelliJ Ultimate</li> </ul>"},{"location":"01-intro-spring-boot/practica1.html#windows","title":"Windows","text":"<p>Es recomendable instalar git for Windows, que adem\u00e1s de Git instala Git BASH, un terminal Bash integrado en Windows.</p> <p>Adem\u00e1s, hay que instalar Java e IntelliJ Ultimate.</p>"},{"location":"01-intro-spring-boot/practica1.html#despues-de-la-instalacion-basica","title":"Despu\u00e9s de la instalaci\u00f3n b\u00e1sica","text":"<p>Es f\u00e1cil probar que funciona el software instalado. Basta con ejecutar desde el terminal:</p> <pre><code>$ git --version\n$ java -version (imprime la versi\u00f3n de Java)\n</code></pre>"},{"location":"01-intro-spring-boot/practica1.html#configuracion-del-prompt-para-que-aparezca-la-rama-de-git","title":"Configuraci\u00f3n del prompt para que aparezca la rama de Git","text":"<p>Bash</p> <p>Es tambi\u00e9n bastante \u00fatil configurar el prompt para que aparezca la rama del repositorio Git en que nos encontramos. Para ello se debe a\u00f1adir en el fichero <code>$HOME/.bashrc</code> (linux y Git Bash Windows) o <code>$HOME/.bash_profile</code> (macOS con shell <code>bash</code>) :</p> <pre><code>parse_git_branch() {\n    git branch 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/* \\(.*\\)/ (\\1)/'\n}\nexport PS1=\"\\[\\e[37m\\]\\A \\[\\e[m\\]\\[\\033[32m\\]\\W\\[\\033[33m\\]\\$(parse_git_branch)\\[\\033[00m\\] $ \"\n</code></pre> <p>Podemos encontrar m\u00e1s opciones de configuraci\u00f3n del prompt en muchas p\u00e1ginas en Internet. Por ejemplo aqu\u00ed.</p> <p>Zsh</p> <p>Si trabajas con el shell <code>zsh</code> que viene por defecto en MacOS, debes a\u00f1adir en el fichero <code>.zshrc</code> lo siguiente:</p> <pre><code>parse_git_branch() {\n    git branch 2&gt; /dev/null | sed -n -e 's/^\\* \\(.*\\)/ [\\1]/p'\n}\nsetopt PROMPT_SUBST\nexport PROMPT='%1~%F{green}$(parse_git_branch)%f %% '\n</code></pre>"},{"location":"01-intro-spring-boot/practica1.html#2-creacion-del-repositorio-github-con-la-practica","title":"2. Creaci\u00f3n del repositorio GitHub con la pr\u00e1ctica","text":"<p>Para inicializar el repositorio de GitHub en el que vas a trabajar en esta pr\u00e1ctica debes seguir los siguientes pasos:</p> <ol> <li> <p>Inicializa tu nombre de usuario y tu correo en Git. El nombre de    usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits. Pon tu nombre    y apellido.</p> <pre><code>$ git config --global user.name \"Pepe Perez\"\n$ git config --global user.email pepe.perez@example.com\n</code></pre> </li> <li> <p>Crea una cuenta en GitHub. Puedes usar el nombre de usuario que    quieras (o usar el que ya tienes), pero escribe correctamente tu    nombre y apellidos en el perfil usando la opci\u00f3n Settings &gt;    Profile y actualizando el campo Name.</p> </li> <li> <p>Una vez logeado en GitHub, pincha en el enlace con una invitaci\u00f3n    que compartiremos en el foro de Moodle. Deber\u00e1s aceptar las    peticiones de GitHub Classroom y podr\u00e1s aceptar la pr\u00e1ctica Spring    Boot Demo App. </p> <p></p> <p>Se crear\u00e1 autom\u00e1ticamente el repositorio <code>springboot-demo-app-&lt;usuario&gt;</code> en la organizaci\u00f3n mads-ua-23-24. Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial del proyecto demostraci\u00f3n de Spring Boot (es una copia del repositorio domingogallardo/spring-boot-demoapp).</p> <p></p> <p>Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n <code>mads-ua-23-24</code>. Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas o pulsando en el icono de GitHub:</p> <p></p> </li> <li> <p>El profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n <code>mads-ua-23-24</code>    y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s    aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n    accediendo a https://github.com/mads-ua-23-24.</p> </li> </ol>"},{"location":"01-intro-spring-boot/practica1.html#3-aplicacion-demo-de-spring-boot","title":"3. Aplicaci\u00f3n Demo de Spring Boot","text":"<p>Haremos una primera pr\u00e1ctica sencilla en la que primero pondremos en marcha y publicaremos una aplicaci\u00f3n inicial en Spring Boot y despu\u00e9s a\u00f1adiremos alguna funcionalidad.</p> <p>En el documento Introducci\u00f3n a Spring Boot se explica c\u00f3mo ejecutar una aplicaci\u00f3n Spring Boot y c\u00f3mo lanzar sus tests. Tambi\u00e9n se proporciona una introducci\u00f3n a los distintos componentes de la aplicaci\u00f3n. Debes leerlo y aprender el funcionamiento b\u00e1sico de este framework.</p>"},{"location":"01-intro-spring-boot/practica1.html#construccion-y-ejecucion-de-la-aplicacion","title":"Construcci\u00f3n y ejecuci\u00f3n de la aplicaci\u00f3n","text":"<p>Lo primero que deber\u00e1s hacer ser\u00e1 descargar la aplicaci\u00f3n  <code>demo-spring-boot</code> que tienes en el repositorio creado en el punto  anterior y comprobar que funciona correctamente. Debes hacer lo siguiente:</p> <ol> <li> <p>Configura un Personal Access    Token (PAT)    en GitHub para poder autenticarte desde el terminal. Dale todos los    permisos de acceso a repositorios y copia la clave generada. Ser\u00e1    la contrase\u00f1a que deber\u00e1s introducir cuando un comando git te la    pida.</p> </li> <li> <p>Descarga en tu ordenador el repositorio creado en GitHub en el apartado    anterior, usando el comando <code>git clone</code>:</p> <pre><code>$ git clone https://github.com/mads-ua-23-24/springboot-demo-app-&lt;usuario&gt;.git\n</code></pre> <p>Cuando git te pida autenticaci\u00f3n, usa como nombre de usuario tu usuario de GitHub y como contrase\u00f1a el PAT que has creado anteriormente.</p> </li> </ol> <p>Una vez descargado el repositorio con la aplicaci\u00f3n deber\u00e1s ejecutarla desde la l\u00ednea de comandos, probar los tests e importarla en IntelliJ y ejecutar y depurar con el IDE la aplicaci\u00f3n y los tests.</p> <ol> <li> <p>Desde el directorio donde est\u00e1 la aplicaci\u00f3n, probamos todos sus    tests usando el Maven Wrapper:</p> <pre><code>$ ./mvnw test\n</code></pre> </li> <li> <p>Para poner en marcha la aplicaci\u00f3n la arrancamos como una    aplicaci\u00f3n Java:</p> <pre><code>$ ./mvnw package\n$ java -jar target/demoapp-0.0.1-SNAPSHOT.jar \n</code></pre> <p>Tambi\u00e9n podemos lanzarla usando el plugin <code>spring-boot</code> de Maven:</p> <pre><code>$ ./mvnw spring-boot:run\n</code></pre> <p>La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio.</p> <p>En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas:</p> <ul> <li>http://localhost:8080</li> <li>http://localhost:8080/saludo/Pepito</li> <li>http://localhost:8080/saludoplantilla/Pepito</li> <li>http://localhost:8080/saludoform</li> </ul> </li> </ol> <p>Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate. Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA.</p> <p>Tambi\u00e9n es recomendable instalar el plugin GithHub Copilot para JetBrains para trabajar con este asistente de IA como ayudante de c\u00f3digo. Tras instalar el plugin deber\u00e1s activarlo introduciendo tu usuario de GitHub.</p> <p>Puedes trabajar de forma gratuita con GitHub Copilot d\u00e1ndote de alta en el GitHub Student Developer Pack.</p> <ol> <li> <p>Abre proyecto el en IntelliJ. Debes importar el directorio donde se    encuentre el fichero <code>pom.xml</code>. Se puede hacer desde la pantalla de    bienvenida de IntelliJ con la opci\u00f3n Import Project o usando la    opci\u00f3n \"File &gt; New &gt; Project from Existing    Sources. Aparecer\u00e1 la pantalla de importaci\u00f3n y seleccionamos el    importador Maven:</p> <p></p> <p>IntelliJ abre el proyecto correctamente:</p> <p></p> <p>Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n:</p> <p></p> <p>Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc:</p> <p></p> <p>Desde la configuraci\u00f3n de Run tambi\u00e9n podemos depurar el proyecto, pulsando el bot\u00f3n de depuraci\u00f3n.</p> <p></p> </li> <li> <p>Lanza los tests desde el propio IntelliJ, pulsando en el    panel del proyecto sobre el directorio de tests con el bot\u00f3n    derecho. Los tests se lanzar\u00e1n y aparecer\u00e1 un panel en el que se    mostrar\u00e1 si pasan correctamente (verde) o no.</p> <p></p> </li> </ol> <p>Por \u00faltimo, haz alg\u00fan peque\u00f1o cambio a la aplicaci\u00f3n. </p> <ol> <li> <p>Cambia el mensaje de saludo que da el controller de la ra\u00edz para incluir tu nombre.     Comprueba que los tests pasan (modif\u00edcalos si no es as\u00ed) y que la aplicaci\u00f3n funciona    correctamente.</p> <p></p> </li> </ol>"},{"location":"01-intro-spring-boot/practica1.html#dockerizacion-de-la-aplicacion","title":"Dockerizaci\u00f3n de la aplicaci\u00f3n","text":"<p>Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. </p> <p>Las m\u00e1quinas Docker son muy eficientes porque comparten los servicios del sistema operativo en el que se ejecutan, utilizando menos recursos que las m\u00e1quinas virtuales tradicionales. </p> <p>Docker proporciona un sistema muy sencillo de distribuci\u00f3n y puesta en producci\u00f3n de software, ya que las m\u00e1quinas Docker pueden ser distribuidas usando repositorios (como Docker Hub) y ejecutadas en cualquier ordenador que tenga instalado el Docker Engine.</p> <p>La tecnolog\u00eda es muy popular y se usa en gran cantidad de empresas de desarrollo para simplificar la ejecuci\u00f3n en en m\u00faltiples entornos y para que los contenedores (m\u00e1quinas Docker en ejecuci\u00f3n) se pueden configurar y combinar o ejecutar en clusters usando herramientas como Kubernetes.</p> <p>En nuestro caso, vamos a construir una m\u00e1quina Docker basada en la aplicaci\u00f3n demo. Posteriormente, la publicaremos en Docker Hub y  la desplegaremos en un host para ponerla en producci\u00f3n.</p> <ol> <li> <p>Instala Docker    Desktop. Los    usuarios de Linux deb\u00e9is seguir las instrucciones de esta    p\u00e1gina para    instalar Docker Engine. Usaremos la l\u00ednea de comando para lanzar    los comandos Docker. La aplicaci\u00f3n Docker Desktop permite usar una    interfaz de usuario para interactuar con im\u00e1genes y contenedores,    pero no proporciona ninguna funcionalidad que no est\u00e9 disponible en    la l\u00ednea de comando.</p> <p>Una vez instalado puedes probar el tutorial r\u00e1pido (2 minutos)  desde Docker Desktop para comprobar que todo funciona  correctamente. Tambi\u00e9n puedes desde el terminal comprobar la  versi\u00f3n de Docker instalada:</p> <pre><code>$ docker version\n</code></pre> </li> <li> <p>Crea una cuenta de usuario en Docker    Hub. De esta forma tendr\u00e1s un repositorio    en el que podr\u00e1s subir las im\u00e1genes de las m\u00e1quinas Docker que    construyas. Deber\u00e1s dar un nombre de usuario que ser\u00e1 el que    utilizar\u00e1s para publicar estas im\u00e1genes.</p> </li> <li> <p>Crea un fichero llamado <code>Dockerfile</code> (sin extensi\u00f3n) en el   directorio ra\u00edz de la aplicaci\u00f3n con el siguiente contenido:</p> <p>Fichero <code>./Dockerfile</code>:</p> <pre><code>FROM openjdk:8-jdk-alpine\nCOPY target/*.jar app.jar\nENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/urandom\",\"-jar\",\"/app.jar\"]\n</code></pre> <p>El fichero <code>Dockerfile</code> consiste en un conjunto secuencial de instrucciones con las que se construye la m\u00e1quina Docker:</p> <ul> <li><code>FROM</code>: este comando indica la m\u00e1quina base sobre la que se van   a ejecutar el resto de comandos. En nuestro caso una m\u00e1quina de   la organizaci\u00f3n <code>openjdk</code> que contiene la distribuci\u00f3n 8 del   <code>Java Development Kit (JDK)</code> y que est\u00e1 basada en una   distribuci\u00f3n linux Alpine. El primer paso de la construcci\u00f3n de   nuestra m\u00e1quina Docker consiste por tanto en descargar esta   m\u00e1quina <code>openjdk:8-jdk-alpine</code> y usarla como m\u00e1quina base.</li> <li><code>COPY</code>: este comando indica que se debe copiar un fichero o   conjunto de ficheros de la m\u00e1quina host (el directorio en el que   estamos) en la m\u00e1quina base. En este caso se copia el fichero   JAR que constituye nuestra aplicaci\u00f3n que est\u00e1 situado en el   directorio <code>./target</code> y se copia en la m\u00e1quina Docker con el   nombre <code>app.jar</code>.</li> <li> <p><code>ENTRYPOINT</code>: este comando indica el comando a ejecutar cuando se   pone en marcha la m\u00e1quina Docker. En este caso se lanza la   aplicaci\u00f3n (<code>app.jar</code>) con el comando <code>java -jar</code>. </p> <p>El modificador <code>-Djava.security.egd</code> hace que se inicialice el generador de n\u00fameros aleatorios de Java usando el fichero del sistema <code>/dev/urandom</code> en lugar del fichero por defecto <code>/dev/random</code>. Es necesario para resolver un bug que aparece al ejecutar el contenedor en servidores como los alojados en DigitalOcean.</p> </li> </ul> </li> <li> <p>Vuelve a compilar la aplicaci\u00f3n para asegurarte de que se genera el fichero    JAR que la contiene. Este fichero es que vamos a dockerizar.</p> <pre><code>$ ./mvnw package\n$ ls -l ./target/*.jar\n./target/demoapp-0.0.1-SNAPSHOT.jar\n</code></pre> </li> <li> <p>Ya puedes construir la m\u00e1quina Docker con el siguiente comando,   desde el directorio ra\u00edz de la aplicaci\u00f3n (en el que debe estar el   fichero <code>Dockerfile</code> anterior):</p> <pre><code>$ docker build -t &lt;usuario-docker&gt;/spring-boot-demoapp . </code></pre> <p>Comprueba que la imagen se ha creado correctamente. Debe aparecer en el Docker Desktop y con el comando <code>docker image ls</code>:</p> <pre><code>$ docker image ls \nREPOSITORY                            TAG\ndomingogallardo/spring-boot-demoapp   latest </code></pre> </li> <li> <p>Pon en marcha un la imagen con la aplicaci\u00f3n:</p> <pre><code>$ docker run -p 8080:8080 &lt;usuario-docker&gt;/spring-boot-demoapp\n</code></pre> <p>El comando <code>docker run</code> pone en marcha la imagen indicada, creando lo que se denomina un contenedor Docker. Es similar a una m\u00e1quina virtual en ejecuci\u00f3n. El par\u00e1metro <code>-p 8080:8080</code> indica que el puerto interno 8080 del contenedor se va a mapear en el puerto 8080 del host. De esta forma podremos conectarnos desde el host a la aplicaci\u00f3n Spring Boot en funcionamiento.</p> <p>Ver\u00e1s que en la consola aparecen los mensajes de salida de la aplicaci\u00f3n Spring Boot que se ejecuta en el contenedor.</p> <p>Prueba a abrir un navegador y conectarte a la URL localhost:8080. Deber\u00e1s ver el mensaje de saludo de la aplicaci\u00f3n ejecut\u00e1ndose en el contendor.</p> <p>Haciendo <code>ctrl+c</code> puedes parar el contenedor. El efecto es similar a suspender una m\u00e1quina virtual. Puedes ver el identificador del contenedor con el comando:</p> <p><pre><code>$ docker container ls -a\nCONTAINER ID   IMAGE                NAMES\n5bd9d0b055a9   domingogallardo/spring-boot-demoapp  inspiring_feynman\n</code></pre> Puedes usar tanto el ID del contenedor (<code>5bd9d0b055a9</code>) como su nombre (<code>inspiring_feynman</code>) para identificarlo.</p> <p>Estando parado, puedes volver a poner en marcha el contenedor haciendo:</p> <pre><code>$ docker container start &lt;identificador&gt;\n</code></pre> <p>Tambi\u00e9n podemos parar el contenedor:</p> <pre><code>$ docker container stop &lt;identificador&gt;\n</code></pre> <p>Y borrarlo definitivamente con </p> <pre><code>$ docker container rm &lt;identificador&gt;\n</code></pre> <p>Otros comandos \u00fatiles de Docker son:</p> <ul> <li><code>docker run -d</code> : lanza el contendor en modo background.</li> <li><code>docker run --rm</code> : lanza el contenedor de forma que al pararlo   se borra autom\u00e1ticamente.</li> <li><code>docker container logs &lt;identificador&gt;</code> : muestra los logs del   contenedor indicado.</li> </ul> <p>En la aplicaci\u00f3n Docker Engine podemos realizar tambi\u00e9n muchos de estos comandos interactuando directamente con la interfaz. Pru\u00e9balo.</p> </li> <li> <p>Ahora que has comprobado que el fichero <code>Dockerfile</code> funciona    correctamente debes a\u00f1adirlo a git y subirlo al respositorio    GitHub:</p> <pre><code>$ git status\n$ git add .\n$ git status\n$ git commit -m \"A\u00f1adido Dockerfile\"\n$ git push\n</code></pre> </li> <li> <p>Vamos a terminar publicando la imagen en tu cuenta de Docker Hub.</p> <ul> <li> <p>Ve a Docker Hub y log\u00e9ate.</p> </li> <li> <p>Crea un repositorio p\u00fablico con el nombre <code>spring-boot-demoapp</code>. En   ese repositorio vas a subir la imagen con el mismo nombre. En un   repositorio Docker puedes mantener m\u00faltiples versiones de una misma   imagen, usando tags.</p> </li> <li> <p>Una vez creado el repositorio puedes publicar la imagen en \u00e9l   loge\u00e1ndote desde la l\u00ednea de comando (introduce tu usuario y   contrase\u00f1a de Docker Hub) y con el comando <code>docker push</code>:</p> </li> </ul> <pre><code>$ docker login\n$ docker push &lt;usuario-docker&gt;/spring-boot-demoapp\n</code></pre> <p>Ver\u00e1s que autom\u00e1ticamente se asigna la etiqueta <code>latest</code>   (etiqueta por defecto) a la imagen y que \u00e9sta se sube al   repositorio. Podr\u00edas asignar una etiqueta espec\u00edfica a la imagen   con el comando <code>docker tag</code>. Por ejemplo, si quisi\u00e9ramos fijar   esta imagen con la versi\u00f3n <code>1.0</code> podr\u00edamos hacerlo con el   siguiente comando:</p> <pre><code>$ docker tag &lt;usario-docker&gt;/spring-boot-demoapp &lt;usuario-docker&gt;/spring-boot-demoapp:1.0\n</code></pre> <ul> <li>Comprueba en la p\u00e1gina web del repositorio que se   ha subido. El repositorio es p\u00fablico y cualquiera puede   descargar la imagen haciendo:</li> </ul> <pre><code>$ docker pull &lt;usuario-docker&gt;/spring-boot-demoapp\n</code></pre> <p>Al no indicar la etiqueta, se descargar\u00eda la imagen etiquetada   con <code>latest</code>. Si quisi\u00e9ramos descargar una versi\u00f3n concreta   habr\u00eda que especificar la etiqueta:</p> <pre><code>$ docker pull &lt;usuario-docker&gt;/spring-boot-demoapp:1.0\n</code></pre> </li> <li> <p>Escribe en el fichero <code>README.md</code> del repositorio GitHub un enlace a la     vista p\u00fablica de la imagen en Docker Hub. La vista p\u00fablica tiene el     formato     https://hub.docker.com/r/domingogallardo/spring-boot-demoapp.</p> </li> </ol> <p>Importante</p> <p>Aseg\u00farate de que es posible acceder al enlace de tu imagen docker  sin estar logeado en DockerHub. Abre otro navegador diferente en el que no est\u00e9s logeado y prueba que el enlace funciona correctamente. Ese enlace es el que voy a usar para comprobar el funcionamiento correcto de la pr\u00e1ctica.</p>"},{"location":"01-intro-spring-boot/practica1.html#4-estudia-el-funcionamiento-de-la-aplicacion-y-su-arquitectura","title":"4. Estudia el funcionamiento de la aplicaci\u00f3n y su arquitectura","text":"<p>En el documento Introducci\u00f3n a Spring Boot se comenta el c\u00f3digo fuente de la aplicaci\u00f3n Spring Boot con la que estamos trabajando. L\u00e9elo despacio, revisando tambi\u00e9n el c\u00f3digo fuente, para entender los aspectos b\u00e1sicos (controladores, servicios, inyecci\u00f3n de dependencias, plantillas) del funcionamiento de Spring Boot.</p> <p>Estudia tambi\u00e9n despacio el funcionamiento de los tests y el funcionamiento del formulario y la validaci\u00f3n. </p> <p>Puedes ver un ejemplo adicional de validaci\u00f3n de un formulario en el repositorio domingogallardo/spring-boot-validate.</p> <p>Ver\u00e1s tambi\u00e9n ah\u00ed varios ejemplos de tests en los que se realiza una petici\u00f3n POST pasando par\u00e1metros y se obtiene informaci\u00f3n del modelo resultante, llamando al m\u00e9todo <code>model()</code>. El siguiente es un ejemplo de uno de los tests:</p> <pre><code>@Test\npublic void checkPersonInfoWhenNameTooShortThenFailure() throws Exception {\nmockMvc.perform(post(\"/\")\n.param(\"name\", \"R\")\n.param(\"age\", \"20\"))\n.andExpect(model().hasErrors());\n}\n</code></pre>"},{"location":"01-intro-spring-boot/practica1.html#5-anadimos-alguna-funcionalidad-sencilla-a-la-aplicacion","title":"5. A\u00f1adimos alguna funcionalidad sencilla a la aplicaci\u00f3n","text":"<p>Para demostrar que comprendes el funcionamiento de una aplicaci\u00f3n Spring Boot, debes a\u00f1adir alguna funcionalidad sencilla a la aplicaci\u00f3n Demo. Debes definir t\u00fa la funcionalidad a implementar. Por ejemplo, cualquiera de los siguientes ejemplos o alguno similar que se te ocurra:</p> <ul> <li>Pal\u00edndroma: lee una palabra y comprueba si es pal\u00edndroma.</li> <li>N\u00famero par: lee un n\u00famero y comprueba si es par</li> <li>Cuadrado: lee dos n\u00fameros y comprueba si el segundo es el cuadrado del primero</li> <li>Calculadora: lee un par de n\u00fameros y una operaci\u00f3n y devuelve el resultado.</li> </ul> <p>La aplicaci\u00f3n debe realizar lo siguiente:</p> <ul> <li>Leer datos de un formulario usando Thymeleaf y realizar alguna validaci\u00f3n.</li> <li>Llamar a un m\u00e9todo de servicio que procese los datos le\u00eddos.</li> <li>Mostrar el resultado devuelto por el servicio en una p\u00e1gina Thymeleaf.</li> <li>Tests de la capa de servicio y de la capa de presentaci\u00f3n   (controllers web).</li> <li>En la p\u00e1gina principal de la aplicaci\u00f3n debe aparecer tu nombre y apellidos.</li> </ul> <p>Muy importante, debemos desarrollar la aplicaci\u00f3n en peque\u00f1os commits. Cada commit debe compilar correctamente y a\u00f1adir una peque\u00f1a funcionalidad o debe realizar una refactorizaci\u00f3n en la que no se incluye ninguna nueva funcionalidad pero se mejora el c\u00f3digo. </p> <p>Debemos subir los commits al repositorio de GitHub.</p> <p>Peque\u00f1os commits</p> <p>Para la realizaci\u00f3n correcta de la pr\u00e1ctica debes ir construyendo la aplicaci\u00f3n a base de peque\u00f1os commits que incrementen su funcionalidad. Si no has trabajado nunca de esta forma te resultar\u00e1 algo complicado al principio, pero poco a poco ir\u00e1s cogi\u00e9ndole el tranquillo.</p> <p>La idea es que antes de emepezar a escribir el c\u00f3digo debes tener claro qu\u00e9 cosas quieres hacer. Veremos que la t\u00e9cnica de TDD nos ayuda a ello, pero por ahora no vamos a usarla. </p> <p>Por ejemplo, si queremos hacer una aplicaci\u00f3n que compruebe si una palabra  es pal\u00edndroma necestaremos una funci\u00f3n en un servicio que haga esa comprobaci\u00f3n. Procedemos entonces a escribir c\u00f3digo para implementarla. Antes de grabar el commit debemos comprobar que funciona correctamente. \u00bfC\u00f3mo lo hacemos? Podemos hacerlo de dos formas: crear un sencillo controller que la llame a esa funci\u00f3n con un ejemplo concreto o crear un test. Una vez comprobado que funciona correctamente la funci\u00f3n grabamos el commit.</p> <p>Una vez terminada la capa de servicio deberemos programar el controller y el formulario para usar la aplicaci\u00f3n. Tambi\u00e9n lo debemos hacer poco a poco, con commits peque\u00f1os. Por ejemplo, primero podemos programar una versi\u00f3n sencilla (primer commit), despu\u00e9s podemos a\u00f1adir validaciones al formulario (segundo commit) y por \u00faltimo podemos hacer alg\u00fan retoque del aspecto de la aplicaci\u00f3n (tercer commit).</p> <p>Cuando termines de implementar todos los tests (cuantos m\u00e1s mejor) y compruebes que funcionan correctamente y que la aplicaci\u00f3n funciona bien en local, debes crear la m\u00e1quina Docker con la etiqueta <code>final</code> y subirla a tu repositorio DockerHub.</p>"},{"location":"01-intro-spring-boot/practica1.html#6-comandos-git","title":"6. Comandos Git","text":"<p>Comandos Git necesarios para realizar la pr\u00e1ctica:</p> <ul> <li>git clone</li> <li>git status</li> <li>git add</li> <li>git commit</li> <li>git push</li> <li>git log</li> </ul> <p>Puedes encontrar m\u00e1s informaci\u00f3n sobre estos comandos en el documento Resumen de comandos Git que resume los conceptos m\u00e1s importantes de Git necesarios para estas primeras pr\u00e1cticas de la asignatura.</p>"},{"location":"01-intro-spring-boot/practica1.html#7-entrega","title":"7. Entrega","text":"<ul> <li> <p>La pr\u00e1ctica tiene una duraci\u00f3n de 1 semana y debe estar terminada   el martes 19 de septiembre.</p> </li> <li> <p>La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 4% en la nota   final de la asignatura.</p> </li> </ul> <p>Para realizar la entrega debes hacer lo siguiente:</p> <ul> <li>Realizar la aplicaci\u00f3n en el repositorio creado e ir subiendo los   commits a GitHub conforme se van realizando.</li> <li>Actualizar el fichero <code>README.md</code> con el enlace a la vista p\u00fablica de la   imagen subida DockerHub. En esa p\u00e1gina debe estar la imagen con la etiqueta   <code>final</code>. El formato de la URL debe ser   <code>https://hub.docker.com/r/&lt;usuario-docker&gt;/spring-boot-demoapp</code>.</li> <li>A\u00f1adir una p\u00e1gina de documentaci\u00f3n <code>doc/practica1.md</code> en la que se   explique brevemente tanto la funcionalidad como la implementaci\u00f3n y tests   a\u00f1adidos. Se debe incluir tambi\u00e9n la URL  de los repositorios en GitHub y en Docker   Hub. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes   disponible en GitHub una breve pero \u00fatil introducci\u00f3n a   Markdown.</li> <li>Entregar en Moodle un ZIP con el directorio del proyecto (incluyendo el   directorio .git con el repositorio git), despu\u00e9s de haber hecho   <code>./mvnw clean</code> para eliminar los binarios compilados.</li> </ul> <p>Para la evaluaci\u00f3n se tendr\u00e1 en cuenta:</p> <ul> <li>Desarrollo continuo (los commits deben realizarse a lo largo de   toda la semana y no dejar todo para el \u00faltimo d\u00eda).</li> <li>Commits peque\u00f1os, cada commit debe ser funcional e introducir alg\u00fan elemento   nuevo o realizar alguna refactorizaci\u00f3n.</li> <li>Correcto desarrollo de la metodolog\u00eda.</li> <li>Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las   caracter\u00edsticas desarrolladas.</li> </ul> <p>Penalizaci\u00f3n por realizar la pr\u00e1ctica el \u00faltimo d\u00eda</p> <p>En la asignatura se recompensa el trabajo continuo y la realizaci\u00f3n de los commits a lo largo de toda la semana. Si se realiza todo el trabajo en el \u00faltimo d\u00eda se tendr\u00e1 una penalizaci\u00f3n en la nota.</p>"},{"location":"02-todolist/practica2.html","title":"Pr\u00e1ctica 2: Aplicaci\u00f3n ToDoList","text":""},{"location":"02-todolist/practica2.html#1-objetivos","title":"1. Objetivos","text":"<p>En pr\u00e1ctica 2 vamos a trabajar sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial.</p> <p>La duraci\u00f3n de la pr\u00e1ctica es de 4 semanas, la fecha l\u00edmite de entrega es el d\u00eda 17 de octubre y su puntuaci\u00f3n es de 1 punto en la nota final de la asignatura.</p> <p>Deber\u00e1s realizar la pr\u00e1ctica de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues, pull requests, releases y actualizando los tableros del proyecto (en Trello y en GitHub).</p> <p>Al igual que en la pr\u00e1ctica 1 usaremos GitHub Classroom para crear un repositorio individual con el que realizar\u00e1s la pr\u00e1ctica. El proyecto base ser\u00e1 la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial. En este repositorio se ha seguido una metodolog\u00eda similar a la que vamos a utilizar en este pr\u00e1ctica y puedes examinarlo para ver distintos elementos:</p> <ul> <li>Issues cerrados</li> <li>Pull Requests mezclados</li> <li>Tablero de issues</li> <li>Tablero Trello de historias de usuario</li> </ul> <p>Debes leer la introducci\u00f3n a Spring Boot para entender los conceptos fundamentales del framework.</p>"},{"location":"02-todolist/practica2.html#2-aplicacion-inicial","title":"2. Aplicaci\u00f3n inicial","text":"<p>La aplicaci\u00f3n con la que vamos a trabajar es una t\u00edpica aplicaci\u00f3n ToDo que sirve para gestionar tareas pendientes. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer.</p> <p>A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n.</p>  Pantalla de login   Pantalla con listado de tareas  <p>Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es mads-todolist.</p>"},{"location":"02-todolist/practica2.html#3-la-aplicacion-todolist","title":"3. La aplicaci\u00f3n ToDoList","text":"<p>La aplicaci\u00f3n mads-todolist-inicial es la versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante toda la asignatura.</p> <p>Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista en la pr\u00e1ctica 1. Entre otros, tiene los siguientes elementos:</p> <ul> <li>Distintos comandos HTTP: GET, POST, DELETE.</li> <li>Recogida de datos en formularios HTML y validaci\u00f3n de los datos.</li> <li>Base de datos gestionada con JPA (Java Persisence API), un ORM (Object Relational   Mapping) implementado por la librer\u00eda Hibernate. Se utiliza una   capa de persistencia basada en clases repository.</li> <li>Capa de servicio que proporciona la l\u00f3gica de negocio a los   controllers.</li> <li>Las clases controller s\u00f3lo se encargan de hacer de interfaz de la   capa de servicio: <ul> <li>Recoger datos de la petici\u00f3n HTTP,</li> <li>tratar y validar estas entradas, </li> <li>llamar a la clase de servicio para que se realice la acci\u00f3n   requerida, y</li> <li>convertir la respuesta obtenida de la aplicaci\u00f3n en una vista   que se devuelve como respuesta de la petici\u00f3n.</li> </ul> </li> <li>En las plantillas se incluye Bootstrap y scripts JavaScript.</li> <li>Las clases de servicio y de repository se obtienen por inyecci\u00f3n   de dependencias.</li> <li>Gran n\u00famero de tests que prueban la capa de servicios y la de presentaci\u00f3n.</li> </ul> <p>Vamos a ver con un poco m\u00e1s de detalle d\u00f3nde puedes encontrar en el c\u00f3digo todos estos elementos.</p>"},{"location":"02-todolist/practica2.html#configuracion-de-la-aplicacion","title":"Configuraci\u00f3n de la aplicaci\u00f3n","text":"<p>Los distintos par\u00e1metros de la aplicaci\u00f3n Spring Boot se configuran un fichero de propiedades. El fichero de propiedades por defecto es <code>application.properties</code>.</p> src/main/resources/application.properties<pre><code>spring.application.name = mads-todolist\nspring.datasource.url=jdbc:h2:mem:dev\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect\nspring.jpa.hibernate.ddl-auto=update\nlogging.level.org.hibernate.SQL=debug\nlogging.level.madstodolist=debug\nspring.sql.init.mode=never\nspring.h2.console.enabled=true\nspring.h2.console.path=/h2-console\n\n# Activamos el perfil dev\nspring.profiles.active=dev\n\n# Deshabilitamos Open EntityManager in View\n# https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/html/data.html#data.sql.jpa-and-spring-data.open-entity-manager-in-view\n# Ver tambien https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/hibernate5/support/OpenSessionInViewInterceptor.html\n# y https://www.baeldung.com/spring-open-session-in-view\nspring.jpa.open-in-view=false\n</code></pre> <p>Entre otras cosas, se define las caracter\u00edsticas de la fuente de datos con la que trabaja la aplicaci\u00f3n (la base de datos en memoria H2):</p> <ul> <li>El par\u00e1metro <code>spring.jpa.hibernate.ddl-auto=update</code> hace que   Hibernate actualice autom\u00e1ticamente los esquemas de la base de   datos, construy\u00e9ndolos a partir de las clases <code>Entity</code>. En un   entorno de producci\u00f3n el valor de esta propiedad deber\u00e1 ser   <code>validate</code> para no modificar la base de datos de producci\u00f3n.</li> <li>El par\u00e1metro <code>spring.profiles.active=dev</code> define el perfil que se activa por   defecto al lanzar la aplicaci\u00f3n, el perfil de desarrollo (<code>dev</code>). En pr\u00e1cticas   posteriores veremos c\u00f3mo es \u00fatil usar distintos perfiles (por ejemplo,   desarrollo y producci\u00f3n) para configurar qu\u00e9 bases de datos se van a usar.</li> </ul> <p>Los datos iniciales de la aplicaci\u00f3n se cargan mediante el servicio <code>InitDbService</code>. S\u00f3lo se cargan si el perfil activo es <code>dev</code>.</p> src/main/java/madstodolist/service/InitDbService.java<pre><code>@Service\n// Se ejecuta solo si el perfil activo es 'dev'\n@Profile(\"dev\")\npublic class InitDbService {\n\n@Autowired\nprivate UsuarioRepository usuarioRepository;\n@Autowired\nprivate TareaRepository tareaRepository;\n\n// Se ejecuta tras crear el contexto de la aplicaci\u00f3n\n// para inicializar la base de datos\n@PostConstruct\npublic void initDatabase() {\nUsuario usuario = new Usuario(\"user@ua\");\nusuario.setNombre(\"Usuario Ejemplo\");\nusuario.setPassword(\"123\");\nusuarioRepository.save(usuario);\n\nTarea tarea1 = new Tarea(usuario, \"Lavar coche\");\ntareaRepository.save(tarea1);\n\nTarea tarea2 = new Tarea(usuario, \"Renovar DNI\");\ntareaRepository.save(tarea2);\n}\n\n}\n</code></pre> <p>Base de datos H2 en memoria en desarrollo</p> <p>En esta pr\u00e1ctica vamos a trabajar \u00fanicamente con la base de datos en memoria. Esto significa que los datos que introduzcamos van a estar presentes mientras que la aplicaci\u00f3n est\u00e9 funcionando. Cuando matemos la aplicaci\u00f3n y la volvamos a reiniciar s\u00f3lo estar\u00e1n los datos iniciales, los datos que se cargan con el servicio <code>InitDbService</code>.</p> <p>En la pr\u00e1ctica 3 utilizaremos una base de datos real, que deberemos gestionar tambi\u00e9n en producci\u00f3n. En concreto, se tratar\u00e1 de una base de datos PostgresSQL.</p> <p>Por \u00faltimo, el par\u00e1metro <code>spring.jpa.open-in-view=false</code> deshabilita una caracter\u00edstica de Spring denominada open in view que mantiene abierta la conexi\u00f3n de la base de datos de forma autom\u00e1tica en cada petici\u00f3n HTTP. Se trata de una caracter\u00edstica que facilita el trabajo con las relaciones lazy entre entidades, pero puede introducir errores no deseados al permitir acceder a la base de datos en la capa controller. Al deshabilitar esta caracter\u00edstica tendremos que gestionar manualmente las relaciones lazy, recuper\u00e1ndolas en la capa de servicio, en donde s\u00ed que mantenemos abierta la conexi\u00f3n con la base de datos. Lo veremos m\u00e1s adelante con m\u00e1s detalle.</p>"},{"location":"02-todolist/practica2.html#otras-configuraciones","title":"Otras configuraciones","text":"<p>Es posible definir otras configuraciones e indicar en el comando de ejecuci\u00f3n de la aplicaci\u00f3n Spring Boot qu\u00e9 fichero de configuraci\u00f3n usar. Lo veremos en la pr\u00e1ctica 3.</p> <p>En esta pr\u00e1ctica se define otra configuraci\u00f3n en el directorio de test, que es la que se carga cuando se lanzan los tests:</p> src/test/resources/application.properties<pre><code>spring.datasource.url=jdbc:h2:mem:test\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect\nspring.jpa.hibernate.ddl-auto=create\nlogging.level.org.hibernate.SQL=debug\nspring.sql.init.mode=never\n\n# obligamos a que Hibernate inicialice los esquemas de datos\n# https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes#sql-script-datasource-initialization\nspring.jpa.defer-datasource-initialization=true\n\n# Deshabilitamos Open EntityManager in View\n# https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/html/data.html#data.sql.jpa-and-spring-data.open-entity-manager-in-view\n# Ver tambien https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/hibernate5/support/OpenSessionInViewInterceptor.html\n# y https://www.baeldung.com/spring-open-session-in-view\nspring.jpa.open-in-view=false\n</code></pre> <p>Una diferencia con el fichero de configuraci\u00f3n de desarrollo es el nombre de la fuente de datos, el modo del <code>spring.jpa.hibernate.ddl-auto</code>, que es <code>create</code> y el fichero de datos iniciales que se carga al ejecutar los tests.</p> <p>La otra diferencia es que no se activa el perfil <code>dev</code>, por lo que no se carga ning\u00fan dato en la aplicaci\u00f3n para los tests. Ya veremos m\u00e1s adelante que los datos para los tests se cargan en los propios tests.</p>"},{"location":"02-todolist/practica2.html#gestion-de-persistencia-con-jpa","title":"Gesti\u00f3n de persistencia con JPA","text":"<p>Para la gesti\u00f3n de la persistencia de los datos en la aplicaci\u00f3n Spring Boot usaremos Spring Data JPA. Se trata de un API de Spring Boot que se construye sobre JPA (Java Persistence API), el ORM (Object Relational Mapping) est\u00e1ndar de Java. La implementaci\u00f3n de JPA que utiliza Spring Boot es Hibernate.</p> <p>Spring Data JPA usa todos los conceptos de JPA y a\u00f1ade algunos adicionales que facilitan aun m\u00e1s su utilizaci\u00f3n, como es la definici\u00f3n de interfaces <code>Repository</code> con m\u00e9todos CRUD est\u00e1ndar para las entidades.</p>"},{"location":"02-todolist/practica2.html#definicion-del-modelo-de-datos","title":"Definici\u00f3n del modelo de datos","text":"<p>El framework JPA permite definir el esquema de la base de datos usando anotaciones en las clases denominadas de entidad. Para cada clase de entidad se define una tabla en la base de datos, con columnas que se mapean con sus atributos.</p> <p>Por ejemplo, la clase <code>Usuario</code> que se lista a continuaci\u00f3n define la tabla <code>usuarios</code> en la base de datos. Los distintos atributos (<code>login</code>, <code>email</code>, ...) se corresponden con las columnas de la tabla.</p> <p>El atributo <code>id</code> se corresponde con la clave primaria de la tabla. JPA define varias estrategias para obtener esa clave primera, y se ha escogido la estrategia <code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code> que define una columna que se autoincrementa en cada operaci\u00f3n de inserci\u00f3n de un nuevo registro en la tabla.</p> <p>Adem\u00e1s de los atributos, en la clase se define un constructor con los atributos obligatorios para definir un usuario (en nuestro caso el correo electronico), los getters y setters de todas las propiedades (necesario para JPA) y los m\u00e9todos <code>equals</code> y <code>hashCode</code> para comparar usuarios. </p> <p>Los m\u00e9todos <code>equals</code> y <code>hashCode</code> son necesarios para buscar instancias de la entidad en colecciones y JPA los usa para no incluir instancias repetidas en los resultados de las queries. El m\u00e9todo <code>equals</code> proporcionado no es el que genera IntelliJ por defecto, sino que hay que considerar si la instancia ha sido ya vinculada a la base de datos o no. En el caso en que la instancia ya est\u00e9 vinculada a la base de datos, tendr\u00e1 una clave primaria asignada y \u00e9sta ser\u00e1 la que se usar\u00e1 para comparar. En el caso en que la instancia no est\u00e9 vinculada (se acaba de crear o la estamos usando para alguna parte de la l\u00f3gica de negocio y no se va a persistir) se comparan los atributos obligatorios (en este caso el correo electr\u00f3nico).</p> src/main/java/madstodolist/model/Usuario.java<pre><code>package madstodolist.model;\n\n// Imports \n...\n\n@Entity\n@Table(name = \"usuarios\")\npublic class Usuario implements Serializable {\n\nprivate static final long serialVersionUID = 1L;\n\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long id;\n@NotNull\nprivate String email;\nprivate String nombre;\nprivate String password;\n@Column(name = \"fecha_nacimiento\")\n@Temporal(TemporalType.DATE)\nprivate Date fechaNacimiento;\n\n// La relaci\u00f3n es lazy por defecto,\n// es necesario acceder a la lista de tareas para que se carguen\n@OneToMany(mappedBy = \"usuario\")\nSet&lt;Tarea&gt; tareas = new HashSet&lt;&gt;();\n\n// Constructor vac\u00edo necesario para JPA/Hibernate.\n// No debe usarse desde la aplicaci\u00f3n.\npublic Usuario() {}\n\n// Constructor p\u00fablico con los atributos obligatorios. En este caso el correo electr\u00f3nico.\npublic Usuario(String email) {\nthis.email = email;\n}\n\n// Getters y setters atributos b\u00e1sicos\n...\n\n// Getters y setters de la relaci\u00f3n\n\npublic Set&lt;Tarea&gt; getTareas() {\nreturn tareas;\n}\n\n// M\u00e9todo helper para a\u00f1adir una tarea a la lista y establecer la relaci\u00f3n inversa\npublic void addTarea(Tarea tarea) {\n// Si la tarea ya est\u00e1 en la lista, no la a\u00f1adimos\nif (tareas.contains(tarea)) return;\n// A\u00f1adimos la tarea a la lista\ntareas.add(tarea);\n// Establecemos la relaci\u00f3n inversa del usuario en la tarea\nif (tarea.getUsuario() != this) {\ntarea.setUsuario(this);\n}\n}\n\n@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\nUsuario usuario = (Usuario) o;\nif (id != null &amp;&amp; usuario.id != null)\n// Si tenemos los ID, comparamos por ID\nreturn Objects.equals(id, usuario.id);\n// si no comparamos por campos obligatorios\nreturn email.equals(usuario.email);\n}\n\n@Override\npublic int hashCode() {\n// Generamos un hash basado en los campos obligatorios\nreturn Objects.hash(email);\n}\n}\n</code></pre> <p>En la definici\u00f3n de la entidad tambi\u00e9n se incluyen relaciones con otras entidades. En este caso un <code>Usuario</code> tiene muchas <code>Tarea</code>s (una relaci\u00f3n una-a-muchos).</p> <p>La relaci\u00f3n uno-a-muchos se representa en la base de datos con una clave ajena. El atributo <code>mappedBy</code> indica que la clave ajena se va a guardar en la columna correspondiente con el atributo <code>usuario</code> de la entidad <code>Tarea</code>.</p> <p>La definici\u00f3n de <code>Tarea</code> es la siguiente:</p> src/main/java/madstodolist/model/Tarea.java<pre><code>package madstodolist.model;\n\n// Imports\n...\n\n@Entity\n@Table(name = \"tareas\")\npublic class Tarea implements Serializable {\n\nprivate static final long serialVersionUID = 1L;\n\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long id;\n@NotNull\nprivate String titulo;\n\n@NotNull\n// Relaci\u00f3n muchos-a-uno entre tareas y usuario\n@ManyToOne\n// Nombre de la columna en la BD que guarda f\u00edsicamente\n// el ID del usuario con el que est\u00e1 asociado una tarea\n@JoinColumn(name = \"usuario_id\")\nprivate Usuario usuario;\n\n// Constructor vac\u00edo necesario para JPA/Hibernate.\n// No debe usarse desde la aplicaci\u00f3n.\npublic Tarea() {}\n\n// Al crear una tarea la asociamos autom\u00e1ticamente a un usuario\npublic Tarea(Usuario usuario, String titulo) {\nthis.titulo = titulo;\nsetUsuario(usuario); // Esto a\u00f1adir\u00e1 la tarea a la lista de tareas del usuario\n}\n\n// Getters y setters atributos b\u00e1sicos\n...\n\n// Getters y setters de la relaci\u00f3n\n\npublic Usuario getUsuario() {\nreturn usuario;\n}\n\n// M\u00e9todo para establecer la relaci\u00f3n con el usuario\n\npublic void setUsuario(Usuario usuario) {\n// Comprueba si el usuario ya est\u00e1 establecido\nif(this.usuario != usuario) {\nthis.usuario = usuario;\n// A\u00f1ade la tarea a la lista de tareas del usuario\nusuario.addTarea(this);\n}\n}\n\n@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\nTarea tarea = (Tarea) o;\nif (id != null &amp;&amp; tarea.id != null)\n// Si tenemos los ID, comparamos por ID\nreturn Objects.equals(id, tarea.id);\n// si no comparamos por campos obligatorios\nreturn titulo.equals(tarea.titulo) &amp;&amp;\nusuario.equals(tarea.usuario);\n}\n\n@Override\npublic int hashCode() {\nreturn Objects.hash(titulo, usuario);\n}\n}\n</code></pre>"},{"location":"02-todolist/practica2.html#recuperacion-de-colecciones-lazy","title":"Recuperaci\u00f3n de colecciones lazy","text":"<p>Como hemos visto anteriormente, en la aplicaci\u00f3n se define la relaci\u00f3n uno-a-muchos entre usuarios y tareas: un usuario tiene muchas tareas.</p> <p>Por defecto, todas las relaciones a-muchos en JPA se definen de tipo <code>LAZY</code>. </p> <p>La caracter\u00edstica de los atributos marcados como lazy en JPA es que no se traen a memoria cuando se recupera la entidad, sino cuando se consultan expl\u00edcitamente accediendo al atributo. Para que se traigan a memoria debe accederse a la colecci\u00f3n de la entidad estando abierta la conexi\u00f3n con la base de datos. Normalmente esto se hace en la capa de servicio marcando en los m\u00e9todos en los que se accede a las entidades con la anotaci\u00f3n <code>@Transactional</code>. </p> <p>Las entidades que usemos en estos m\u00e9todos estar\u00e1n conectadas a la base de datos y podremos recuperar sus relaciones lazy, accediendo a la colecci\u00f3n. Si queremos obtener todos los datos de la relaci\u00f3n podemos por ejemplo llamar al m\u00e9todo <code>size()</code> de la misma, o convertirla en un objeto DTO (<code>TareaData</code>) para devolverla al controller, tal y como se hace en el c\u00f3digo de la aplicaci\u00f3n:</p> <pre><code>@Transactional(readOnly = true)\npublic List&lt;TareaData&gt; allTareasUsuario(Long idUsuario) {\nlogger.debug(\"Devolviendo todas las tareas del usuario \" + idUsuario);\nUsuario usuario = usuarioRepository.findById(idUsuario).orElse(null);\nif (usuario == null) {\nthrow new TareaServiceException(\"Usuario \" + idUsuario + \" no existe al listar tareas \");\n}\n// Hacemos uso de Java Stream API para mapear la lista de entidades a DTOs.\nList&lt;TareaData&gt; tareas = usuario.getTareas().stream()\n.map(tarea -&gt; modelMapper.map(tarea, TareaData.class))\n.collect(Collectors.toList());\n// Ordenamos la lista por id de tarea\nCollections.sort(tareas, (a, b) -&gt; a.getId() &lt; b.getId() ? -1 : a.getId() == b.getId() ? 0 : 1);\nreturn tareas;\n}\n</code></pre> <p>Si devolvi\u00e9ramos al controller directamente una entidad que contiene una colecci\u00f3n lazy sin haberla inicializado, cuando se intentar acceder a ella se producir\u00eda un error por estar fuera del m\u00e9todo anotado con <code>@Transactional</code>.</p> <p>La otra forma de definir una relaci\u00f3n es usar el tipo eager, en el que JPA traer\u00e1 siempre a memoria todos los elementos cuando se recupere cualquier entidad. En general, no es conveniente definir una relaci\u00f3n como eager porque puede provocar problemas de rendimiento en el caso en que haya muchos elementos relacionados. Por ello, por defecto solo se definen como eager las relaciones uno-a-uno.</p> <p>En la pr\u00e1ctica 3 veremos m\u00e1s ejemplo de trabajo con relaciones lazy.</p>"},{"location":"02-todolist/practica2.html#clases-repository","title":"Clases Repository","text":"<p>Spring define la clase gen\u00e9rica <code>CrudRepository</code> que contienen m\u00e9todos por defecto para actualizar las entidades y realizar queries sobre ellas. Para dejar abierta la posibilidad de cambiar la implementaci\u00f3n, se definen con interfaces.</p> <pre><code>public interface CrudRepository&lt;T, ID extends Serializable&gt;  extends Repository&lt;T, ID&gt; {\n&lt;S extends T&gt; S save(S entity);\nOptional&lt;T&gt; findById(ID primaryKey); Iterable&lt;T&gt; findAll();\nlong count();\nvoid delete(T entity);\nboolean existsById(ID primaryKey);\n// \u2026 more functionality omitted.\n}\n</code></pre> <p>Para usar estos m\u00e9todos con nuestras entidades basta con definir interfaces que extienden esta clase gen\u00e9rica. Lo hemos hecho en el package <code>repository</code>.</p> <p>Por ejemplo, la interfaz <code>UsuarioRepository</code>:</p> src/main/java/madstodolist/repository/UsuarioRepository.java<pre><code>package madstodolist.repository;\n\nimport madstodolist.model.Usuario;\nimport org.springframework.data.repository.CrudRepository;\n\nimport java.util.Optional;\n\npublic interface UsuarioRepository extends CrudRepository&lt;Usuario, Long&gt; {\nOptional&lt;Usuario&gt; findByEmail(String s);\n}\n</code></pre> <p>En la interfaz se a\u00f1ade un m\u00e9todo <code>findByEmail</code> que hace que Spring construya autom\u00e1ticamente una consulta sobre  la base de datos. Al usar como nombre del m\u00e9todo el nombre de la propiedad de la entidad (<code>email</code>), Spring puede generar autom\u00e1ticamente la consulta.</p> <p>Puedes consultar una lista completa de las traducciones de nombres de m\u00e9todos a consultas a la base de datos en este enlace de la documentaci\u00f3n de Spring Boot.</p> <p>Tambi\u00e9n es posible definir expl\u00edcitamente en el Repository la consulta a realizar a la base de datos utilizando la anotaci\u00f3n <code>@Query</code>. Puedes encontrar varios ejemplos en este enlace.</p> <p>Una vez definida la interfaz, ya podemos inyectar una instancia de repository y usarla en las clases de servicio. Por ejemplo, mostramos el m\u00e9todo de servicio que registra un usuario:</p> <pre><code>@Service\npublic class UsuarioService {\n\n@Autowired\nprivate UsuarioRepository usuarioRepository;\n@Autowired\nprivate ModelMapper modelMapper;\n\n...\n\n// Se a\u00f1ade un usuario en la aplicaci\u00f3n.\n// El email y password del usuario deben ser distinto de null\n// El email no debe estar registrado en la base de datos\n@Transactional\npublic UsuarioData registrar(UsuarioData usuario) {\nOptional&lt;Usuario&gt; usuarioBD = usuarioRepository.findByEmail(usuario.getEmail());\nif (usuarioBD.isPresent())\nthrow new UsuarioServiceException(\"El usuario \" + usuario.getEmail() + \" ya est\u00e1 registrado\");\nelse if (usuario.getEmail() == null)\nthrow new UsuarioServiceException(\"El usuario no tiene email\");\nelse if (usuario.getPassword() == null)\nthrow new UsuarioServiceException(\"El usuario no tiene password\");\nelse {\nUsuario usuarioNuevo = modelMapper.map(usuario, Usuario.class);\nusuarioNuevo = usuarioRepository.save(usuarioNuevo);\nreturn modelMapper.map(usuarioNuevo, UsuarioData.class);\n}\n}\n\n...\n}\n</code></pre> <p>En el cuerpo del m\u00e9todo se llama al m\u00e9todo <code>findByEmail</code> del repositorio que realiza una b\u00fasqueda en la base de datos y al m\u00e9todo <code>save</code> que actualiza el valor de la entidad.</p> <p>La anotaci\u00f3n <code>@Transactional</code> hace dos cosas. En primer lugar, abre una conexi\u00f3n con la base de datos y hace que todas las llamadas a las clases repository se realicen usando esa conexi\u00f3n. Las entidades est\u00e1n conectadas a la base de datos durante todas las sentencias que se ejecutan dentro del m\u00e9todo anotado y cualquier cambio en ellas se propaga a la base de datos (en este caso el t\u00edtulo de la tarea). Adem\u00e1s, y muy importante, las relaciones lazy pueden recuperarse sin problemas accediendo a los atributos correspondientes de las entidades. </p> <p>En segundo lugar, la anotaci\u00f3n <code>@Transactional</code>, como su nombre indica, hace que las acciones sobre la base de datos se ejecuten de forma transaccional. Se abre la transacci\u00f3n al del m\u00e9todo y se cierra al final. Si sucede alguna excepci\u00f3n durante su ejecuci\u00f3n la transacci\u00f3n se deshace.</p> <p>La interfaz <code>TareaRepository</code> es similar.</p>"},{"location":"02-todolist/practica2.html#dtos-data-transfer-objects","title":"DTOs (Data Transfer Objects)","text":"<p>Los Data Transfer Objects (DTOs) son una pr\u00e1ctica efectiva para separar la representaci\u00f3n de datos que usa la capa de negocio de la que se expone a trav\u00e9s de la API. En el mundo de Spring, los DTOs resultan especialmente \u00fatiles para manipular y transferir datos entre distintas capas de la aplicaci\u00f3n, como de los repositorios a los servicios o de los servicios a los controladores. </p> <p>Los DTOs permiten separar la representaci\u00f3n de datos utilizada en la capa de negocio de la que se expone a trav\u00e9s de la API. Esto es particularmente \u00fatil cuando tienes una entidad con m\u00faltiples campos pero, en ciertas circunstancias, s\u00f3lo necesitas un subconjunto de ellos. Usar un DTO en estos casos permite transferir solo los datos necesarios, lo que hace la operaci\u00f3n m\u00e1s eficiente y segura. </p> <p>Adem\u00e1s, los DTOs proporcionan un desacoplamiento con la base de datos. A diferencia de las entidades que se obtienen directamente de los repositorios, los DTOs est\u00e1n desacoplados de la base de datos. Mientras que cualquier cambio en un objeto de entidad podr\u00eda propagarse a la base de datos si est\u00e1s dentro de un contexto transaccional, los cambios en un DTO no tienen ning\u00fan efecto en la base de datos. Por ello es recomendado que sean este tipo de objetos los devueltos por los servicios, para que los controllers no puedan realizar modificaciones en la base de datos.</p> <p>En nuestra aplicaci\u00f3n todas las clases DTO est\u00e1n en el paquete <code>dto</code>:</p> <ul> <li><code>LoginData</code></li> <li><code>RegistroData</code></li> <li><code>TareaData</code></li> <li><code>UsuarioData</code></li> </ul> <p>Las clases <code>LoginData</code> y <code>RegistroData</code> transportan los datos entre las plantillas de la vista y el controller. Y las clases <code>TareaData</code> y <code>UsuarioData</code> se usan para devolver datos del servicio al controller.</p>"},{"location":"02-todolist/practica2.html#modelmapper","title":"ModelMapper","text":"<p><code>ModelMapper</code> es una biblioteca de mapeo de objetos en Java que agiliza y estandariza la conversi\u00f3n entre entidades de base de datos y Data Transfer Objects (DTOs). Al usarla, puedes evitar el tedio y los posibles errores de escribir c\u00f3digo de mapeo manual. Adem\u00e1s, te brinda una gran flexibilidad mediante diversas estrategias de coincidencia y configuraciones personalizables. </p> <p>Por ejemplo, si tienes una clase <code>Estudiante</code> con campos como <code>nombre</code>, <code>edad</code> y <code>numeroMatricula</code>, y un DTO llamado <code>EstudianteDTO</code> que solo necesita nombre y edad, podr\u00edas encontrarte escribiendo un c\u00f3digo manual para asignar cada campo de la entidad al DTO correspondiente: </p> <pre><code>Estudiante estudiante = new Estudiante(\"Ana\", 20, \"123ABC\");\nEstudianteDTO estudianteDTO = new EstudianteDTO();\nestudianteDTO.setNombre(estudiante.getNombre());\nestudianteDTO.setEdad(estudiante.getEdad());\n</code></pre> <p>Con ModelMapper, esta tarea se condensa en unas pocas l\u00edneas:</p> <pre><code>ModelMapper modelMapper = new ModelMapper();\nEstudiante estudiante = new Estudiante(\"Ana\", 20, \"123ABC\");\nEstudianteDTO estudianteDTO = modelMapper.map(estudiante, EstudianteDTO.class);\n</code></pre> <p>El uso de <code>ModelMapper</code> no solo hace que tu c\u00f3digo sea m\u00e1s sencillo de escribir y mantener, sino que tambi\u00e9n proporciona un enfoque coherente para el mapeo de objetos en tu aplicaci\u00f3n, lo cual es de mucha importancia en proyectos de gran envergadura.</p> <p>Para poder trabajar con <code>ModelMapper</code> en la aplicaci\u00f3n lo declaramos como una dependencia en el fichero POM y creamos un <code>Bean</code> de Spring para poder usarlo con inyecci\u00f3n de dependencias:</p> src/main/java/madstodolist/config/ModelMapperConfig.java<pre><code>package madstodolist.config;\n\n// Imports\n...\n\n@Configuration\npublic class ModelMapperConfig {\n\n@Bean\npublic ModelMapper modelMapper() {\nreturn new ModelMapper();\n}\n}\n</code></pre>"},{"location":"02-todolist/practica2.html#ejemplos-de-dtos-en-nuestra-aplicacion","title":"Ejemplos de DTOs en nuestra aplicaci\u00f3n","text":"<p>Veamos dos ejemplos de construcci\u00f3n de DTOs como objetos devueltos por m\u00e9todos de servicios de nuestra aplicaci\u00f3n.</p> <p>Primer ejemplo:</p> <pre><code>@Transactional(readOnly = true)\npublic TareaData findById(Long tareaId) {\nlogger.debug(\"Buscando tarea \" + tareaId);\nTarea tarea = tareaRepository.findById(tareaId).orElse(null);\nif (tarea == null) return null;\nelse return modelMapper.map(tarea, TareaData.class);\n}\n</code></pre> <p>En este primer ejemplo, el m\u00e9todo <code>findById</code> se encarga de buscar una tarea espec\u00edfica en la base de datos utilizando su <code>tareaId</code>. Si la tarea no se encuentra, devuelve <code>null</code>. En caso contrario, utiliza <code>ModelMapper</code> para convertir la entidad <code>Tarea</code> a su representaci\u00f3n DTO <code>TareaData</code>. </p> <p>Segundo ejemplo:</p> <pre><code>@Transactional(readOnly = true)\npublic List&lt;TareaData&gt; allTareasUsuario(Long idUsuario) {\nlogger.debug(\"Devolviendo todas las tareas del usuario \" + idUsuario);\nUsuario usuario = usuarioRepository.findById(idUsuario).orElse(null);\nif (usuario == null) {\nthrow new TareaServiceException(\"Usuario \" + idUsuario + \" no existe al listar tareas \");\n}\n// Hacemos uso de Java Stream API para mapear la lista de entidades a DTOs.\nList&lt;TareaData&gt; tareas = usuario.getTareas().stream()\n.map(tarea -&gt; modelMapper.map(tarea, TareaData.class))\n.collect(Collectors.toList());\n// Ordenamos la lista por id de tarea\nCollections.sort(tareas, (a, b) -&gt; a.getId() &lt; b.getId() ? -1 : a.getId() == b.getId() ? 0 : 1);\nreturn tareas;\n}\n</code></pre> <p>El segundo ejemplo muestra c\u00f3mo listar todas las tareas de un usuario espec\u00edfico. Se obtiene el usuario con el m\u00e9todo <code>findById</code> y, si no se encuentra, se lanza una excepci\u00f3n. Si el usuario existe, se hace uso de la Java Stream API para transformar la lista de tareas del usuario (entidades) en una lista de DTOs <code>TareaData</code>. Finalmente, la lista se ordena por el id de la tarea. </p>"},{"location":"02-todolist/practica2.html#servicios","title":"Servicios","text":"<p>Aunque ya hemos visto ejemplos de servicios en la secci\u00f3n anterior, vamos a detallar algo m\u00e1s la utilidad de esta capa. </p> <p>La capa de servicios es la capa intermedia entre la capa de controllers y la de repository. Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. En determinados contextos, tambi\u00e9n utilizamos objetos de transferencia de datos, o DTOs, para devolver informaci\u00f3n a los controllers de manera m\u00e1s eficiente. </p> <p>La responsabilidad principal de la capa de servicios es crear, obtener o modificar los objetos entidad necesarios para cada funcionalidad a partir de los datos que env\u00eda la capa controller. Estos objetos entidad se trabajan en memoria y, cuando es necesario, se hacen persistentes los cambios utilizando la capa repository. Cuando la funcionalidad lo requiere, los datos se transforman a DTOs para su retorno al controller, a\u00f1adiendo un nivel de desacoplamiento y eficiencia. </p> <p>La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository y de ModelMapper para la conversi\u00f3n entre entidades y DTOs, cuando sea necesario, mediante la inyecci\u00f3n de dependencias. </p> <p>Como hemos comentado anteriormente, los m\u00e9todos de la capa de servicios estar\u00e1n anotados con <code>@Transactional</code> actualizar correctamente la base de datos y las conexiones lazy y para garantizar la transaccionalidad.</p> <p>Por ejemplo, la clase <code>UsuarioService</code> se define como se muestra a continuaci\u00f3n.</p> src/main/java/madstodolist/service/UsuarioService.java<pre><code>package madstodolist.service;\n\n// Imports\n...\n\n@Service\npublic class UsuarioService {\n\nLogger logger = LoggerFactory.getLogger(UsuarioService.class);\n\npublic enum LoginStatus {LOGIN_OK, USER_NOT_FOUND, ERROR_PASSWORD}\n\n@Autowired\nprivate UsuarioRepository usuarioRepository;\n@Autowired\nprivate ModelMapper modelMapper;\n\n@Transactional(readOnly = true)\npublic LoginStatus login(String eMail, String password) {\nOptional&lt;Usuario&gt; usuario = usuarioRepository.findByEmail(eMail);\nif (!usuario.isPresent()) {\nreturn LoginStatus.USER_NOT_FOUND;\n} else if (!usuario.get().getPassword().equals(password)) {\nreturn LoginStatus.ERROR_PASSWORD;\n} else {\nreturn LoginStatus.LOGIN_OK;\n}\n}\n\n// Se a\u00f1ade un usuario en la aplicaci\u00f3n.\n// El email y password del usuario deben ser distinto de null\n// El email no debe estar registrado en la base de datos\n@Transactional\npublic UsuarioData registrar(UsuarioData usuario) {\nOptional&lt;Usuario&gt; usuarioBD = usuarioRepository.findByEmail(usuario.getEmail());\nif (usuarioBD.isPresent())\nthrow new UsuarioServiceException(\"El usuario \" + usuario.getEmail() + \" ya est\u00e1 registrado\");\nelse if (usuario.getEmail() == null)\nthrow new UsuarioServiceException(\"El usuario no tiene email\");\nelse if (usuario.getPassword() == null)\nthrow new UsuarioServiceException(\"El usuario no tiene password\");\nelse {\nUsuario usuarioNuevo = modelMapper.map(usuario, Usuario.class);\nusuarioNuevo = usuarioRepository.save(usuarioNuevo);\nreturn modelMapper.map(usuarioNuevo, UsuarioData.class);\n}\n}\n\n@Transactional(readOnly = true)\npublic UsuarioData findByEmail(String email) {\nUsuario usuario = usuarioRepository.findByEmail(email).orElse(null);\nif (usuario == null) return null;\nelse {\nreturn modelMapper.map(usuario, UsuarioData.class);\n}\n}\n\n@Transactional(readOnly = true)\npublic UsuarioData findById(Long usuarioId) {\nUsuario usuario = usuarioRepository.findById(usuarioId).orElse(null);\nif (usuario == null) return null;\nelse {\nreturn modelMapper.map(usuario, UsuarioData.class);\n}\n}\n}\n</code></pre> src/main/java/madstodolist/service/UsuarioServiceException.java<pre><code>package madstodolist.service;\n\npublic class UsuarioServiceException extends RuntimeException {\n\npublic UsuarioServiceException(String message) {\nsuper(message);\n}\n}\n</code></pre> <p>Estudia con detalle esta clase y la otra clase de servicio, <code>TareaService</code>.</p>"},{"location":"02-todolist/practica2.html#ventajas-de-utilizar-una-capa-de-servicios","title":"Ventajas de utilizar una capa de servicios","text":"<p>Al utilizar clases de servicios, podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n utilizando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esta manera, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML, solo tendremos que tocar las clases controller, no las de servicio. </p> <p>Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas. </p>"},{"location":"02-todolist/practica2.html#controllers","title":"Controllers","text":"<p>Los controllers son el punto de entrada a la l\u00f3gica de negocio de la aplicaci\u00f3n. Act\u00faan como intermediarios entre las peticiones HTTP del usuario y la capa de servicios. Su rol es recibir datos de la petici\u00f3n, invocar el servicio apropiado para procesar la l\u00f3gica de negocio y, finalmente, devolver la vista o los datos adecuados. </p> <p>En esta aplicaci\u00f3n, tenemos dos controladores principales:</p> <ul> <li><code>LoginController</code>: gestiona el registro y el inicio de sesi\u00f3n de los   usuarios.</li> <li><code>TareasController</code>: se encarga de las operaciones CRUD relacionadas con las   tareas del usuario. </li> </ul> <p>Para facilitar la manipulaci\u00f3n de los datos del formulario, los controllers emplean clases auxiliares como <code>LoginData</code> y <code>RegistroData</code>. Estas clases ayudan a recopilar los datos del usuario en un formato m\u00e1s manejable. </p> <p>Ejemplo de <code>LoginController</code></p> <p>El siguiente fragmento de c\u00f3digo muestra un ejemplo de c\u00f3mo se implementa un controlador en nuestra aplicaci\u00f3n: </p> src/main/java/madstodolist/controller/LoginController.java<pre><code>// Importaciones y anotaciones\n...\n\n@Controller\npublic class LoginController {\n\n@Autowired\nUsuarioService usuarioService;\n\n@Autowired\nManagerUserSession managerUserSession;\n\n@GetMapping(\"/login\")\npublic String loginForm(Model model) {\nmodel.addAttribute(\"loginData\", new LoginData());\nreturn \"formLogin\";\n}\n\n// ... m\u00e1s c\u00f3digo para gestionar el inicio de sesi\u00f3n y el registro\n}\n</code></pre> <p>Y el siguiente c\u00f3digo muestra la implementaci\u00f3n de la clase <code>LoginData</code> que se usar\u00e1 para recoger los datos del formulario rellenado por el usuario.</p> src/main/java/madstodolist/dto/LoginData.java<pre><code>package madstodolist.dto;\n\npublic class LoginData {\nprivate String eMail;\nprivate String password;\n\npublic String geteMail() {\nreturn eMail;\n}\n\npublic void seteMail(String eMail) {\nthis.eMail = eMail;\n}\n\npublic String getPassword() {\nreturn password;\n}\n\npublic void setPassword(String password) {\nthis.password = password;\n}\n}\n</code></pre> <p>En este caso, el m\u00e9todo <code>loginForm</code> se encarga de manejar las peticiones GET a la URL <code>/login</code>. Crea una nueva instancia de la clase <code>LoginData</code> y la a\u00f1ade al modelo, que posteriormente se pasar\u00e1 a la vista para ser completado por el usuario. </p> <p>Los controllers suelen interactuar con varios servicios y componentes, como se muestra en los ejemplos de <code>UsuarioService</code> y <code>ManagerUserSession</code>, que se inyectan en LoginController.</p> <p>Las clases auxiliares como <code>LoginData</code> o <code>RegistroData</code> facilitan la validaci\u00f3n y el manejo de datos en el controller. Estos objetos se llenan autom\u00e1ticamente con los datos del formulario, y permiten que los m\u00e9todos del controller sean m\u00e1s limpios y m\u00e1s f\u00e1ciles de leer. </p>"},{"location":"02-todolist/practica2.html#peticiones-y-rutas","title":"Peticiones y rutas","text":"<p>Las rutas (endpoints) que se definen en los controllers para realizar las acciones de la aplicaci\u00f3n son:</p> <p><code>LoginController</code></p> <ul> <li><code>GET /login</code>: devuelve el formulario de login</li> <li><code>POST /login</code>: realiza el login</li> <li><code>GET /registro</code>: devuelve el formulario de registro</li> <li><code>POST /registro</code>: realiza el registro</li> <li><code>GET /logout</code>: realiza la salida del usuario de la aplicaci\u00f3n</li> </ul> <p><code>TareaController</code></p> <ul> <li><code>GET /usuarios/{id}/tareas/nueva</code>: devuelve el formulario para a\u00f1adir una tarea al usuario con identificador <code>{id}</code></li> <li><code>POST /usuarios/{id}/tareas/nueva</code>: a\u00f1ade una tarea nueva a un usuario</li> <li><code>GET /usuarios/{id}/tareas</code>: devuelve el listado de tareas de un usuario</li> <li><code>GET /tareas/{id}/editar\"</code>: devuelve el formulario para editar una tarea</li> <li><code>POST /tareas/{id}/editar</code>: a\u00f1ade una tarea modificada </li> <li><code>DELETE /tareas/{id}</code>: realiza el borrado de una tarea</li> </ul>"},{"location":"02-todolist/practica2.html#vistas","title":"Vistas","text":"<p>Todas las vistas de la aplicaci\u00f3n comparten la misma cabecera y pie de p\u00e1gina. Para centralizar estos elementos se usa la caracter\u00edstica de fragmentos de Thymeleaf. Los fragmentos comunes se definen en el fichero <code>fragments.html</code>.</p> src/main/resources/templates/fragments.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n\n&lt;head th:fragment=\"head (titulo)\"&gt;\n    &lt;meta charset=\"UTF-8\"/&gt;\n    &lt;title th:text=\"${titulo}\"&gt;&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" th:href=\"@{/css/bootstrap.min.css}\"&gt;\n&lt;/head&gt;\n\n&lt;div th:fragment=\"javascript\"&gt;\n    &lt;script th:src=\"@{/js/jquery.min.js}\"&gt;&lt;/script&gt;\n    &lt;script th:src=\"@{/js/popper.min.js}\"&gt;&lt;/script&gt;\n    &lt;script th:src=\"@{/js/bootstrap.min.js}\"&gt;&lt;/script&gt;\n&lt;/div&gt;\n/html&gt;\n</code></pre> <p>Vemos que las vistas usan el framework CSS Bootstrap (en concreto, la versi\u00f3n Bootstrap 4.6) y varias librer\u00edas JavaScript. Ambos se encuentran en el directorio <code>src/main/resources/static/</code>, el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Spring Boot.</p> <p>La vista principal de la aplicaci\u00f3n es el listado de tareas que vemos a continuaci\u00f3n.</p> src/main/resources/templates/listaTareas.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n\n&lt;head th:replace=\"fragments :: head (titulo='Login')\"&gt;&lt;/head&gt;\n\n&lt;body&gt;\n&lt;div class=\"container-fluid\"&gt;\n\n    &lt;div class=\"row mt-3\"&gt;\n        &lt;div class=\"col\"&gt;\n            &lt;h2 th:text=\"'Listado de tareas de ' + ${usuario.nombre}\"&gt;&lt;/h2&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"row mt-3\"&gt;\n        &lt;div class=\"col\"&gt;\n            &lt;table class=\"table table-striped\"&gt;\n                &lt;thead&gt;\n                &lt;tr&gt;\n                    &lt;th&gt;Id&lt;/th&gt;\n                    &lt;th&gt;Tarea&lt;/th&gt;\n                    &lt;th&gt;Acci\u00f3n&lt;/th&gt;\n                &lt;/tr&gt;\n                &lt;/thead&gt;\n                &lt;tbody&gt;\n                &lt;tr th:each=\"tarea: ${tareas}\"&gt;\n                    &lt;td th:text=\"${tarea.id}\"&gt;&lt;/td&gt;\n                    &lt;td th:text=\"${tarea.titulo}\"&gt;&lt;/td&gt;\n                    &lt;td&gt;&lt;a class=\"btn btn-primary btn-xs\" th:href=\"@{/tareas/{id}/editar(id=${tarea.id})}\"/&gt;editar&lt;/a&gt;\n                        &lt;a class=\"btn btn-danger btn-xs\" href=\"#\" onmouseover=\"\" style=\"cursor: pointer;\"\n                           th:onclick=\"'del(\\'/tareas/' + ${tarea.id} + '\\')'\"&gt;borrar&lt;/a&gt;\n                    &lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;/tbody&gt;\n            &lt;/table&gt;\n            &lt;p&gt;&lt;a class=\"btn btn-primary\" th:href=\"@{/usuarios/{id}/tareas/nueva(id=${usuario.id})}\"&gt; Nueva tarea&lt;/a&gt;\n            &lt;a class=\"btn btn-link\" href=\"/logout\"&gt;Salir&lt;/a&gt;&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"row mt-2\"&gt;\n        &lt;div class=\"col\"&gt;\n            &lt;div class=\"alert alert-success alert-dismissible fade show\" role=\"alert\" th:if=\"${!#strings.isEmpty(mensaje)}\"&gt;\n                &lt;span th:text=\"${mensaje}\"&gt;&lt;/span&gt;\n                &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-label=\"Close\"&gt;\n                    &lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt;\n                &lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n\n\n&lt;/div&gt;\n\n&lt;div th:replace=\"fragments::javascript\"/&gt;\n\n\n&lt;!-- Ejemplo de uso de Ajax para lanzar una petici\u00f3n DELETE y borrar una tarea --&gt;\n\n&lt;script type=\"text/javascript\"&gt;\nfunction del(urlBorrar) {\nif (confirm('\u00bfEst\u00e1s seguro/a de que quieres borrar la tarea?')) {\n$.ajax({\nurl: urlBorrar,\ntype: 'DELETE',\nsuccess: function (results) {\n//refresh the page\nlocation.reload();\n}\n});\n}\n}\n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller <code>TareasController</code> c\u00f3mo se obtienen esos datos). </li> <li>Define un script JavaScript en el que se realiza una petici\u00f3n   <code>DELETE</code> a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para   lanzar la acci\u00f3n de borrar una tarea).</li> <li>Utiliza una instrucci\u00f3n de iteraci\u00f3n sobre la lista de tares para   construir los elementos de la tabla de tareas.</li> <li>En las acciones de a\u00f1adir y editar tareas se construyen las URLs a   las que hacer la petici\u00f3n usando el identificador de la tarea.</li> </ul>"},{"location":"02-todolist/practica2.html#autenticacion-y-control-de-acceso","title":"Autenticaci\u00f3n y control de acceso","text":"<p>En la aplicaci\u00f3n se realiza una autenticaci\u00f3n y un control de acceso muy sencillo usando la sesi\u00f3n HTTP (clase <code>HttpSession</code>). Esta sesi\u00f3n se implementa en Spring Boot con una cookie que se pasa desde el navegador hasta el servidor en cada petici\u00f3n.</p> <p>El manejo de la clase <code>HttpSession</code> es muy sencillo: es un diccionario en el que podemos a\u00f1adir datos. En el servidor podemos obtener los datos de la sesi\u00f3n consultando el diccionario.</p> <p>La implementaci\u00f3n de la autenticaci\u00f3n y del control de acceso se realiza con en la clase <code>ManagerUserSesion</code>:</p> src/main/java/madstodolist/authentication/ManagerUserSesion.java<pre><code>package madstodolist.authentication;\n\n// Imports\n...\n\n@Component\npublic class ManagerUserSession {\n\n@Autowired\nHttpSession session;\n\n// A\u00f1adimos el id de usuario en la sesi\u00f3n HTTP para hacer\n// una autorizaci\u00f3n sencilla. En los m\u00e9todos de controllers\n// comprobamos si el id del usuario logeado coincide con el obtenido\n// desde la URL\npublic void logearUsuario(Long idUsuario) {\nsession.setAttribute(\"idUsuarioLogeado\", idUsuario);\n}\n\npublic Long usuarioLogeado() {\nreturn (Long) session.getAttribute(\"idUsuarioLogeado\");\n}\n\npublic void logout() {\nsession.setAttribute(\"idUsuarioLogeado\", null);\n}\n}\n</code></pre> <p>Se implementa como un componente Spring con la anotaci\u00f3n <code>@Component</code>. La referencia a la clase <code>HttpSession</code> se obtiene por inyecci\u00f3n de dependencias con la anotaci\u00f3n de spring Boot <code>@Autowired</code>.</p> <p>La anotaci\u00f3n <code>@Component</code> permite inyectar un <code>ManagerUserSession</code> en los controllers para gestionar all\u00ed el usuario que est\u00e1 logeado y mockearlo en los tests.</p>"},{"location":"02-todolist/practica2.html#pruebas-manuales-y-automaticas","title":"Pruebas manuales y autom\u00e1ticas","text":"<p>Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que vamos introduciendo funcionan correctamente.</p> <p>Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre una base de datos con valores iniciales. Como hemos visto en la configuraci\u00f3n de la aplicaci\u00f3n, estos valores iniciales se cargan al arrancar la aplicaci\u00f3n cuando el perfil activo es <code>dev</code> (se configura en la variable <code>spring.profiles.active</code> del fichero <code>application.properties</code>.</p> <p>Sin embargo, en los tests autom\u00e1ticos no se activa este perfil, por lo que no se carga ning\u00fan dato autom\u00e1ticamente. En cada test hay que cargar manualmente los datos de prueba al comienzo de cada test. Por ejemplo, el siguiente c\u00f3digo:</p> <pre><code>    // M\u00e9todo para inicializar los datos de prueba en la BD\n// Devuelve un mapa con los identificadores del usuario y de la primera tarea a\u00f1adida\nMap&lt;String, Long&gt; addUsuarioTareasBD() {\nUsuarioData usuario = new UsuarioData();\nusuario.setEmail(\"user@ua\");\nusuario.setPassword(\"123\");\n\n// A\u00f1adimos un usuario a la base de datos\nUsuarioData usuarioNuevo = usuarioService.registrar(usuario);\n\n// Y a\u00f1adimos dos tareas asociadas a ese usuario\nTareaData tarea1 = tareaService.nuevaTareaUsuario(usuarioNuevo.getId(), \"Lavar coche\");\ntareaService.nuevaTareaUsuario(usuarioNuevo.getId(), \"Renovar DNI\");\n\n// Devolvemos los ids del usuario y de la primera tarea a\u00f1adida\nMap&lt;String, Long&gt; ids = new HashMap&lt;&gt;();\nids.put(\"usuarioId\", usuarioNuevo.getId());\nids.put(\"tareaId\", tarea1.getId());\nreturn ids;\n}\n</code></pre> <p>Es importante que al terminar la ejecuci\u00f3n de cada test se limpie la base de datos y se borren todos los datos existentes, para que la ejecuci\u00f3n de un test no interfiera con la de otro. Una forma de hacer esto en SpringBoot es usando la anotaci\u00f3n <code>@Sql</code>, con la que se define un script de SQL a realizar despu\u00e9s de cada test:</p> <pre><code>@Sql(scripts = \"/clean-db.sql\", executionPhase = AFTER_TEST_METHOD)\npublic class TareaTest {\n...\n</code></pre> src/test/resources/clean-db.sql<pre><code>DELETE FROM tareas;\nDELETE FROM usuarios;\n</code></pre>"},{"location":"02-todolist/practica2.html#tests-de-las-entidades-y-de-la-capa-repository","title":"Tests de las entidades y de la capa repository","text":"<p>Se realizan tests autom\u00e1ticos sobre las entidades y repository:</p> <ul> <li><code>TareaTest.java</code></li> <li><code>UsuarioTest.java</code>:</li> </ul> <p>Veamos, por ejemplo, el fichero <code>TareaTest.java</code>:</p> src/test/java/madstodolist/repository/TareaTest.java<pre><code>package madstodolist.repository;\n\n// Imports\n...\n\n@SpringBootTest\n@Sql(scripts = \"/clean-db.sql\")\npublic class TareaTest {\n\n@Autowired\nUsuarioRepository usuarioRepository;\n\n@Autowired\nTareaRepository tareaRepository;\n\n//\n// Tests modelo Tarea en memoria, sin la conexi\u00f3n con la BD\n//\n\n@Test\npublic void crearTarea() {\n// GIVEN\n// Un usuario nuevo creado en memoria, sin conexi\u00f3n con la BD,\n\nUsuario usuario = new Usuario(\"juan.gutierrez@gmail.com\");\n\n// WHEN\n// se crea una nueva tarea con ese usuario,\n\nTarea tarea = new Tarea(usuario, \"Pr\u00e1ctica 1 de MADS\");\n\n// THEN\n// el t\u00edtulo y el usuario de la tarea son los correctos.\n\nassertThat(tarea.getTitulo()).isEqualTo(\"Pr\u00e1ctica 1 de MADS\");\nassertThat(tarea.getUsuario()).isEqualTo(usuario);\n}\n\n@Test\npublic void laListaDeTareasDeUnUsuarioSeActualizaEnMemoriaConUnaNuevaTarea() {\n// GIVEN\n// Un usuario nuevo creado en memoria, sin conexi\u00f3n con la BD,\n\nUsuario usuario = new Usuario(\"juan.gutierrez@gmail.com\");\n\n// WHEN\n// se crea una tarea de ese usuario,\n\nSet&lt;Tarea&gt; tareas = usuario.getTareas();\nTarea tarea = new Tarea(usuario, \"Pr\u00e1ctica 1 de MADS\");\n\n// THEN\n// la tarea creada se ha a\u00f1adido a la lista de tareas del usuario.\n\nassertThat(usuario.getTareas()).contains(tarea);\nassertThat(tareas).contains(tarea);\n}\n\n@Test\npublic void comprobarIgualdadTareasSinId() {\n// GIVEN\n// Creadas tres tareas sin identificador, y dos de ellas con\n// la misma descripci\u00f3n\n\nUsuario usuario = new Usuario(\"juan.gutierrez@gmail.com\");\nTarea tarea1 = new Tarea(usuario, \"Pr\u00e1ctica 1 de MADS\");\nTarea tarea2 = new Tarea(usuario, \"Pr\u00e1ctica 1 de MADS\");\nTarea tarea3 = new Tarea(usuario, \"Pagar el alquiler\");\n\n// THEN\n// son iguales (Equal) las tareas que tienen la misma descripci\u00f3n.\n\nassertThat(tarea1).isEqualTo(tarea2);\nassertThat(tarea1).isNotEqualTo(tarea3);\n}\n\n@Test\npublic void comprobarIgualdadTareasConId() {\n// GIVEN\n// Creadas tres tareas con distintas descripciones y dos de ellas\n// con el mismo identificador,\n\nUsuario usuario = new Usuario(\"juan.gutierrez@gmail.com\");\nTarea tarea1 = new Tarea(usuario, \"Pr\u00e1ctica 1 de MADS\");\nTarea tarea2 = new Tarea(usuario, \"Lavar la ropa\");\nTarea tarea3 = new Tarea(usuario, \"Pagar el alquiler\");\ntarea1.setId(1L);\ntarea2.setId(2L);\ntarea3.setId(1L);\n\n// THEN\n// son iguales (Equal) las tareas que tienen el mismo identificador.\n\nassertThat(tarea1).isEqualTo(tarea3);\nassertThat(tarea1).isNotEqualTo(tarea2);\n}\n\n//\n// Tests TareaRepository.\n// El c\u00f3digo que trabaja con repositorios debe\n// estar en un entorno transactional, para que todas las peticiones\n// est\u00e9n en la misma conexi\u00f3n a la base de datos, las entidades est\u00e9n\n// conectadas y sea posible acceder a colecciones LAZY.\n//\n\n@Test\n@Transactional\npublic void guardarTareaEnBaseDatos() {\n// GIVEN\n// Un usuario en la base de datos.\n\nUsuario usuario = new Usuario(\"user@ua\");\nusuarioRepository.save(usuario);\n\nTarea tarea = new Tarea(usuario, \"Pr\u00e1ctica 1 de MADS\");\n\n// WHEN\n// salvamos la tarea en la BD,\n\ntareaRepository.save(tarea);\n\n// THEN\n// se actualiza el id de la tarea,\n\nassertThat(tarea.getId()).isNotNull();\n\n// y con ese identificador se recupera de la base de datos la tarea\n// con los valores correctos de las propiedades y la relaci\u00f3n con\n// el usuario actualizado tambi\u00e9n correctamente (la relaci\u00f3n entre tarea\n// y usuario es EAGER).\n\nTarea tareaBD = tareaRepository.findById(tarea.getId()).orElse(null);\nassertThat(tareaBD.getTitulo()).isEqualTo(tarea.getTitulo());\nassertThat(tareaBD.getUsuario()).isEqualTo(usuario);\n}\n\n@Test\n@Transactional\npublic void salvarTareaEnBaseDatosConUsuarioNoBDLanzaExcepcion() {\n// GIVEN\n// Un usuario nuevo que no est\u00e1 en la BD\n// y una tarea asociada a ese usuario,\n\nUsuario usuario = new Usuario(\"juan.gutierrez@gmail.com\");\nTarea tarea = new Tarea(usuario, \"Pr\u00e1ctica 1 de MADS\");\n\n// WHEN // THEN\n// se lanza una excepci\u00f3n al intentar salvar la tarea en la BD\n\nAssertions.assertThrows(Exception.class, () -&gt; {\ntareaRepository.save(tarea);\n});\n}\n\n@Test\n@Transactional\npublic void unUsuarioTieneUnaListaDeTareas() {\n// GIVEN\n// Un usuario con 2 tareas en la base de datos\nUsuario usuario = new Usuario(\"user@ua\");\nusuarioRepository.save(usuario);\nLong usuarioId = usuario.getId();\n\nTarea tarea1 = new Tarea(usuario, \"Pr\u00e1ctica 1 de MADS\");\nTarea tarea2 = new Tarea(usuario, \"Renovar el DNI\");\ntareaRepository.save(tarea1);\ntareaRepository.save(tarea2);\n\n// WHEN\n// recuperamos el ususario de la base de datos,\n\nUsuario usuarioRecuperado = usuarioRepository.findById(usuarioId).orElse(null);\n\n// THEN\n// su lista de tareas tambi\u00e9n se recupera, porque se ha\n// definido la relaci\u00f3n de usuario y tareas como EAGER.\n\nassertThat(usuarioRecuperado.getTareas()).hasSize(2);\n}\n\n@Test\n@Transactional\npublic void a\u00f1adirUnaTareaAUnUsuarioEnBD() {\n// GIVEN\n// Un usuario en la base de datos\nUsuario usuario = new Usuario(\"user@ua\");\nusuarioRepository.save(usuario);\nLong usuarioId = usuario.getId();\n\n// WHEN\n// Creamos una nueva tarea con el usuario recuperado de la BD\n// y la salvamos,\n\nUsuario usuarioBD = usuarioRepository.findById(usuarioId).orElse(null);\nTarea tarea = new Tarea(usuarioBD, \"Pr\u00e1ctica 1 de MADS\");\ntareaRepository.save(tarea);\nLong tareaId = tarea.getId();\n\n// THEN\n// la tarea queda guardada en la BD asociada al usuario\n\nTarea tareaBD = tareaRepository.findById(tareaId).orElse(null);\nassertThat(tareaBD).isEqualTo(tarea);\nassertThat(tarea.getUsuario()).isEqualTo(usuarioBD);\n\n// y si recuperamos el usuario se obtiene la nueva tarea\nusuarioBD = usuarioRepository.findById(usuarioId).orElse(null);\nassertThat(usuarioBD.getTareas()).contains(tareaBD);\n}\n\n\n@Test\n@Transactional\npublic void cambioEnLaEntidadEnTransactionalModificaLaBD() {\n// GIVEN\n// Un usuario y una tarea en la base de datos\nUsuario usuario = new Usuario(\"user@ua\");\nusuarioRepository.save(usuario);\nTarea tarea = new Tarea(usuario, \"Pr\u00e1ctica 1 de MADS\");\ntareaRepository.save(tarea);\n\n// Recuperamos la tarea\nLong tareaId = tarea.getId();\ntarea = tareaRepository.findById(tareaId).orElse(null);\n\n// WHEN\n// modificamos la descripci\u00f3n de la tarea\n\ntarea.setTitulo(\"Esto es una prueba\");\n\n// THEN\n// la descripci\u00f3n queda actualizada en la BD.\n\nTarea tareaBD = tareaRepository.findById(tareaId).orElse(null);\nassertThat(tareaBD.getTitulo()).isEqualTo(tarea.getTitulo());\n}\n}\n</code></pre> <p>Te recomiendo que leas con cuidado los tests y sus comentarios. Son muy \u00fatiles para entender el funcionamiento de la aplicaci\u00f3n (en este caso de las entidades y de la capa repository).</p> <p>Utilizamos el formato GIVEN, WHEN, THEN para estructurar el test. En la parte GIVEN se preparan los datos, en la parte WHEN se lanza el m\u00e9todo o m\u00e9todos que se quieren probar y en la parte THEN se comprueban los resultados.</p> <p>Se realizan distintos tipos de tests dentro de la misma clase:</p> <ul> <li>Pruebas sobre las entidades por si solas, sin conexi\u00f3n con la   base de datos. Son lo que se denomina tests del modelo.</li> <li>Pruebas sobre la capa repository, en las que se comprueban que las   operaciones de b\u00fasqueda y actualizaci\u00f3n funcionan correctamente   sobre la base de datos. En muchas de estas pruebas se necesita   realizar m\u00e1s de una sentencia con la misma conexi\u00f3n a la base de   datos o acceder a atributos lazy. Para esto es necesario usar la   anotaci\u00f3n <code>@Transactional</code>.</li> </ul>"},{"location":"02-todolist/practica2.html#tests-de-la-capa-de-servicios","title":"Tests de la capa de servicios","text":"<p>Tambi\u00e9n se realizan tests sobre la capa de servicio: </p> <ul> <li><code>TareaServiceTest.java</code></li> <li><code>UsuarioServiceTest.java</code></li> </ul> <p>Estos tests comprueban que los m\u00e9todos de servicio funcionan correctamente y modifican la base de datos tal y como se pretende en cada operaci\u00f3n.</p> <p>Veamos, por ejemplo, el fichero <code>TareaServiceTest.java</code>:</p> src/test/java/madstodolist/service/TareaServiceTest.java<pre><code>package madstodolist.service;\n\n// Imports\n...\n\n// Hemos eliminado todos los @Transactional de los tests\n// y usado un script para limpiar la BD de test despu\u00e9s de\n// cada test\n// https://dev.to/henrykeys/don-t-use-transactional-in-tests-40eb\n\n@SpringBootTest\n@Sql(scripts = \"/clean-db.sql\")\npublic class TareaServiceTest {\n\n@Autowired\nUsuarioService usuarioService;\n\n@Autowired\nTareaService tareaService;\n\n// M\u00e9todo para inicializar los datos de prueba en la BD\n// Devuelve un mapa con los identificadores del usuario y de la primera tarea a\u00f1adida\nMap&lt;String, Long&gt; addUsuarioTareasBD() {\nUsuarioData usuario = new UsuarioData();\nusuario.setEmail(\"user@ua\");\nusuario.setPassword(\"123\");\n\n// A\u00f1adimos un usuario a la base de datos\nUsuarioData usuarioNuevo = usuarioService.registrar(usuario);\n\n// Y a\u00f1adimos dos tareas asociadas a ese usuario\nTareaData tarea1 = tareaService.nuevaTareaUsuario(usuarioNuevo.getId(), \"Lavar coche\");\ntareaService.nuevaTareaUsuario(usuarioNuevo.getId(), \"Renovar DNI\");\n\n// Devolvemos los ids del usuario y de la primera tarea a\u00f1adida\nMap&lt;String, Long&gt; ids = new HashMap&lt;&gt;();\nids.put(\"usuarioId\", usuarioNuevo.getId());\nids.put(\"tareaId\", tarea1.getId());\nreturn ids;\n}\n\n@Test\npublic void testNuevaTareaUsuario() {\n// GIVEN\n// Un usuario en la BD\n\nLong usuarioId = addUsuarioTareasBD().get(\"usuarioId\");\n\n// WHEN\n// creamos una nueva tarea asociada al usuario,\nTareaData nuevaTarea = tareaService.nuevaTareaUsuario(usuarioId, \"Pr\u00e1ctica 1 de MADS\");\n\n// THEN\n// al recuperar la lista de tareas del usuario, la nueva tarea\n// est\u00e1 en la lista de tareas del usuario.\n\nList&lt;TareaData&gt; tareas = tareaService.allTareasUsuario(usuarioId);\n\nassertThat(tareas).hasSize(3);\nassertThat(tareas).contains(nuevaTarea);\n}\n\n@Test\npublic void testBuscarTarea() {\n// GIVEN\n// Una tarea en la BD\n\nLong tareaId = addUsuarioTareasBD().get(\"tareaId\");\n\n// WHEN\n// recuperamos una tarea de la base de datos a partir de su ID,\n\nTareaData lavarCoche = tareaService.findById(tareaId);\n\n// THEN\n// los datos de la tarea recuperada son correctos.\n\nassertThat(lavarCoche).isNotNull();\nassertThat(lavarCoche.getTitulo()).isEqualTo(\"Lavar coche\");\n}\n\n@Test\npublic void testModificarTarea() {\n// GIVEN\n// Un usuario y una tarea en la BD\n\nMap&lt;String, Long&gt; ids = addUsuarioTareasBD();\nLong usuarioId = ids.get(\"usuarioId\");\nLong tareaId = ids.get(\"tareaId\");\n\n// WHEN\n// modificamos la tarea correspondiente al identificador,\n\ntareaService.modificaTarea(tareaId, \"Limpiar los cristales del coche\");\n\n// THEN\n// al buscar por el identificador en la base de datos se devuelve la tarea modificada\n\nTareaData tareaBD = tareaService.findById(tareaId);\nassertThat(tareaBD.getTitulo()).isEqualTo(\"Limpiar los cristales del coche\");\n\n// y el usuario tiene tambi\u00e9n esa tarea modificada.\nList&lt;TareaData&gt; tareas = tareaService.allTareasUsuario(usuarioId);\nassertThat(tareas).contains(tareaBD);\n}\n\n@Test\npublic void testBorrarTarea() {\n// GIVEN\n// Un usuario y una tarea en la BD\n\nMap&lt;String, Long&gt; ids = addUsuarioTareasBD();\nLong usuarioId = ids.get(\"usuarioId\");\nLong tareaId = ids.get(\"tareaId\");\n\n// WHEN\n// borramos la tarea correspondiente al identificador,\n\ntareaService.borraTarea(tareaId);\n\n// THEN\n// la tarea ya no est\u00e1 en la base de datos ni en las tareas del usuario.\n\nassertThat(tareaService.findById(tareaId)).isNull();\n\nList&lt;TareaData&gt; tareas = tareaService.allTareasUsuario(usuarioId);\nassertThat(tareas).hasSize(1);\n}\n\n@Test\npublic void asignarEtiquetaATarea(){\n\nMap&lt;String, Long&gt; ids = addUsuarioTareasBD();\nLong usuarioId = ids.get(\"usuarioId\");\nLong tareaId = ids.get(\"tareaId\");\n\nassertThat(tareaService.usuarioContieneTarea(usuarioId,tareaId)).isTrue();\n}\n\n}\n</code></pre> <p>Para conseguir que los tests sean independientes y evitar que datos introducidos o modificados en un test afecten a otros tests, limpiamos las tablas de la base de datos al final de cada test usando la anotaci\u00f3n <code>@Sql</code>:</p> <pre><code>@Sql(scripts = \"/clean-db.sql\", executionPhase = AFTER_TEST_METHOD)\npublic class TareaServiceTest {\n</code></pre> <p>Los datos de prueba se introducen al principio de cada test.</p>"},{"location":"02-todolist/practica2.html#tests-de-la-capa-controller","title":"Tests de la capa controller","text":"<p>Por \u00faltimo, tambi\u00e9n realizamos tests sobre los controllers:</p> <ul> <li><code>UsuarioWebTest.java</code></li> <li><code>TareaWebTest.java</code></li> </ul> <p>En estos tests se comprueba que el resultado de realizar un <code>GET</code> o un <code>POST</code> sobre los endpoints correspondientes devuelven un HTML que contiene alguna cadena que coincide con lo esperado.</p> <p>Existen dos enfoques a la hora de definir estos tests. </p> <ul> <li>Podemos, al igual que hemos hecho en los tests de servicio,   introducir los datos de prueba al comienzo de cada test.</li> <li>Podemos mockear los servicios para que devuelvan los datos que nos   interesan.</li> </ul> <p>Utilizamos ambos enfoques para que aprendas a trabajar con los dos. En la clase <code>TareaWebTest</code> se utilizan los datos de prueba de la base de datos y en la clase <code>UsuarioWebTest</code> se mockean los servicios.</p> <p>La utilizaci\u00f3n de mocks es muy \u00fatil tambi\u00e9n para poder testear los m\u00e9todos que tienen un acceso restringido al usuario que hace la operaci\u00f3n. Por ejemplo, la consulta o modificaci\u00f3n de una tarea. Mockeamos el <code>managerUserSession</code> para simular que el usuario est\u00e1 logeado.</p> <p>Mostramos a continuaci\u00f3n los ficheros de test de controllers.</p> <p>Para los tests de tareas se a\u00f1aden datos de prueba a la base de datos y despu\u00e9s se comprueba que los controllers devuelven p\u00e1ginas HTML que contienen los resultados esperados.</p> src/test/java/madstodolist/controller/TareaWebTest.java<pre><code>package madstodolist.controller;\n\n// Imports\n...\n\n@SpringBootTest\n@AutoConfigureMockMvc\n@Sql(scripts = \"/clean-db.sql\")\npublic class TareaWebTest {\n\n@Autowired\nprivate MockMvc mockMvc;\n\n// Declaramos los servicios como Autowired\n@Autowired\nprivate TareaService tareaService;\n\n@Autowired\nprivate UsuarioService usuarioService;\n\n// Moqueamos el managerUserSession para poder moquear el usuario logeado\n@MockBean\nprivate ManagerUserSession managerUserSession;\n\n// M\u00e9todo para inicializar los datos de prueba en la BD\n// Devuelve un mapa con los identificadores del usuario y de la primera tarea a\u00f1adida\n\nMap&lt;String, Long&gt; addUsuarioTareasBD() {\n// A\u00f1adimos un usuario a la base de datos\nUsuarioData usuario = new UsuarioData();\nusuario.setEmail(\"user@ua\");\nusuario.setPassword(\"123\");\nusuario = usuarioService.registrar(usuario);\n\n// Y a\u00f1adimos dos tareas asociadas a ese usuario\nTareaData tarea1 = tareaService.nuevaTareaUsuario(usuario.getId(), \"Lavar coche\");\ntareaService.nuevaTareaUsuario(usuario.getId(), \"Renovar DNI\");\n\n// Devolvemos los ids del usuario y de la primera tarea a\u00f1adida\nMap&lt;String, Long&gt; ids = new HashMap&lt;&gt;();\nids.put(\"usuarioId\", usuario.getId());\nids.put(\"tareaId\", tarea1.getId());\nreturn ids;\n\n}\n\n@Test\npublic void listaTareas() throws Exception {\n// GIVEN\n// Un usuario con dos tareas en la BD\nLong usuarioId = addUsuarioTareasBD().get(\"usuarioId\");\n\n// Moqueamos el m\u00e9todo usuarioLogeado para que devuelva el usuario 1L,\n// el mismo que se est\u00e1 usando en la petici\u00f3n. De esta forma evitamos\n// que salte la excepci\u00f3n de que el usuario que est\u00e1 haciendo la\n// petici\u00f3n no est\u00e1 logeado.\nwhen(managerUserSession.usuarioLogeado()).thenReturn(usuarioId);\n\n// WHEN, THEN\n// se realiza la petici\u00f3n GET al listado de tareas del usuario,\n// el HTML devuelto contiene las descripciones de sus tareas.\n\nString url = \"/usuarios/\" + usuarioId.toString() + \"/tareas\";\n\nthis.mockMvc.perform(get(url))\n.andExpect((content().string(allOf(\ncontainsString(\"Lavar coche\"),\ncontainsString(\"Renovar DNI\")\n))));\n}\n\n@Test\npublic void getNuevaTareaDevuelveForm() throws Exception {\n// GIVEN\n// Un usuario con dos tareas en la BD\nLong usuarioId = addUsuarioTareasBD().get(\"usuarioId\");\n\n// Ver el comentario en el primer test\nwhen(managerUserSession.usuarioLogeado()).thenReturn(usuarioId);\n\n// WHEN, THEN\n// si ejecutamos una petici\u00f3n GET para crear una nueva tarea de un usuario,\n// el HTML resultante contiene un formulario y la ruta con\n// la acci\u00f3n para crear la nueva tarea.\n\nString urlPeticion = \"/usuarios/\" + usuarioId.toString() + \"/tareas/nueva\";\nString urlAction = \"action=\\\"/usuarios/\" + usuarioId.toString() + \"/tareas/nueva\\\"\";\n\nthis.mockMvc.perform(get(urlPeticion))\n.andExpect((content().string(allOf(\ncontainsString(\"form method=\\\"post\\\"\"),\ncontainsString(urlAction)\n))));\n}\n\n@Test\npublic void postNuevaTareaDevuelveRedirectYA\u00f1adeTarea() throws Exception {\n// GIVEN\n// Un usuario con dos tareas en la BD\nLong usuarioId = addUsuarioTareasBD().get(\"usuarioId\");\n\n// Ver el comentario en el primer test\nwhen(managerUserSession.usuarioLogeado()).thenReturn(usuarioId);\n\n// WHEN, THEN\n// realizamos la petici\u00f3n POST para a\u00f1adir una nueva tarea,\n// el estado HTTP que se devuelve es un REDIRECT al listado\n// de tareas.\n\nString urlPost = \"/usuarios/\" + usuarioId.toString() + \"/tareas/nueva\";\nString urlRedirect = \"/usuarios/\" + usuarioId.toString() + \"/tareas\";\n\nthis.mockMvc.perform(post(urlPost)\n.param(\"titulo\", \"Estudiar examen MADS\"))\n.andExpect(status().is3xxRedirection())\n.andExpect(redirectedUrl(urlRedirect));\n\n// y si despu\u00e9s consultamos el listado de tareas con una petici\u00f3n\n// GET el HTML contiene la tarea a\u00f1adida.\n\nthis.mockMvc.perform(get(urlRedirect))\n.andExpect((content().string(containsString(\"Estudiar examen MADS\"))));\n}\n\n@Test\npublic void deleteTareaDevuelveOKyBorraTarea() throws Exception {\n// GIVEN\n// Un usuario con dos tareas en la BD\nMap&lt;String, Long&gt; ids = addUsuarioTareasBD();\nLong usuarioId = ids.get(\"usuarioId\");\nLong tareaLavarCocheId = ids.get(\"tareaId\");\n\n// Ver el comentario en el primer test\nwhen(managerUserSession.usuarioLogeado()).thenReturn(usuarioId);\n\n// WHEN, THEN\n// realizamos la petici\u00f3n DELETE para borrar una tarea,\n// se devuelve el estado HTTP que se devuelve es OK,\n\nString urlDelete = \"/tareas/\" + tareaLavarCocheId.toString();\n\nthis.mockMvc.perform(delete(urlDelete))\n.andExpect(status().isOk());\n\n// y cuando se pide un listado de tareas del usuario, la tarea borrada ya no aparece.\n\nString urlListado = \"/usuarios/\" + usuarioId + \"/tareas\";\n\nthis.mockMvc.perform(get(urlListado))\n.andExpect(content().string(\nallOf(not(containsString(\"Lavar coche\")),\ncontainsString(\"Renovar DNI\"))));\n}\n\n@Test\npublic void editarTareaActualizaLaTarea() throws Exception {\n// GIVEN\n// Un usuario con dos tareas en la BD\nMap&lt;String, Long&gt; ids = addUsuarioTareasBD();\nLong usuarioId = ids.get(\"usuarioId\");\nLong tareaLavarCocheId = ids.get(\"tareaId\");\n\n// Ver el comentario en el primer test\nwhen(managerUserSession.usuarioLogeado()).thenReturn(usuarioId);\n\n// WHEN, THEN\n// realizamos una petici\u00f3n POST al endpoint para editar una tarea\n\nString urlEditar = \"/tareas/\" + tareaLavarCocheId + \"/editar\";\nString urlRedirect = \"/usuarios/\" + usuarioId + \"/tareas\";\n\nthis.mockMvc.perform(post(urlEditar)\n.param(\"titulo\", \"Limpiar cristales coche\"))\n.andExpect(status().is3xxRedirection())\n.andExpect(redirectedUrl(urlRedirect));\n\n// Y si realizamos un listado de las tareas del usuario\n// ha cambiado el t\u00edtulo de la tarea modificada\n\nString urlListado = \"/usuarios/\" + usuarioId + \"/tareas\";\n\nthis.mockMvc.perform(get(urlListado))\n.andExpect(content().string(containsString(\"Limpiar cristales coche\")));\n}\n}\n</code></pre> <p>Para los tests de usuarios usamos el enfoque de moquear los servicios con los datos que queremos que devuelvan (no tocamos la base de datos) y, al igual que antes, comprobamos que los controllers devuelven las p\u00e1ginas HTML con los datos correctos.</p> src/test/java/madstodolist/controller/UsuarioWebTest.java<pre><code>package madstodolist.controller;\n\n// Imports\n...\n\n@SpringBootTest\n@AutoConfigureMockMvc\n//\n// A diferencia de los tests web de tarea, donde us\u00e1bamos los datos\n// de prueba de la base de datos, aqu\u00ed vamos a practicar otro enfoque:\n// moquear el usuarioService.\npublic class UsuarioWebTest {\n\n@Autowired\nprivate MockMvc mockMvc;\n\n// Moqueamos el usuarioService.\n// En los tests deberemos proporcionar el valor devuelto por las llamadas\n// a los m\u00e9todos de usuarioService que se van a ejecutar cuando se realicen\n// las peticiones a los endpoint.\n@MockBean\nprivate UsuarioService usuarioService;\n\n@Test\npublic void servicioLoginUsuarioOK() throws Exception {\n// GIVEN\n// Moqueamos la llamada a usuarioService.login para que\n// devuelva un LOGIN_OK y la llamada a usuarioServicie.findByEmail\n// para que devuelva un usuario determinado.\n\nUsuarioData anaGarcia = new UsuarioData();\nanaGarcia.setNombre(\"Ana Garc\u00eda\");\nanaGarcia.setId(1L);\n\nwhen(usuarioService.login(\"ana.garcia@gmail.com\", \"12345678\"))\n.thenReturn(UsuarioService.LoginStatus.LOGIN_OK);\nwhen(usuarioService.findByEmail(\"ana.garcia@gmail.com\"))\n.thenReturn(anaGarcia);\n\n// WHEN, THEN\n// Realizamos una petici\u00f3n POST al login pasando los datos\n// esperados en el mock, la petici\u00f3n devolver\u00e1 una redirecci\u00f3n a la\n// URL con las tareas del usuario\n\nthis.mockMvc.perform(post(\"/login\")\n.param(\"eMail\", \"ana.garcia@gmail.com\")\n.param(\"password\", \"12345678\"))\n.andExpect(status().is3xxRedirection())\n.andExpect(redirectedUrl(\"/usuarios/1/tareas\"));\n}\n\n@Test\npublic void servicioLoginUsuarioNotFound() throws Exception {\n// GIVEN\n// Moqueamos el m\u00e9todo usuarioService.login para que devuelva\n// USER_NOT_FOUND\nwhen(usuarioService.login(\"pepito.perez@gmail.com\", \"12345678\"))\n.thenReturn(UsuarioService.LoginStatus.USER_NOT_FOUND);\n\n// WHEN, THEN\n// Realizamos una petici\u00f3n POST con los datos del usuario mockeado y\n// se debe devolver una p\u00e1gina que contenga el mensaja \"No existe usuario\"\nthis.mockMvc.perform(post(\"/login\")\n.param(\"eMail\",\"pepito.perez@gmail.com\")\n.param(\"password\",\"12345678\"))\n.andExpect(content().string(containsString(\"No existe usuario\")));\n}\n\n@Test\npublic void servicioLoginUsuarioErrorPassword() throws Exception {\n// GIVEN\n// Moqueamos el m\u00e9todo usuarioService.login para que devuelva\n// ERROR_PASSWORD\nwhen(usuarioService.login(\"ana.garcia@gmail.com\", \"000\"))\n.thenReturn(UsuarioService.LoginStatus.ERROR_PASSWORD);\n\n// WHEN, THEN\n// Realizamos una petici\u00f3n POST con los datos del usuario mockeado y\n// se debe devolver una p\u00e1gina que contenga el mensaja \"Contrase\u00f1a incorrecta\"\nthis.mockMvc.perform(post(\"/login\")\n.param(\"eMail\",\"ana.garcia@gmail.com\")\n.param(\"password\",\"000\"))\n.andExpect(content().string(containsString(\"Contrase\u00f1a incorrecta\")));\n}\n}\n</code></pre>"},{"location":"02-todolist/practica2.html#4-metodologia-de-desarrollo","title":"4. Metodolog\u00eda de desarrollo","text":"<p>En cuanto a la metodolog\u00eda de desarrollo, en esta pr\u00e1ctica repasaremos e introduciremos el uso de:</p> <ul> <li>Git como sistema de control de versiones que nos permitir\u00e1   registrar paso a paso los cambios realizados en el desarrollo,   realizando e integrando ramas de features en las que   desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las   funcionalidades necesarias en la aplicaci\u00f3n.</li> <li>GitHub como servicio en el que publicaremos los cambios e   integraremos las ramas usando pull requests (PRs). Utilizaremos un   gran n\u00famero de caracter\u00edsticas de GitHub para realizar el   seguimiento del desarrollo del proyecto: issues, labels,   milestones, etc.</li> <li>JUnit y las caracter\u00edsticas de testing de Spring   Boot   para realizar continuamente pruebas unitarias que   validen el desarrollo.</li> </ul> <p>El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source. </p> <p>Existen muchos proyectos que tienen un desarrollo abierto, transparente, en GitHub. Podemos aprender de sus metodolog\u00edas estudi\u00e1ndolos. A continuaci\u00f3n listamos ejemplos de repositorios en GitHub interesantes, en los que podemos estudiar los procesos de pull requests, issues, tableros, etc. y las din\u00e1micas de comunicaci\u00f3n que utilizan.</p> <ul> <li>CartoDB. Software espa\u00f1ol para   representaci\u00f3n visual de datos geogr\u00e1ficos.</li> <li>Vapor. Framework web en Swift.</li> <li>Guice. Framework de inyecci\u00f3n de   dependencias en Java.</li> <li>swift-nio. Framework as\u00edncrono   de entrada-salida en Swift. </li> <li>Spring   Boot. Framework web   en Java.</li> </ul>"},{"location":"02-todolist/practica2.html#git","title":"Git","text":"<p>Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento.</p> <ul> <li>Resumen de comandos de Git: Resumen de comandos   principales para empezar a trabajar con Git.</li> <li>Atlassian Git Tutorials:   Tutoriales muy orientados al uso de Git con gran cantidad de   ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos Getting   Started   y los tutoriales   Syncing y Using   Branches en   el apartado Collaborating.</li> <li>Libro de Scott Chacon: Completo   manual con todos los detalles de todos los comandos de Git.</li> </ul> <p>Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto.</p>"},{"location":"02-todolist/practica2.html#flujo-de-trabajo","title":"Flujo de trabajo","text":"<p>Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian.</p> <p>Para implementar este flujo de trabajo utilizaremos los siguientes instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo:</p> <ul> <li> <p>Issues (incidencias): GitHub permite abrir issues   (incidencias o tareas), asignarlos a personas, realizar comentarios,   asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha   terminado. Consultar   Mastering Issues.</p> <p></p> <p>Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: bug, technical, enhancement. Los issues que implementan una historia de usuario los etiquetaremos con el c\u00f3digo de la historia de usuario. Puede haber m\u00e1s de un issue asociado con una historia de usuario y de esta forma podemos agruparlos.</p> <p></p> <p>Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama main haciendo un pull request.</p> </li> <li> <p>Pull Requests: Un pull request permite avisar al equipo de que   se va a integrar en la rama principal una rama con un desarrollo   nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se   pueden realizar comentarios, revisiones de c\u00f3digo o definir   pol\u00edticas de aceptaci\u00f3n del PR. Consultar   About pull requests.</p> <p>Implementaremos cada issue en una rama separada de git y la integraremos en la rama <code>main</code> haciendo un pull request. Cuando se mezcle el PR en <code>main</code> el issue se cerrar\u00e1.</p> <p></p> <p>M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido <code>releases</code> para incluir en ella las releases del proyecto.</p> </li> <li> <p>Milestones y Releases: Etiquetaremos cada issue con el   milestone en el que queremos que se lance. Para identificar el   milestone usaremos el versionado sem\u00e1ntico:   MAJOR.MINOR.PATCH. </p> <p></p> <p>Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues ese milestone).</p> <p></p> </li> <li> <p>Tablero de proyecto: Un tablero de proyecto en GitHub nos   ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada   issue: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar,   implementar, probar, etc. Vamos a utilizar la funcionalidad propia   de GitHub llamada Projects. Consultar Quickstart for Projects</p> <p></p> <p>Cuando se crea un pull request que resuelve un issue enlazaremos el issue con el pull request. Podremos ver en el tablero que bajo el issue aparece su PR enlazado y podremos desplegarlo en la propia tarjeta (funcionalidad nueva de GitHub).</p> <p></p> </li> </ul> <p>Tambi\u00e9n utilizaremos un panel de Trello para representar las historias de usuario que se van implementando en el proyecto. </p> <p></p> <p>Cada historia de usuario tendr\u00e1 un c\u00f3digo num\u00e9rico y podr\u00e1 implementarse con uno o m\u00e1s issues. En GitHub crearemos una etiqueta por cada historia de usuario y se la asignaremos a los issues que se usen para implementarla.</p> <p>Importante</p> <p>Puede parecer redundante el uso de dos tableros, uno para las historias de usuario y otro para los issues y PR. La justificaci\u00f3n es que los objetivos de ambos tableros son distintos (y los contenidos tambi\u00e9n). El tablero Trello es un tablero de funcionalidades de usuario, que es gestionado por el product owner, usado por el equipo de desarrollo y puede ser compartido tambi\u00e9n con clientes y gerencia. En la terminolog\u00eda de Scrum ser\u00e1 el product backlog. Mientras que el tablero de GitHub ser\u00e1 un tablero t\u00e9cnico gestionado por el equipo de desarrollo. En terminolog\u00eda de Scrum ser\u00e1 el sprint backlog. </p> <p>La documentaci\u00f3n en Trello y en GitHub (en los issues, en los PRs y en el propio <code>README.md</code> del proyecto) hay que escribirla en Markdown, un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub.</p> <p>Nota</p> <p>Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira, YouTrack o Confluence. Pero la combinaci\u00f3n de GitHub + Trello es suficiente para lo que vamos a realizar en la asignatura y para aprender los objetivos y el funcionamiento de estos tipos de sistemas basados en incidencias.</p>"},{"location":"02-todolist/practica2.html#5-antes-de-empezar-la-practica","title":"5. Antes de empezar la pr\u00e1ctica","text":"<ol> <li> <p>Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que    compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1    autom\u00e1ticamente tu repositorio <code>mads-todolist-&lt;usuario&gt;</code> en la    organizaci\u00f3n mads-ua. Al igual    que el repositorio de la primera parte de la pr\u00e1ctica es un    repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene    el c\u00f3digo inicial de un proyecto base (es una copia del repositorio    domingogallardo/mads-todolist-inicial)    en la que se han comprimido todos los commits en uno.</p> <p>Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n <code>mads-ua-23-24</code>. Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas.</p> </li> <li> <p>Descarga el proyecto y comprueba que se compila y ejecuta    correctamente:</p> <pre><code>$ git clone https://github.com/mads-ua/mads-todolist-&lt;usuario&gt;.git\n$ cd mads-todolist-&lt;usuario&gt;\n$ ./mvnw spring-boot:run\n</code></pre> <p>Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:8080/login en la m\u00e1quina host.</p> <p></p> <p>Para la aplicaci\u00f3n haciendo CTR+C en el terminal.</p> </li> <li> <p>Importa el proyecto en IntelliJ para trabajar, ejecutar los tests y    lanzar la aplicaci\u00f3n desde este entorno.</p> </li> <li> <p>Es posible examinar el esquema de la base de datos y los datos    accediendo a la base de datos H2 en memoria a\u00f1adiendo las    siguientes preferencias:</p> <pre><code>spring.h2.console.enabled=true\nspring.h2.console.path=/h2-console\n</code></pre> <p>Una vez lanzada la aplicaci\u00f3n, podemos acceder a http://localhost:8080/h2-console introduciendo como <code>JDBC URL</code> la direcci\u00f3n de la fuente de datos <code>jdbc:h2:mem:dev</code> y como <code>User name</code> la cadena <code>sa</code></p> <p></p> <p>Y examinar tablas en concreto:</p> <p></p> </li> </ol>"},{"location":"02-todolist/practica2.html#6-desarrollo-de-la-practica","title":"6. Desarrollo de la pr\u00e1ctica","text":"<p>En esta primera pr\u00e1ctica vamos a desarrollar las siguientes historias de usuario o features:</p> <ol> <li>P\u00e1gina Acerca de</li> <li>Barra de men\u00fa</li> <li>P\u00e1gina listado de usuarios</li> <li>P\u00e1gina descripci\u00f3n de usuario</li> <li>Usuario administrador (opcional)</li> <li>Protecci\u00f3n del listado y descripci\u00f3n de usuarios (opcional)</li> <li>Bloqueo de usuarios por el usuario administrador (opcional)</li> </ol> <p>La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : tablero Trello, issues, pull requests (con sus commits en los que se desarrolla paso a paso cada issue) y tablero del proyecto. </p> <p>Haremos paso a paso la historia de usuario 1, creando la primera versi\u00f3n 1.0.1 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0.</p>"},{"location":"02-todolist/practica2.html#version-101","title":"Versi\u00f3n 1.0.1","text":"<p>Para que veas la metodolog\u00eda de desarrollo, vamos a desarrollar una versi\u00f3n 1.0.1 en la que se implementa la primera caracter\u00edstica: P\u00e1gina Acerca de. Todo el resto de funcionalidades las deber\u00e1s incorporar en la versi\u00f3n 1.1.0, que deber\u00e1s desarrollar durante las cuatro semanas que dura esta pr\u00e1ctica.</p> <p>No hay que hacer versiones 1.0.2, 1.0.3, etc.</p> <p>No hay que hacer un release nuevo para cada nueva caracter\u00edstica. El milestone 1.1.0 tiene que contener todas las nuevas funcionalidades de la pr\u00e1ctica y el release de la versi\u00f3n 1.1.0 se hace al final, cuando se entregue la pr\u00e1ctica. La versi\u00f3n 1.0.1 la usamos solo como ejemplo, para explicar el proceso de lanzar una nueva versi\u00f3n. Por ello no hay que hacer versiones 1.0.2, 1.0.3, etc., solo la 1.1.0.</p>"},{"location":"02-todolist/practica2.html#tablero-trello","title":"Tablero Trello","text":"<p>Crea un en Trello un tablero p\u00fablico llamado <code>ToDoList MADS</code>. Va a servir como backlog de las historias de usuario que debes realizar en la pr\u00e1ctica.  A\u00f1ade en \u00e9l 3 columnas, tal y se explica en el apartado anterior de metodolog\u00eda de desarrollo.</p> <p>A\u00f1ade el enlace en el README del repositorio GitHub, para que el profesor pueda acceder a consultar el estado del proyecto.</p> <p>El tablero Trello debe ser p\u00fablico</p> <p>Para evitar tener que gestionar invitaciones de colaboraci\u00f3n en tableros Trello, deb\u00e9is hacer p\u00fablico el tablero. El profesor podr\u00e1 acceder al tablero a trav\u00e9s del enlace en el README del proyecto. El proyecto es privado, por lo que solo vosotros y el profesor tendr\u00e9is acceso al tablero.</p> <p>Un ejemplo de tablero es el Trello del proyecto mads-todolist-inicial. </p> <p>Utilizaremos el tablero Trello para documentar las caracter\u00edsticas a desarrollar en la aplicaci\u00f3n. Deber\u00e1 haber una tarjeta para cada caracter\u00edstica. Cada caracter\u00edstica deber\u00e1 tener un n\u00famero y un t\u00edtulo.</p> <p></p> <p>A\u00f1ade la descripci\u00f3n de la caracter\u00edstica P\u00e1gina Acerca de:</p> <p></p> <p>Cuando empecemos a trabajar en la historia de usuario moveremos la tarjeta a En marcha y cuando la hayamos terminado de testear e integrar en la rama principal la moveremos a Terminadas.</p>"},{"location":"02-todolist/practica2.html#tablero-de-github","title":"Tablero de GitHub","text":"<p>GitHub ha cambiado recientemente la forma de gestionar visualmente los issues para hacerla mucho m\u00e1s flexible y potente.</p> <p>En la versi\u00f3n actual, la funcionalidad se denomina Proyectos. Un proyecto est\u00e1 asociado a un usuario de GitHub y puede contener issues de m\u00e1s de un repositorio. Un usuario puede crear los proyectos que considere necesarios. Tambi\u00e9n se pueden crear proyectos asociados a organizaciones.</p> <p>En cuanto a la forma de visualizar los issues, podemos seleccionar dos formas: como un tablero o como una hoja de c\u00e1lculo. La primera forma es m\u00e1s sencilla y la segunda m\u00e1s potente. En la asignatura usaremos la primera.</p> <p>Puedes encontrar m\u00e1s informaci\u00f3n sobre los GitHub Projects en este enlace.</p> <p>En la asignatura vamos a usar los proyectos de GitHub para mostrar, en forma de tablero, los issues del repositorio de la pr\u00e1ctica. Tambi\u00e9n podremos acceder a los pull requests desde cada uno de los issues (enlazaremos los issues a su pull request).</p> <p>Aviso</p> <p>Aunque se han a\u00f1adido en los apuntes las nuevas im\u00e1genes sobre el proceso de creaci\u00f3n de un proyecto, no se han actualizado todas las im\u00e1genes en las que aparece el tablero de proyectos, por lo que puede que alguna imagen no represente fielmente la aparencia real que tiene en la actualidad.</p> <p>Lo primero que debes hacer es crear un proyecto desde el enlace <code>Projects</code> en la organizaci\u00f3n mads-ua-23-24.</p> <p></p> <p>Selecciona la opci\u00f3n Board y ponle como nombre tu usuario de GitHub:</p> <p></p> <p>Define una columna adicional In Pull Request, entre In Progress y Done:</p> <p></p> <p>En las columnas colocaremos los issues del proyecto (y los PRs estar\u00e1n enlazados en ellos). GitHub permite automatizar el movimiento de las tarjetas de una columna a otra.</p> <p>Activa dos flujos de trabajo. Uno para que cuando un issue nuevo se a\u00f1ada al proyecto se coloque en la columna To Do:</p> <p></p> <p>Y otro para que cuando se cierre un issue se mueva a la columna de Done:</p> <p></p> <p>El resto de cambios de los issues los tendr\u00e1s que hacer manualmente. Por ejemplo, cuando crees el pull request asociado a un issue tendr\u00e1s que mover el issue a la columna de In Pull Request.</p> <p>En resumen, las condiciones de las fichas que habr\u00e1 en cada columna son las siguientes: </p> <ul> <li>Columna <code>To do</code>: Nuevos issues a\u00f1adidos al proyecto. Cuando   a\u00f1adimos el proyecto al issue (en la p\u00e1gina del issue) GitHub   lo coloca autom\u00e1ticamente en esta columna.</li> <li>Columna <code>In progress</code>: issues que se han comenzado a implementar   (se ha creado una rama su desarrollo). Manual.</li> <li>Columna <code>In pull request</code>: moveremos a esta columna el issue abramos   un PR y lo enlacemos con el issue. Manual.   GitHub lo coloca autom\u00e1ticamente en esta columna. implementado por el pull request manualmente.</li> <li>Columna <code>Done</code>: pull requests cerrados. GitHub lo detecta autom\u00e1ticamente.</li> </ul> <p>Por \u00faltimo, en la opci\u00f3n Settings &gt; Manage access comparte el tablero con mi usuario de GitHub <code>domingogallardo</code>, para que pueda revisarlo:</p> <p></p> <p>Y cambia el base role a modo No access para solo tengan acceso al tablero las personas colaboradoras.</p> <p></p> <p>Por \u00faltimo, desde la p\u00e1gina Projects del repositorio, a\u00f1ade el proyecto al repositorio:</p> <p></p>"},{"location":"02-todolist/practica2.html#issues","title":"Issues","text":"<p>A\u00f1ade en el proyecto las etiquetas que vamos a usar inicialmente.</p> <p></p> <p>Crea el primer issue, correspondiente a la feature a desarrollar P\u00e1gina Acerca de. </p> <p></p> <p>Crea el milestone 1.0.1. Y, desde la p\u00e1gina del issue, a\u00f1ade el milestone y el proyecto. Autom\u00e1ticamente se a\u00f1adir\u00e1 en la columna <code>To Do</code>.</p> <p></p> <p>En el listado de issues del repositorio debe aparecer este reci\u00e9n creado:</p> <p></p>"},{"location":"02-todolist/practica2.html#desarrollo","title":"Desarrollo","text":"<p>Para desarrollar el issue abriremos una rama en Git, realizaremos commits sobre ella hasta estar terminado y despu\u00e9s crearemos un pull request en GitHub para realizar la integraci\u00f3n con la rama <code>main</code>.</p> <p>Mueve en el tablero la tarjeta con el issue a la columna <code>In progress</code>.</p> <p></p> <p>Empezamos el desarrollo importando el proyecto en IntelliJ y abriendo un terminal para trabajar con Git:</p> <p></p> <p>En el terminal escribimos los comandos para crear la rama en la que desarrollaremos la feature y subirla:</p> <pre><code>(main) $ git checkout -b acerca-de\n(acerca-de) $ git push -u origin acerca-de\n</code></pre>"},{"location":"02-todolist/practica2.html#primer-commit","title":"Primer commit","text":"<p>Hacemos un primer commit.</p> <p>Cambia en <code>pom.xml</code> el nombre del proyecto (<code>artifactId</code>) a <code>mads-todolist-&lt;tu-nombre&gt;</code> y la versi\u00f3n a <code>1.0.1-SNAPSHOT</code>. El sufijo <code>SNAPSHOT</code> indica en desarrollo. Cuando hagamos el release de la versi\u00f3n 1.0.1 eliminaremos el sufijo.</p> <p>Realiza el commit y s\u00fabelo a GitHub:</p> <pre><code>(acerca-de) $ git status (comprobamos los ficheros que han cambiado)\nOn branch acerca-de\nYour branch is up to date with 'origin/acerca-de'.\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n    modified:   README.md\n    modified:   pom.xml\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n(acerca-de) $ git add .\n(acerca-de) $ git status (comprobamos que est\u00e1 listo para a\u00f1adirse en el commit)\n(acerca-de) $ git commit -m \"Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.1\"\nOn branch acerca-de\nYour branch is up to date with 'origin/acerca-de'.\n\nChanges to be committed:\n  (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n\n    modified:   README.md\n    modified:   pom.xml\n(acerca-de) $ git push\n</code></pre> <p>Consulta en GitHub que el commit se ha subido en GitHub:</p> <p></p> <p>De esta forma habr\u00e1s comprobado que tienes permiso de escritura en el repositorio y que ya puedes comenzar a realizar la pr\u00e1ctica.</p>"},{"location":"02-todolist/practica2.html#segundo-commit","title":"Segundo commit","text":"<p>En el segundo commit incluiremos el desarrollo de los elementos necesarios para la p\u00e1gina acerca de:</p> <ul> <li>Acci\u00f3n en controller</li> <li>Vista</li> </ul> <p>A\u00f1ade los siguientes ficheros:</p> <p>Controller</p> main/java/madstodolist/controller/HomeController.java<pre><code>package madstodolist.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Controller\npublic class HomeController {\n\n@GetMapping(\"/about\")\npublic String about(Model model) {\nreturn \"about\";\n}\n\n}\n</code></pre> <p>Vista:</p> main/resources/templates/about.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n\n&lt;head th:replace=\"fragments :: head (titulo='Acerca de')\"&gt;&lt;/head&gt;\n\n&lt;body&gt;\n&lt;div class=\"container-fluid\"&gt;\n    &lt;div class=\"container-fluid\"&gt;\n        &lt;h1&gt;ToDoList&lt;/h1&gt;\n        &lt;ul&gt;\n            &lt;li&gt;Desarrollada por TU NOMBRE &lt;/li&gt;\n            &lt;li&gt;Versi\u00f3n 1.0.1 (en desarrollo)&lt;/li&gt;\n            &lt;li&gt;Fecha de release: pendiente de release&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n\n&lt;/div&gt;\n\n&lt;div th:replace=\"fragments::javascript\"/&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Prueba la p\u00e1gina accediendo a la url http://localhost:8080/about. </p> <p></p> <p>A\u00f1ade un test que automatiza la comprobaci\u00f3n de que la URL <code>/about</code> debe devolver el nombre de la aplicaci\u00f3n.</p> <p>Test:</p> test/java/madstodolist/controller/AcercaDeWebTest.java<pre><code>package madstodolist.controller;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.hamcrest.Matchers.containsString;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class AcercaDeWebTest {\n\n@Autowired\nprivate MockMvc mockMvc;\n\n@Test\npublic void getAboutDevuelveNombreAplicacion() throws Exception {\nthis.mockMvc.perform(get(\"/about\"))\n.andExpect(content().string(containsString(\"ToDoList\")));\n}\n}\n</code></pre> <p>Puedes lanzar el test pulsando en IntelliJ con el bot\u00f3n derecho en el fichero (en el panel del proyecto) y seleccionando la opci\u00f3n Run AcercaDeWebTest.</p> <p>Puedes lanzar tambi\u00e9n todos los tests en el terminal para comprobar que no se ha roto nada.</p> <pre><code>(acerca-de) $ ./mvnw test\n...\n[INFO] \n[INFO] Tests run: 34, Failures: 0, Errors: 0, Skipped: 0\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  21.879 s\n</code></pre> <p>Por \u00faltimo, confirma el commit en la rama y s\u00fabelo a GitHub. En el panel <code>Git</code>:</p> <pre><code>(acerca-de) $ git add .\n(acerca-de) $ git status (comprueba que se han a\u00f1adido los ficheros)\n(acerca-de) $ git commit -m \"A\u00f1adida vista y controller 'about'\"\n(acerca-de) $ git push\n</code></pre>"},{"location":"02-todolist/practica2.html#tercer-commit","title":"Tercer commit","text":"<p>En el tercer commit pondremos un enlace a la p\u00e1gina acerca de en la p\u00e1gina de login de la aplicaci\u00f3n.</p> <p>Realiza el siguiente cambio:</p> formLogin.html<pre><code>                         &lt;a class=\"btn btn-link\" href=\"/registro\"&gt;Ir a registro&lt;/a&gt;\n+                        &lt;a class=\"btn btn-link\" href=\"/about\"&gt;Acerca de&lt;/a&gt;\n                    &lt;/div&gt;\n             &lt;/form&gt;\n</code></pre> <p>Prueba que funciona correctamente, prueba los tests, haz el commit y s\u00fabelo a GitHub:</p> <pre><code>(acerca-de) $ git status\n(acerca-de) $ git add .\n(acerca-de) $ git commit -m \"A\u00f1adido enlace a p\u00e1gina 'about' en p\u00e1gina 'login'\"\n(acerca-de) $ git push\n</code></pre>"},{"location":"02-todolist/practica2.html#pull-request","title":"Pull request","text":"<p>Una vez terminada la implementaci\u00f3n de la feature en la rama, creamos un pull request en GitHub para indicar que estamos listos para mezclar la rama con la feature con la rama principal de desarrollo (main).</p>"},{"location":"02-todolist/practica2.html#creacion-del-pull-request","title":"Creaci\u00f3n del pull request","text":"<p>Accede en GitHub a la rama <code>acerca-de</code> y comprueba que se han subido todos los cambios pulsando <code>Compare</code>.</p> <p></p> <p>Aparecer\u00e1 la siguiente p\u00e1gina, con la informaci\u00f3n de los cambios que introducen todos los commits de la rama:</p> <p></p> <p>Pulsa despu\u00e9s el bot\u00f3n Create pull request para crear el pull request.</p> <p>Escribe como t\u00edtulo del PR: <code>A\u00f1adida p\u00e1gina 'Acerca de'</code> y en el comentario escribe:</p> <pre><code>Closes #1\n</code></pre> <p>Ver\u00e1s que al escribir <code>#1</code> aparecer\u00e1 el nombre del issue. Si escribes s\u00f3lo <code>#</code> ver\u00e1s una lista de los \u00faltimos issues. </p> <p>De esta forma estamos enlazando el PR con el issue. Cuando se cierre el pull request se cerrar\u00e1 autom\u00e1ticamente el issue. Tambi\u00e9n podremos acceder desde el issue al PR enlazado. Lo puedes comprobar en la pantalla del issue, en la columna de la derecha, en el apartado denominado Development, donde aparece el texto Successfully merging a pull request may close this issue y, bajo este texto, el PR enlazado.</p> <p>Pulsa en el bot\u00f3n para crear el pull request. Debe quedar la siguiente pantalla en la que informa del PR reci\u00e9n creado:</p> <p></p> <p>En el proyecto mueve la tarjeta con el issue a la columna <code>In Pull Request</code>. Pinchando en el nombre del issue se abre un panel en el que puedes comprobar toda su informaci\u00f3n, incluyendo el PR enlazado.</p> <p></p> <p>En este momento los compa\u00f1eros del equipo podr\u00edan revisar el pull request y el c\u00f3digo que se va a introducir. En la propia p\u00e1gina del pull request es posible conversar y realizar comentarios que puede aclarar el autor del PR. Y tambi\u00e9n es posible subir nuevos commits con modificaciones o ampliaciones correspondientes a las sugerencias indicadas.</p> <p>Haremos esto en futuras pr\u00e1cticas.</p> <p>Podemos ver que GitHub informa de que no hay conflictos con la rama <code>main</code> y que es posible hacer el merge en GitHub.</p> <p>Antes de pulsar el bot\u00f3n para realizar el merge, lanzamos los tests (estando en la rama) para comprobar que no se ha roto nada y que los tests que se han a\u00f1adido pasan correctamente (en este caso no hemos a\u00f1adido ninguno).</p> <pre><code>(acerca-de) $ ./mvnw test\n...\n[INFO] \n[INFO] Tests run: 34, Failures: 0, Errors: 0, Skipped: 0\n[INFO] \n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  21.879 s\n</code></pre> <p>Veremos en la pr\u00f3xima pr\u00e1ctica c\u00f3mo configurar GitHub para que esta comprobaci\u00f3n se haga de forma autom\u00e1tica en GitHub.</p> <p>Aunque deber\u00edamos tambi\u00e9n comprobar que los tests pasan correctamente despu\u00e9s de mezclar la rama con <code>main</code>, dejamos de hacer esta comprobaci\u00f3n porque a partir de la pr\u00f3xima pr\u00e1ctica lo haremos tambi\u00e9n de forma autom\u00e1tica en GitHub.</p> <p>Pulsa el bot\u00f3n de <code>Merge pull request</code> (con la opci\u00f3n por defecto <code>Create a merge commit</code>) y conf\u00edrmalo. </p> <p></p> <p>Borra la rama en GitHub, pulsando el bot\u00f3n correspondiente.</p> <p></p> <p>Este merge lo has hecho en GitHub. Debes por \u00faltimo integrarlo en tu repositorio local. En el terminal:</p> <pre><code>(acerca-de) $ git checkout main\n(main) $ git pull (bajamos los cambios)\n(main) $ git branch -d acerca-de (borramos la rama)\n(main) $ git remote prune origin (borramos referencias a rama remota)\n(main) $ git log --oneline --graph --all\n    *   9527ae2 (HEAD -&gt; main, origin/main, origin/HEAD) Merge pull request #2 from mads-ua-18/acerca-de\n    |\\  \n    | * 672c28f A\u00f1adido enlace a p\u00e1gina 'about' en p\u00e1gina 'login'\n    | * 3fdfb83 A\u00f1adida ruta, vista y controller 'about'\n    | * a332017 Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0\n    |/  \n    * 6767016 Commit inicial\n</code></pre> <p>Comprobamos tambi\u00e9n la historia de commits en GitHub. Aparecer\u00e1 el commit de merge introducido por el pull request.</p> <p></p> <p>De esta forma hemos cerrado el PR e integrado su c\u00f3digo en la rama principal de desarrollo. El issue ligado al PR se habr\u00e1 cerrado autom\u00e1ticamente y en el tablero de proyecto debe haber cambiado la tarjeta a la columna <code>Done</code>.</p>"},{"location":"02-todolist/practica2.html#actualizamos-tablero-trello","title":"Actualizamos tablero Trello","text":"<p>Actualizamos el tablero Trello moviendo la historia de usuario a la columna Terminadas.</p> <p></p>"},{"location":"02-todolist/practica2.html#release-101","title":"Release 1.0.1","text":"<p>Vamos a ver por \u00faltimo c\u00f3mo crear un release y poner en producci\u00f3n la aplicaci\u00f3n. Lo vamos a hacer ahora como ejemplo, creando el release 1.0.1 y tendr\u00e1s que hacerlo otra vez m\u00e1s al final de la pr\u00e1ctica, creando el release 1.1.0.</p> <p>Para hacer el release haremos un commit directamente sobre la rama <code>main</code> (m\u00e1s adelante explicaremos una forma m\u00e1s elaborada de hacer un release, cuando expliquemos el flujo de trabajo de GitFlow).</p> <p>Crea un commit con la confirmaci\u00f3n del n\u00famero de versi\u00f3n y fecha en los ficheros <code>pom.xml</code> y <code>about.html</code></p> pom.xml<pre><code>     &lt;groupId&gt;es.ua.mads&lt;/groupId&gt;\n     &lt;artifactId&gt;mads-todolist-dgallardo&lt;/artifactId&gt;\n-    &lt;version&gt;1.0.1-SNAPSHOT&lt;/version&gt;\n+    &lt;version&gt;1.0.1&lt;/version&gt;\n</code></pre> about.html<pre><code>    &lt;h1&gt;ToDo List&lt;/h1&gt;\n        &lt;ul&gt;\n         &lt;h1&gt;ToDo List&lt;/h1&gt;\n         &lt;ul&gt;\n             &lt;li&gt;Desarrollada por Domingo Gallardo&lt;/li&gt;\n-            &lt;li&gt;Versi\u00f3n 1.0.1 (en desarrollo)&lt;/li&gt;\n-            &lt;li&gt;Fecha de release: pendiente de release&lt;/li&gt;\n+            &lt;li&gt;Versi\u00f3n 1.0.1&lt;/li&gt;\n+            &lt;li&gt;Fecha de release: 25/9/2023&lt;/li&gt;\n        &lt;/ul&gt;\n}\n</code></pre> <p>A\u00f1adimos el commit y lo subimos a GitHub</p> <pre><code>(main) $ git add .\n(main) $ git commit -m \"Cambio de versi\u00f3n a 1.0.1\"\n(main) $ git push\n</code></pre> <p>Y creamos la versi\u00f3n 1.0.1 en GitHub pulsando en el enlace <code>Create a new release</code> en la p\u00e1gina principal: </p> <p></p> <p>Un release en GitHub se guarda como una una etiqueta Git, junto con informaci\u00f3n asociada. Se suelen indicar las nuevas features a\u00f1adidas en el release mediante enlaces a los pull requests a\u00f1adidos. </p> <p></p> <p>El resultado ser\u00e1:</p> <p></p>"},{"location":"02-todolist/practica2.html#puesta-en-produccion","title":"Puesta en producci\u00f3n","text":"<p>Debes por \u00faltimo poner simular la puesta en producci\u00f3n de la nueva versi\u00f3n.</p> <p>Para crear la imagen Docker primero debes crear el fichero JAR con la aplicaci\u00f3n:</p> <pre><code>$ ./mvnw package\n$ ls -l target/*.jar\ntarget/mads-todolist-domingogallardo-1.0.1.jar\n</code></pre> <p>Y despu\u00e9s construir la imagen docker:</p> <pre><code>$ docker build -t &lt;usuario-docker&gt;/mads-todolist .\n</code></pre> <p>Prueba que la imagen funciona correctamente:</p> <pre><code>$ docker run --rm -p 8080:8080 &lt;usuario-docker&gt;/mads-todolist\n</code></pre> <p>Y sube la m\u00e1quina a Docker Hub (autom\u00e1ticamente se etiquetara como <code>latest</code>). Y etiqueta la m\u00e1quina docker con la versi\u00f3n <code>1.0.1</code> y s\u00fabela tambi\u00e9n.</p> <pre><code>$ docker push &lt;usuario-docker&gt;/mads-todolist \nUsing default tag: latest\n$ docker tag &lt;usuario-docker&gt;/mads-todolist &lt;usuario-docker&gt;/mads-todolist:1.0.1\n$ docker push &lt;usuario-docker&gt;/mads-todolist:1.0.1\n</code></pre> <p>Una vez subida la imagen docker prueba a descargarla en tu m\u00e1quina y comprobar que funciona correctamente.</p> <pre><code>$ docker image ls -a\n$ docker image rm &lt;id-imagen&gt;\n$ docker pull &lt;usuario-docker&gt;/mads-todolist:1.0.1\n$ docker run --rm -p 8080:8080 &lt;usuario-docker&gt;/mads-todolist\n</code></pre>"},{"location":"02-todolist/practica2.html#resto-de-la-practica-version-110","title":"Resto de la pr\u00e1ctica (versi\u00f3n 1.1.0)","text":"<p>El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente.</p> <p>Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 3 opcionales:</p> <ul> <li>(Obligatoria) Barra de men\u00fa</li> <li>(Obligatoria) P\u00e1gina de listado de usuarios</li> <li>(Obligatoria) P\u00e1gina de descripci\u00f3n de un usuario</li> <li>(Opcional) Usuario administrador </li> <li>(Opcional) Protecci\u00f3n listado y descripci\u00f3n de usuario</li> <li>(Opcional) Administrador puede bloquear el acceso a usuarios</li> </ul> <p>Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n:</p> <ul> <li>Capa de presentaci\u00f3n (vista)</li> <li>Nuevo m\u00e9todo en la capa de controller</li> <li>M\u00e9todos necesarios en la capa de servicio y de repository</li> </ul> <p>En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio, as\u00ed como los nuevos controllers y vistas a\u00f1adidos.</p>"},{"location":"02-todolist/practica2.html#barra-de-menu","title":"Barra de men\u00fa","text":"<ul> <li> <p>La aplicaci\u00f3n deber\u00e1 tener una barra de men\u00fa com\u00fan a todas sus   p\u00e1ginas, menos en las p\u00e1ginas de login y registro.</p> </li> <li> <p>La barra de men\u00fa estar\u00e1 situada en la parte superior de la p\u00e1gina y ser\u00e1 un Navbar de Bootstrap.</p> </li> <li> <p>La barra de men\u00fa tendr\u00e1 como m\u00ednimo los siguientes elementos (de izquierda a derecha):</p> </li> <li><code>ToDoList</code>: enlace a la p\u00e1gina acerca de.</li> <li><code>Tareas</code>: enlace a la p\u00e1gina de tareas, con la lista de tareas   pendientes del usuario.</li> <li> <p>Nombre usuario: A la derecha de la p\u00e1gina. Desplegable con las opciones:</p> <ul> <li><code>Cuenta</code>: Futura p\u00e1gina para gestionar la cuenta</li> <li><code>Cerrar sesi\u00f3n &lt;nombre usuario&gt;</code>: cierra la sesi\u00f3n y lleva a la  p\u00e1gina de login.</li> </ul> </li> <li> <p>En la p\u00e1gina acerca de se debe cambiar la barra de men\u00fa   dependiendo de si el usuario est\u00e1 o no logeado. Si est\u00e1 logeado ser\u00e1   la barra com\u00fan con el resto de las p\u00e1ginas. Si el usuario no est\u00e1   logeado, aparecer\u00e1n enlaces a las p\u00e1ginas de login y registro.</p> </li> </ul>"},{"location":"02-todolist/practica2.html#listado-de-usuarios","title":"Listado de usuarios","text":"<ul> <li>Si se introduce la URL <code>/registrados</code> aparecer\u00e1 un listado de los   usuarios registrados (identificador y correo electr\u00f3nico).</li> </ul>"},{"location":"02-todolist/practica2.html#descripcion-de-usuario","title":"Descripci\u00f3n de usuario","text":"<ul> <li>En la lista de usuarios habr\u00e1 un enlace para acceder a su descripci\u00f3n.</li> <li>En la descripci\u00f3n de un usuario aparecer\u00e1n todos sus datos, menos la contrase\u00f1a.</li> <li>La ruta para obtener la descripci\u00f3n de un usuario registrado ser\u00e1 <code>/registrados/:id</code>. </li> </ul>"},{"location":"02-todolist/practica2.html#usuario-administrador-opcional","title":"Usuario administrador (opcional)","text":"<p>Al realizar el registro ser\u00e1 posible darse de alta como usuario administrador.</p> <ul> <li>Para darse de alta como administrador se deber\u00e1 activar un check   box en la p\u00e1gina de registro.</li> <li>S\u00f3lo puede haber un administrador. Si ya existe un administrador, no   debe aparecer el check box en la p\u00e1gina de registro.</li> <li>El usuario administrador acceder\u00e1 directamente a la lista de usuarios.</li> </ul>"},{"location":"02-todolist/practica2.html#proteccion-de-listado-de-usuario-y-descripcion-de-usuario-opcional","title":"Protecci\u00f3n de listado de usuario y descripci\u00f3n de usuario (opcional)","text":"<ul> <li>Proteger las p\u00e1ginas con el listado de usuarios y la descripci\u00f3n de usuario para que s\u00f3lo las pueda consultar el administrador. En el caso en que un usuario no administrador intente acceder a esas p\u00e1ginas, devolver un c\u00f3digo de error HTTP \"No autorizado\" y un mensaje indicando que no se tiene suficiente permiso (de forma similar a como se gestionan los accesos a las p\u00e1ginas de tareas sin estar logeado).</li> </ul>"},{"location":"02-todolist/practica2.html#bloqueo-de-usuarios-por-usuario-administrador-opcional","title":"Bloqueo de usuarios por usuario administrador (opcional)","text":"<ul> <li>A\u00f1adir en el listado de usuarios un bot\u00f3n para que el   administrador pueda bloquear o habilitar el acceso a cada uno de los   usuarios. </li> <li>Si el usuario tiene bloqueado el acceso cuando intente logearse   aparecer\u00e1 un mensaje de error indic\u00e1ndoselo.</li> </ul>"},{"location":"02-todolist/practica2.html#7-documentacion-entrega-y-evaluacion","title":"7. Documentaci\u00f3n, entrega y evaluaci\u00f3n","text":"<p>Deber\u00e1s a\u00f1adir una p\u00e1gina documentaci\u00f3n <code>/doc/practica2.md</code> en la que debes realizar una breve documentaci\u00f3n t\u00e9cnica de entre 500 y 800 palabras (excluyendo el c\u00f3digo fuente).</p> <p>Debes suponer que est\u00e1s trabajando con un equipo de desarrollo y que debes dejar una breve documentaci\u00f3n para que el resto del equipo sepa c\u00f3mo ha evolucionado la implementaci\u00f3n de la aplicaci\u00f3n. No debe ser una manual de usuario, no es una documentaci\u00f3n para el cliente, sino para los compa\u00f1eros desarrolladores del equipo.</p> <p>Por ejemplo, la documentaci\u00f3n podr\u00eda contener:</p> <ul> <li>Listado de nuevas clases y m\u00e9todos implementados.</li> <li>Listado de plantillas thyemeleaf a\u00f1adidas.</li> <li>Explicaci\u00f3n de los tests implementados.</li> <li>Explicaci\u00f3n de c\u00f3digo fuente relevante de las nuevas funcionalidades   implementadas.</li> </ul> <p>Obligatoriamente debes incluir en la documentaci\u00f3n alg\u00fan ejemplo de c\u00f3digo fuente que has a\u00f1adido y que consideres interesante y su explicaci\u00f3n.</p> <p>Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown.</p> <ul> <li>La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada   el martes 17 de octubre.</li> <li>La parte obligatoria punt\u00faa sobre 6 y la opcional sobre 4 puntos.</li> <li>La calificaci\u00f3n de la pr\u00e1ctica se corresponde con 10% de la nota   final de la asignatura.</li> <li>Para realizar la entrega se debe subir a Moodle un ZIP que contenga   todo el proyecto, incluyendo el directorio <code>.git</code> que contiene la   historia Git. Para ello comprime tu directorio local del proyecto   despu\u00e9s de haber hecho un <code>./mvnw clean</code> para eliminar el   directorio <code>target</code> que contiene los binarios compilados. Debes   dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub.</li> </ul> <p>Para la evaluaci\u00f3n se tendr\u00e1 en cuenta:</p> <ul> <li>Desarrollo continuo (los commits deben realizarse a lo largo de   las 4 semanas y no dejar todo para la \u00faltima semana).</li> <li>Correcto desarrollo de la metodolog\u00eda.</li> <li>Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las   caracter\u00edsticas desarrolladas. Correcto funcionamiento.</li> <li>Documentaci\u00f3n.</li> </ul>"},{"location":"03-pruebas-tdd/integration-tdd.html","title":"Pr\u00e1ctica 3: Integraci\u00f3n con GitHub Actions y TDD","text":"<p>En esta pr\u00e1ctica 3 de la asignatura realizaremos dos tareas principales:</p> <ul> <li>Configuraremos un sistema de integraci\u00f3n continua usando las   actions del repositorio de GitHub. En este sistema se lanzar\u00e1n los   tests autom\u00e1ticamente en cada pull request. Despu\u00e9s definiremos   una nueva configuraci\u00f3n del proyecto en la que se lanzar\u00e1n los tests   sobre la base de datos PostgreSQL.</li> <li>A\u00f1adiremos nuevas funcionalidades usando la pr\u00e1ctica XP de TDD   (Test Driven Design).</li> </ul> <p>Importante</p> <p>Lee con cuidado todo el enunciado y dedica especial atenci\u00f3n a los apartados con el t\u00edtulo <code>Pasos a seguir</code>. Ah\u00ed est\u00e1n especificadas las acciones que debes realizar en la pr\u00e1ctica.</p> <p>La duraci\u00f3n de la pr\u00e1ctica es de 3 semanas, la fecha l\u00edmite de entrega es el d\u00eda 7 de noviembre y su puntuaci\u00f3n es de 1 punto en la nota final de la asignatura.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#1-desarrollo-de-la-release-120","title":"1. Desarrollo de la release 1.2.0","text":"<p>En esta pr\u00e1ctica vamos a desarrollar la versi\u00f3n 1.2.0 de la aplicaci\u00f3n <code>ToDoList</code>. A todos los issues y pull requests les debes poner este milestone, indicando que el objetivo es resolverlos y entregarlos en esta release.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir","title":"Pasos a seguir","text":"<ul> <li>Cambia el n\u00famero de versi\u00f3n (en el fichero Acerca De y en el   <code>pom.xml</code>) a <code>1.2.0-SNAPSHOT</code> para indicar que lo que hay en main   es la versi\u00f3n 1.2.0 en progreso. Esta versi\u00f3n la lanzaremos al   final del desarrollo de la pr\u00e1ctica, en su entrega.</li> </ul>"},{"location":"03-pruebas-tdd/integration-tdd.html#2-integracion-continua-con-github-actions","title":"2. Integraci\u00f3n continua con GitHub Actions","text":"<p>GitHub Actions es un servicio de GitHub que permite realizar integraci\u00f3n continua en su propia web, sin necesidad de configurar un servidor propio de integraci\u00f3n continua.</p> <p>Puedes consultar el funcionamiento de GitHub Actions leyendo su documentaci\u00f3n, comenzando por las p\u00e1ginas Quickstart for GitHub Actions, Introduction to GitHub Actions y Building and testing Java with Maven. </p> <p>En la pr\u00e1ctica vamos a comenzar configurando GitHub Actions para que todos los pull requests deban pasar los tests de integraci\u00f3n antes de realizar el merge con <code>main</code>.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#tests-en-los-pull-requests","title":"Tests en los pull requests","text":"<p>Usando GitHub Actions es posible configurar el repositorio de GitHub para que todos los pull requests deban pasar los tests de integraci\u00f3n en el servicio.</p> <p>En la siguiente imagen vemos el aspecto en GitHub de un pull request estando activa la integraci\u00f3n con Actions. Una vez abierto el PR, se lanzan los flujos de trabajo (workflows) definidos en  el directorio <code>.github/workflows</code>. </p> <p>GitHub comprueba si la integraci\u00f3n de main con la rama pasa los tests definidos en el workflow. S\u00f3lo si los tests pasan es posible realizar el merge del PR en main.</p> <p></p>"},{"location":"03-pruebas-tdd/integration-tdd.html#el-fichero-de-configuracion","title":"El fichero de configuraci\u00f3n","text":"<p>Para configurar GitHub Actions basta con a\u00f1adir un fichero de flujo de trabajo en el directorio <code>.github/workflows</code>.</p> <p>El fichero con el flujo de trabajo inicial lo llamaremos <code>developer-tests.yml</code>:</p> .github/workflows/developer-tests.yml<pre><code>name: Tests\n\non: push\n\njobs:\n  # El nombre del job es launch-test\n  launch-tests:\n    runs-on: ubuntu-latest\n    # Todos los pasos se ejecutan en el contenedor openjda:8-jdk-alpine\n    container: openjdk:8-jdk-alpine\n\n    steps:\n      # Hacemos un checkout del c\u00f3digo del repositorio \n      - uses: actions/checkout@v2\n      # Y lanzamos los tests\n      - name: Launch tests with Maven\n        run:  ./mvnw test\n</code></pre> <p>Puntos interesantes a destacar:</p> <ul> <li>El nombre del flujo de trabajo es <code>Tests</code>.</li> <li>El nombre del job es <code>launch-tests</code>.</li> <li>Con la palabra clave <code>on</code> se define el evento que causa que se lance   el flujo de trabajo. Es en cualquier commit subido a GitHub  (push).</li> <li>En <code>jobs</code> se definen los trabajos en paralelo a realizar por el   flujo de trabajo. En nuestro caso s\u00f3lo habr\u00e1 uno.</li> <li>En <code>runs-on</code> se define la m\u00e1quina base sobre la que se van a   ejecutar los siguientes pasos del flujo.</li> <li>En <code>container</code> se especifica el contenedor Docker que se va a usar   para ejecutar los pasos del flujo de trabajo.</li> <li>En <code>uses: actions/checkout@v2</code> se especifica que se obtenga la   versi\u00f3n 2 de la acci\u00f3n llamada <code>actions/checkout</code>. Esta acci\u00f3n se   descarga el repositorio en la m\u00e1quina especificada anteriormente y   lo deja listo para ejecutar los tests o cualquier otra acci\u00f3n.</li> <li>Por \u00faltimo, con el comando <code>run: ./mvnw test</code> se indica que el flujo   de trabajo debe lanzar este comando, que es el que lanza los   tests. </li> <li>Los nombres <code>Tests</code> y <code>launch-tests</code> son nombres arbitrarios que   indicamos y que despu\u00e9s aparecen en la interfaz de Actions y nos   sirven para localizar los distintos pasos.</li> </ul>"},{"location":"03-pruebas-tdd/integration-tdd.html#builds-en-actions","title":"Builds en Actions","text":"<p>En la pesta\u00f1a <code>Actions</code> de GitHub tenemos toda la informaci\u00f3n de los builds. Es posible visualizarla mientras que se est\u00e1 realizando el build o cuando ya ha terminado. All\u00ed podremos ver el detalle de la ejecuci\u00f3n de los tests y consultar la salida de los mismos para comprobar su resultado.</p> <p>En la siguiente imagen se ha capturado el build en ejecuci\u00f3n. El color naranja significa que el proceso est\u00e1 en ejecuci\u00f3n.</p> <p></p>"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_1","title":"Pasos a seguir","text":"<ul> <li> <p>Crea un issue llamado <code>Integraci\u00f3n continua con GitHub   Actions</code>. Abre una rama <code>integracion-continua-actions</code> y s\u00fabela a GitHub. </p> </li> <li> <p>A\u00f1ade el fichero anterior <code>.github/workflows/developer-tests.yml</code>. Haz un   commit, s\u00fabelo a GitHub y abre un pull request con el nombre `Integraci\u00f3n  continua con GitHub Actions\".</p> </li> <li> <p>Comprueba que se pasan los tests y que se marca como correcto el   pull request.</p> </li> <li> <p>Modifica un test para que falle y sube un nuevo commit. Recarga la   p\u00e1gina del pull request y comprueba que el commit aparece como   err\u00f3neo en GitHub cuando el build falla. Pincha en el enlace   details para comprobar la descripci\u00f3n del fallo.</p> </li> <li> <p>Corrige el test que falla, vuelve a subir el commit y comprueba que   el nuevo commit y el PR pasan correctamente.</p> </li> <li> <p>Cierra el pull request, mezcl\u00e1ndolo con <code>main</code>. Se volver\u00e1n a   lanzar los tests en GitHub y el commit aparecer\u00e1 marcado como   correcto. </p> <p>En el listado de commits de la rama <code>main</code> aparecer\u00e1 junto a cada commit el indicador de si en ese commit los tests han pasado correctamente o no. </p> <p></p> </li> <li> <p>Baja los cambios al repositorio local y borra la rama.</p> <pre><code>$ (integracion-continua-actions) git checkout main\n$ (main) git pull\n$ (main) git branch -d integracion-continua-actions\n$ (main) git remote prune origin\n</code></pre> </li> </ul>"},{"location":"03-pruebas-tdd/integration-tdd.html#3-configuracion-de-la-aplicacion-para-usar-una-bd-postgresql","title":"3. Configuraci\u00f3n de la aplicaci\u00f3n para usar una BD PostgreSQL","text":"<p>Hasta ahora hemos trabajado con la aplicaci\u00f3n en una configuraci\u00f3n local con nuestro ordenador de desarrollo trabajando sobre una base de datos H2 en memoria. Pero el objetivo final es poner la aplicaci\u00f3n en producci\u00f3n, en un servidor en Internet y usando una base de datos PostgreSQL en producci\u00f3n. </p> <p>Adem\u00e1s, te habr\u00e1s dado cuenta de que es muy engorroso probar la aplicaci\u00f3n con la base de datos de memoria. Tienes que volver a introducir todos los datos de prueba cada vez que paramos y ponemos en marcha la aplicaci\u00f3n.</p> <p>En esta pr\u00e1ctica vamos a ver c\u00f3mo configurar la aplicaci\u00f3n para poder trabajar con una base datos PostgreSQL, tanto en su ejecuci\u00f3n como en los tests.</p> <p>Para configurar la aplicaci\u00f3n vamos a utilizar los denominados perfiles. Definiremos, adem\u00e1s del perfil base, un perfil adicional para lanzar la aplicaci\u00f3n y los tests usando la base de datos PostgreSQL.</p> <p>La configuraci\u00f3n de tests con base de datos PostgreSQL la utilizaremos para ejecutar los tests de integraci\u00f3n sobre la base de datos PostgreSQL en el proceso de integraci\u00f3n continua de GitHub Actions.</p> <p>Para lanzar un servidor de base de datos PostgreSQL usaremos Docker, de forma que no tendremos que realizar ninguna instalaci\u00f3n en nuestro ordenador.</p> <p></p>"},{"location":"03-pruebas-tdd/integration-tdd.html#ficheros-de-configuracion-de-la-aplicacion","title":"Ficheros de configuraci\u00f3n de la aplicaci\u00f3n","text":"<p>Ya hemos comentado que la configuraci\u00f3n de la aplicaci\u00f3n se define en el fichero <code>application.properties</code>. Ah\u00ed se definen distintas propiedades de la ejecuci\u00f3n de la aplicaci\u00f3n que se pueden modificar (puerto en el que se lanza la aplicaci\u00f3n, base de datos con la que conectarse, etc.). </p> <p>Tenemos dos ficheros <code>application.properties</code>: uno en el directorio <code>src/main/resources</code> que define la configuraci\u00f3n de ejecuci\u00f3n y otro en el directorio <code>src/test/resources</code> que define la configuraci\u00f3n que se carga cuando se lanzan los tests.</p> <p>Spring Boot permite definir ficheros de configuraci\u00f3n adicionales que pueden sobreescribir y a\u00f1adir propiedades a las definidas en el fichero de configuraci\u00f3n por defecto. El nombre de estos ficheros de configuraci\u00f3n debe ser <code>application-xxx.properties</code> donde <code>xxx</code> define el nombre del perfil. En nuestro caso definiremos los ficheros <code>application-postgres.properties</code> (uno en el directorio <code>main</code> y otro en <code>test</code>) para definir las configuraciones de ejecuci\u00f3n y de test con PostgreSQL.</p> <p>Estos ficheros de configuraci\u00f3n adicionales se cargan (cuando se lanza la aplicaci\u00f3n con el perfil espec\u00edfico) despu\u00e9s de cargar la configuraci\u00f3n por defecto definida en <code>application.properties</code>. Recordemos que en este perfil por defecto se define el perfil como perfil activo <code>dev</code>:</p> <pre><code># Activamos el perfil dev\nspring.profiles.active=dev\n</code></pre> <p>Cuando se lance un perfil espec\u00edfico, el perfil activo ya no ser\u00e1 ese, sino el especificado por el perfil espec\u00edfico.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_2","title":"Pasos a seguir","text":"<ol> <li> <p>Crea un nuevo issue llamado <code>A\u00f1adir perfiles y permitir trabajar   con PostgreSQL</code>. Crea una rama nueva (ll\u00e1mala <code>perfiles</code>, por ejemplo) y   abre un pull request. </p> <pre><code>$ (main) git checkout -b perfiles\n$ (perfiles) git push -u origin perfiles\n</code></pre> </li> <li> <p>Copia el siguiente fichero en <code>src/main/resources/application-postgres.properties</code>:</p> <pre><code>spring.datasource.url=jdbc:postgresql://localhost:5432/mads\nspring.datasource.username=mads\nspring.datasource.password=mads\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect\n</code></pre> <p>Este va a ser el perfil que activemos para utilizar la conexi\u00f3n con la BD PostgreSQL.</p> <p>En este fichero de configuraci\u00f3n se define la URL de conexi\u00f3n a la base de datos <code>mads</code>, su usuario (<code>mads</code>) y contrase\u00f1a (<code>mads</code>) y el dialecto que se va a utilizar para trabajar desde JPA con la base de datos (<code>org.hibernate.dialect.PostgreSQL9Dialect</code>). La base de datos PostgreSQL debe estar funcionando en el puerto <code>5432</code> del <code>localhost</code>.</p> </li> <li> <p>Vamos ahora a a\u00f1adir el perfil de test. Copia el siguiente fichero   en <code>src/test/resources/application-postgres.properties</code>:</p> <pre><code>spring.datasource.url=jdbc:postgresql://localhost:5432/mads_test\nspring.datasource.username=mads\nspring.datasource.password=mads\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect\n</code></pre> <p>En este perfil la conexi\u00f3n se hace con una base de datos diferente: <code>mads_test</code>, para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n.</p> <p>Recuerda que en el perfil por defecto <code>resources/application.properties</code> se define el valor de <code>spring.jpa.hibernate.ddl-auto</code> como <code>create</code>. De esta forma la base de datos se inicializa antes de cargar los datos de los tests y de ejecutarlos. Tambi\u00e9n usamos una base de datos distinta (<code>mads_test</code>) para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n.</p> </li> <li> <p>A\u00f1ade la siguiente dependencia en el fichero <code>pom.xml</code> para que se    descargue el driver <code>postgresql:42.2.22</code>. Tambi\u00e9n a\u00f1ade las l\u00edneas    para poder especificar perfiles desde l\u00ednea de comando. La variable    <code>profiles</code> se definir\u00e1 desde l\u00ednea de comando cuando se llame a    Maven:</p> <p>Fichero <code>pom.xml</code>:</p> <pre><code>            &lt;artifactId&gt;h2&lt;/artifactId&gt;\n&lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.postgresql&lt;/groupId&gt;\n&lt;artifactId&gt;postgresql&lt;/artifactId&gt;\n&lt;version&gt;42.2.22&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n</code></pre> </li> <li> <p>Para lanzar la aplicaci\u00f3n necesitar\u00e1s un servidor PostgreSQL en el    puerto 5432 con el usuario <code>mads</code>, la contrase\u00f1a <code>mads</code> y la base    de datos <code>mads</code>. Es muy sencillo descargarlo y ejecutarlo si tienes    instalado Docker. Ejecuta desde el terminal un comando <code>docker run</code> para    poner en marcha la imagen <code>posgres:13</code>:</p> <pre><code>docker run -d -p 5432:5432 --name postgres-develop -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13\n</code></pre> <p>Docker se descarga la imagen <code>postgres:13</code> y lanza el contenedor (una instancia en marcha de una imagen) conectado al puerto 5432 (no debe estar ocupado) y sobre la base de datos <code>mads</code>. Le da como nombre <code>postgres-develop</code>.</p> <p>Puedes ejecutar los siguientes comandos de Docker:</p> <pre><code>$ docker container ls -a (comprueba todos los contenedores en marcha)\n$ docker container stop &lt;nombre o id de contenedor&gt; (para un contenedor)\n$ docker container start &lt;nombre o id de contenedor&gt; (pone en marcha un contenedor)\n$ docker container logs &lt;mombre o id de contenedor&gt; (muestra logs del contenedor)\n$ docker container rm nombre o id de contenedor&gt; (elimina un contenedor)\n</code></pre> </li> <li> <p>Arranca la aplicaci\u00f3n con el siguiente comando:</p> <pre><code>./mvnw spring-boot:run -Dspring-boot.run.profiles=postgres\n</code></pre> <p>Se activar\u00e1 el perfil <code>postgres</code> y se cargar\u00e1n las preferencias de <code>src/main/resource/application.properties</code> y <code>src/main/resource/application-postgres.properties</code>.</p> <p>Cuidado si tienes otro postgres funcionando</p> <p>Si tienes instalado el servicio de postgres para otras asignaturas la aplicaci\u00f3n dar\u00e1 un error al lanzarse, porque se intentar\u00e1 conectar al puerto 5432 y ah\u00ed no estar\u00e1 nuestra base de datos, sino la base de datos de la otra asignatura. Aseg\u00farate de detener el servicio de postgres que tengas instalado en tu ordenador antes de lanzar el comando <code>docker run</code> que pone en marcha nuestra imagen de posgres.</p> <p>Al lanzarse la aplicaci\u00f3n con el perfil activo <code>postgres</code> no se ejecutar\u00e1 el servicio <code>InitDbService</code> que a\u00f1ade datos por defecto en la aplicaci\u00f3n. Ahora ya no tiene sentido trabajar con datos por defecto porque los datos van a ser grabados en la base de datos real.</p> <p>Prueba a introducir datos en la aplicaci\u00f3n y comprueba que se est\u00e1n guardando en la base de datos utilizando por ejemplo el panel <code>Database</code> de IntelliJ. Deber\u00e1s a\u00f1adir una Data Source de tipo PostgreSQL, configurando el usuario y contrase\u00f1a de acceso a <code>mads</code>:</p> <p></p> <p>A\u00f1ade la conexi\u00f3n con la base de datos <code>mads</code> pulsando en el peque\u00f1o recuadro junto al nombre de la fuente de datos:</p> <p></p> <p>Y despu\u00e9s ya podr\u00e1s examinar la base de datos <code>mads</code>, pulsando en la tabla que quieras y seleccionando con el bot\u00f3n derecho Edit Data:</p> <p></p> </li> <li> <p>Cierra la aplicaci\u00f3n y vuelve a abrirla. Comprueba que los datos    que se han creado en la ejecuci\u00f3n anterior siguen estando. </p> <p>Podemos tambi\u00e9n parar el contenedor y volverlo a reiniciar y los datos se conservar\u00e1n. Al parar el contenedor no se eliminan los datos, s\u00f3lo al borrarlo.</p> </li> <li> <p>Tambi\u00e9n podemos arrancar la aplicaci\u00f3n con el perfil de postgres     lanzando directamente el fichero JAR de la siguiente forma:</p> <pre><code>$ ./mvnw package\n$ java -Dspring.profiles.active=postgres -jar target/*.jar \n</code></pre> <p>Para lanzar la aplicaci\u00f3n desde IntelliJ trabajando con el nuevo perfil podemos seleccionar la opci\u00f3n <code>Edit Configurations...</code> del men\u00fa de configuraciones, duplicar la configuraci\u00f3n <code>Application</code>, renombr\u00e1ndola por <code>Application PostgreSQL</code> y a\u00f1adir en el campo <code>Active profiles</code> el nombre del perfil nuevo que acabamos de crear <code>postgres</code>. </p> <p></p> </li> <li> <p>Cierra la aplicaci\u00f3n. Paramos el contenedor con la base de datos de    desarrollo haciendo <code>docker container stop postgres-develop</code>:</p> <pre><code>$ docker container ls -a \nCONTAINER ID        IMAGE        ...    NAME\n520fee61d51e        posgres:13   ...    postgres-develop\n$ docker container stop postgres-develop\n</code></pre> <p>Adem\u00e1s de por l\u00ednea de comando, tambi\u00e9n es posible gestionar los contenedores usando la aplicaci\u00f3n Docker Desktop que se encuentra en la propia instalaci\u00f3n de Docker.</p> </li> <li> <p>Vamos ahora a ver c\u00f3mo lanzar los tests sobre una base de datos    PostgreSQL. Lanzamos ahora otro contenedor con la base de datos de test (<code>mads_test</code>):</p> <pre><code>docker run -d -p 5432:5432 --name postgres-test -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads_test postgres:13\n</code></pre> <p>Y lanzamos los tests usando el perfil <code>postgres</code> con la base de datos PostgreSQL con el siguiente comando:</p> <pre><code>./mvnw -D spring.profiles.active=postgres test\n</code></pre> </li> <li> <p>Podemos lanzar tambi\u00e9n los tests desde IntelliJ editando la     configuraci\u00f3n de lanzamiento de test y a\u00f1adiendo la variable de     entorno <code>spring.profiles.active=postgres</code>. Podr\u00edamos, por ejemplo,     llamar a esta configuraci\u00f3n <code>Tests con PostgreSQL</code>.</p> <p></p> <p>Recargar las dependencias Maven</p> <p>Si la ejecuci\u00f3n de los tests desde IntelliJ produce un error prueba a recargar las dependencias en el panel de Maven.</p> </li> <li> <p>Dado que las configuraciones de test y de ejecuci\u00f3n utilizan     distintas bases de datos, debemos tener en funcionamiento la base     de datos correspondiente a lo que queremos hacer en cada     momento. Esto es muy f\u00e1cil usando los contenedores de Docker. Por     ejemplo, podemos parar el contenedor PostgreSQL con la base de datos     de test y arrancar el contenedor con la base de datos de     desarrollo:</p> <pre><code>$ docker container ls -a \n$ docker container stop postgres-test\n$ docker container start postgres-develop\n</code></pre> </li> <li> <p>Realiza un commit con los cambios, s\u00fabelos a la rama y cierra el     pull request para integrarlo en <code>main</code>:</p> <pre><code>$ (perfiles) git add .\n$ (perfiles) git commit -m \"A\u00f1adidos perfiles para trabajar con PostgreSQL\"\n$ (perfiles) git push\n// Mezclamos el Pull Request en GitHub\n$ (perfiles) git checkout main\n$ (main) git pull\n$ (main) git branch -d perfiles\n$ (main) git remote prune origin\n</code></pre> </li> </ol>"},{"location":"03-pruebas-tdd/integration-tdd.html#4-tests-de-integracion-en-github-actions","title":"4. Tests de integraci\u00f3n en GitHub Actions","text":"<p>Vamos a modificar la configuraci\u00f3n de GitHub Actions para conseguir un sistema de integraci\u00f3n continua que ejecute los tests de integraci\u00f3n usando la base de datos real PostgreSQL.</p> <p>La ejecuci\u00f3n de los tests usando la base de datos de memoria H2 ser\u00e1 responsabilidad del desarrollador y se har\u00e1 en el entorno de trabajo local, tal y como se ha hecho desde la primera pr\u00e1ctica.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#tests-del-desarrollador-vs-tests-de-integracion","title":"Tests del desarrollador vs. tests de integraci\u00f3n","text":"<p>Podemos considerar los tests que usan la base de datos real como tests de integraci\u00f3n y los tests que usan la base de datos en memoria como tests del desarrollador.</p> <p>No usamos el nombre de tests unitarios de forma consciente, para evitar conflictos con la nomenclatura. Cuando hablamos de tests del desarrollador nos referimos a tests que van a ejecutar continuamente los desarrolladores en su equipo local cuando est\u00e1n trabajando con la aplicaci\u00f3n y a\u00f1adiendo funcionalidades. Son tests r\u00e1pidos, que se pueden lanzar desde el propio IDE, y que deben ser ejecutados antes de cada commit.</p> <p>Frente a estos tests, los tests de integraci\u00f3n necesitan una configuraci\u00f3n adicional (poner en marcha la base de datos de test en nuestro caso) y se ejecutan menos frecuentemente.</p> <p>Vamos a actualizar GitHub Actions para que se lancen all\u00ed los tests que usan la base de datos PostgreSQL y nos ahorremos el trabajo de realizarlos en local.</p> <p>Seguiremos lanzando en local los tests que usan la BD de memoria mientras hacemos el desarrollo.</p> <p>Dejaremos tambi\u00e9n en GitHub Actions los tests que usan la BD de memoria. Quiz\u00e1s sean redundantes con los que usan la BD de Postgres, pero su ejecuci\u00f3n no cuesta demasiado y no est\u00e1 de m\u00e1s lanzarlos tambi\u00e9n. Podr\u00edamos prescindir de ellos si en alg\u00fan momento comprobamos que el tiempo de ejecuci\u00f3n de los tests en GitHub se hace muy largo.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#accion-para-lanzar-los-tests-con-la-bd-postgres","title":"Acci\u00f3n para lanzar los tests con la BD postgres","text":"<p>Para lanzar los tests de integraci\u00f3n en GitHub debemos modificar el fichero de configuraci\u00f3n del flujo de trabajo para que lance un contenedor de PostgreSQL y despu\u00e9s se ejecuten los tests sobre ese contenedor.</p> <p>Para tener m\u00e1s flexibilidad en la configuraci\u00f3n de la conexi\u00f3n con PostgreSQL vamos a modificar el perfil de Spring Boot, a\u00f1adiendo unas variables con unos valores por defecto que se pueden modificar definiendo su valor en variables de entorno con el mismo nombre.</p> <p>En concreto, definimos las variables <code>POSTGRES_HOST</code>, <code>POSTGRES_PORT</code>, <code>DB_USER</code> y <code>DB_PASSWD</code>.</p> src/test/resources/application-postgres.properties<pre><code>POSTGRES_HOST=localhost\nPOSTGRES_PORT=5432\nDB_USER=mads\nDB_PASSWD=mads\nspring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads_test\nspring.datasource.username=${DB_USER}\nspring.datasource.password=${DB_PASSWD}\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect\n</code></pre> <p>Ya podemos a\u00f1adir un nuevo fichero de flujo de trabajo. Lo llamamos <code>integration-tests.yml</code></p> .github/workflows/integration-tests.yml<pre><code>name: Integration tests\n\non: push\n\njobs:\n  container-job:\n    runs-on: ubuntu-latest\n    container: openjdk:8-jdk-alpine\n    services:\n      # Etiqueta usada para acceder al contenedor del servicio\n      postgres:\n        # Imagen Docker Hub\n        image: postgres:13\n        # Variables para arrancar PostgreSQL\n        env:\n          POSTGRES_USER: mads\n          POSTGRES_PASSWORD: mads\n          POSTGRES_DB: mads_test\n        # Definimos chequeos para esperar hasta que postgres ya ha comenzado\n        options: &gt;-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      - uses: actions/checkout@v2\n      - name: Launch tests with Maven\n        run:  ./mvnw test -D spring.profiles.active=postgres\n        env:\n          POSTGRES_HOST: postgres\n</code></pre> <ul> <li> <p>Se especifica el servicio <code>postgres</code> que se va a usar en el flujo de   trabajo. Para configurar este servicio se define la imagen docker   (<code>postgres:13</code>) y las variables de entorno que se van a proporcionar   al arrancar, para configurar la base de datos (usuario, contrase\u00f1a y   base de datos). Estamos definiendo un contenedor docker similar al   que hemos usado con los tests cuando hicimos la prueba en local.</p> </li> <li> <p>El nuevo comando de test activa el perfil <code>postgres</code>. Es el mismo   comando que usamos cuando hicimos la prueba en local.</p> </li> <li> <p>En la \u00faltima l\u00ednea se actualiza el par\u00e1metro <code>POSTGRES_HOST</code> para   que la conexi\u00f3n se realice con el host <code>postgres</code> que es el que   nombre que se ha definido en el servicio.</p> </li> </ul>"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_3","title":"Pasos a seguir","text":"<ol> <li> <p>Crea un nuevo issue llamado <code>Tests de integraci\u00f3n en GitHub Actions</code>. Crea la rama <code>integracion-gh-actions</code>.</p> <pre><code>$ git checkout -b integracion-gh-actions\n$ git push -u origin integracion-gh-actions\n</code></pre> </li> <li> <p>Modifica el fichero del perfil postgres de test tal y como se    indica anteriormente, para usar variables de configuraci\u00f3n que    puedan ser definidas mediante variables de entorno.</p> </li> <li> <p>Comprueba que siguen funcionando los tests lanzados sobre la base    de datos usando los valores por defecto de las variables de    entorno.</p> <pre><code>// Nos aseguramos de que la base de datos que est\u00e1 en marcha\n// es la de test\n$ docker container ls\nCONTAINER ID   IMAGE         PORTS                    NAMES\n411d8f2ea46c   postgres:13   0.0.0.0:5432-&gt;5432/tcp   postgres-test\n./mvnw -D spring.profiles.active=postgres test\n</code></pre> </li> <li> <p>Comprueba que podemos modificar los par\u00e1metros definidos en las    variables de entorno. Por ejemplo, si se cambia el nombre del host    de la conexi\u00f3n con la base de datos los tests deben de fallar:</p> <pre><code>$ ./mvnw -D spring.profiles.active=postgres -D POSTGRES_HOST=postgres test\n// Aparecer\u00e1n errores debidos a que no se puede conectar con el\n// host postgres:\norg.postgresql.util.PSQLException: El intento de conexi\u00f3n fall\u00f3.\n...\nCaused by: java.net.UnknownHostException: postgres\n</code></pre> <p>Pulsa CTRL-C para detener la ejecuci\u00f3n de los tests que fallan.</p> </li> <li> <p>Crea un commit, s\u00fabelo a GitHub y crea el Pull Request</p> <pre><code>$ git add .\n$ git commit -m \"A\u00f1adidas variables al perfil de test postgres\"\n$ git push\n</code></pre> </li> <li> <p>A\u00f1ade el fichero <code>.github/workflows/integration-tests.yml</code> con el flujo de    trabajo de la acci\u00f3n de GitHub visto anteriormente. </p> <p>Modifica tambi\u00e9n el nombre de la acci\u00f3n definida en el fichero <code>devoloper-tests.yml</code> para que sea <code>Developer tests</code>.</p> <p>Haz un commit, s\u00fabelo a  GitHub y comprueba que los tests de las dos acciones pasan correctamente y que la acci\u00f3n <code>Integration tests</code> usa la base de datos postgres.</p> <p></p> <p></p> <p></p> <p></p> </li> <li> <p>Una vez comprobado que funcionan los tests de integraci\u00f3n en    GitHub, mezclamos el pull request y lo descargamos a    local. Comprobamos que tambi\u00e9n se lanzan los tests en el commit de    merge en GitHub. </p> </li> <li> <p>Con esto ya tenemos completado un sistema de integraci\u00f3n continua y    GitHub se encargar\u00e1 de ejecutar todos los tests en un modo de    integraci\u00f3n, usando la base de datos PostgreSQL.</p> </li> </ol>"},{"location":"03-pruebas-tdd/integration-tdd.html#5-tdd","title":"5. TDD","text":"<p>En la segunda parte de la pr\u00e1ctica desarrollaremos, usando TDD (Test Driven Design), una nueva feature de la aplicaci\u00f3n: la posibilidad de definir definir equipos a los que puedan pertenecer los usuarios.</p> <p>Descomponemos la feature en las siguientes historias de usuario.</p> <ul> <li>008 Listado de equipos</li> <li>009 Gestionar pertenencia al equipo</li> <li>010 Gesti\u00f3n de equipos (opcional)</li> </ul> <p>008 Listado de equipos: Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos.</p> <p>009 Gestionar pertenencia al equipo: Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos.</p> <p>010 Gesti\u00f3n de equipos (opcional): Como administrador podr\u00e9 cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa.</p> <p>Vamos a hacer de forma guiada la primera historia y dejamos las siguientes para que las hagas por tu cuenta.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#008-listado-de-equipos","title":"008 Listado de equipos","text":"<p>La descripci\u00f3n de la historia de usuario es la siguiente:</p> <pre><code>Listado de equipos\n\nComo usuario podr\u00e9 consultar el listado de\nlos equipos existentes y los participantes en cada uno de ellos para\npoder consultar la estructura de la empresa y los proyectos en marcha\ny comprobar si estoy en los equipos correctos.\n\nDetalles\n\n    * En el men\u00fa aparcer\u00e1 una opci\u00f3n `Equipos` que llevar\u00e1 a un\n    listado con los nombres de todos los equipos existentes.\n    * El listado de equipos estar\u00e1 ordenado por orden alfab\u00e9tico.\n    * Pinchando en el enlace del nombre del equipo nos iremos a una\n    p\u00e1gina con un listado de todos los usuarios que lo componen.\n    * Un usuario podr\u00e1 pertenecer a m\u00e1s de un equipo.\n</code></pre> <p>Vamos a utilizar la t\u00e9cnica de TDD para construir la funcionalidad de dentro a fuera (desde el repository hasta el controller). Comenzaremos con tests que construyan la capa de modelo (clases de entidad y repository) y despu\u00e9s pasaremos a tests que construyan la capa de servicio. </p> <p>Por \u00faltimo, una vez implementados los m\u00e9todos de servicios necesarios, deber\u00e1s implementar (lo haremos sin tests) las vistas y controllers. Las vistas y controllers los probaremos de forma manual, sin tests autom\u00e1ticos.</p> <p>Importante</p> <p>Los controllers no deben implementar ning\u00fan c\u00f3digo adicional, s\u00f3lo llamar al m\u00e9todo de servicio necesario. De esta forma nos aseguramos que todo el c\u00f3digo importante para la funcionalidad est\u00e1 testeado y ha sido creado mediante TDD.</p> <p>Probaremos los tests usando la base de datos de memoria y dejaremos que sea la acci\u00f3n de GitHub la que pruebe los tests con la base de datos Postgres.</p> <p>Recuerda que los pasos seguir la t\u00e9cnica de TDD:</p> <ul> <li>Test: Primero debes escribir el test.</li> <li>Code: Despu\u00e9s debes escribir el c\u00f3digo que hace pasar el test (\u00fanicamente el c\u00f3digo necesario, no puedes escribir c\u00f3digo de m\u00e1s)</li> <li>Refactor: Y, si es necesario, realizar una refactorizaci\u00f3n del c\u00f3digo (los   tests deben seguir pasando despu\u00e9s de la refactorizaci\u00f3n).</li> </ul> <p>Deber\u00e1s hacer un commit por cada fase Test-Code. Si haces refactorizaci\u00f3n deber\u00e1s hacerlo en otro commit adicional.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_4","title":"Pasos a seguir","text":"<ul> <li> <p>Crea la historia de usuario <code>008 Listado de equipos</code> en el tablero Trello.</p> </li> <li> <p>Crea dos issues correspondientes a esta historia:</p> <ul> <li>Servicio y modelo listado de equipos.</li> <li>Vista y controller listado de equipos.</li> </ul> </li> <li> <p>Crea una rama para desarrollar el primer issue (ll\u00e1mala   <code>servicio-equipos</code>, por ejemplo) y p\u00e1salo en el   tablero a <code>In progress</code>.</p> <pre><code>$ git checkout -b servicio-equipos\n$ git push -u origin servicio-equipos\n</code></pre> </li> </ul> <p>Este primer issue lo haremos de forma guiada usando TDD con los tests que enumeraremos a continuaci\u00f3n. El otro issue lo deber\u00e1s implementar por ti mismo. </p>"},{"location":"03-pruebas-tdd/integration-tdd.html#primer-test-clase-equipo","title":"Primer Test - Clase <code>Equipo</code>","text":"<p>El primer test es para crear la entidad <code>Equipo</code>. Por ahora s\u00f3lo creamos la clase Java, sin las anotaciones JPA. Un equipo</p> src/test/java/madstodolist/repository/EquipoTest.java<pre><code>package madstodolist.repository;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.jdbc.Sql;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@SpringBootTest\n@Sql(scripts = \"/clean-db.sql\")\npublic class EquipoTest {\n\n@Test\npublic void crearEquipo() {\nEquipo equipo = new Equipo(\"Proyecto P1\");\nassertThat(equipo.getNombre()).isEqualTo(\"Proyecto P1\");\n}\n}\n</code></pre> <p>Escribe el c\u00f3digo necesario para que pase el test. No debes escribir c\u00f3digo de m\u00e1s, s\u00f3lo el c\u00f3digo m\u00ednimo para que el test pase. </p> <p>Haz un commit que contenga el test y el c\u00f3digo y s\u00fabelo a la rama remota. Pon como descripci\u00f3n del commit el mismo t\u00edtulo de esta secci\u00f3n: Primer test - Clase Equipo.</p> <pre><code>$ git add .\n$ git commit -m \"Primer test - Clase Equipo\"\n$ git push\n</code></pre> <p>Crea el pull request para comprobar que el test pasa correctamente cuando se ejecuta sobre la base de datos Postgres. Ponle como nombre el mismo nombre que el issue que est\u00e1s resolviendo \"Servicio y modelo listado de equipos\". Y liga el pull request con el issue, para que cuando se mezcle el PR se cierre el issue.</p> <p>Importante</p> <p>Debes incluir en el commit tanto el c\u00f3digo del test como el c\u00f3digo que soluciona el test, de forma que el commit aparezca como correcto en GitHub.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#segundo-test-anadir-y-buscar-equipo-en-la-base-de-datos","title":"Segundo test - A\u00f1adir y buscar equipo en la base de datos","text":"<p>Con el segundo test queremos conseguir que funcione JPA con la entidad <code>Equipo</code> y que podamos usar una tabla de equipos en la base de datos, en la que podamos guardar entidades <code>equipo</code>. </p> <p>Para comprobar que la entidad se ha guardado correctamente, comprobaremos se ha actualizando su identificador y que podemos recuperarlo de la base de datos.</p> <p>Lo hacemos a\u00f1adiendo el test <code>grabarYBuscarEquipo</code>. Usaremos la anotaci\u00f3n <code>@Transactional</code> siempre que trabajemos con clases repository. De esa forma nos aseguramos que todo el c\u00f3digo del test se ejecuta en la misma transacci\u00f3n. Cuando escribamos el c\u00f3digo del servicio tambi\u00e9n habr\u00e1 que usar esta anotaci\u00f3n en cada m\u00e9todo, tal y como se hace en las clases de servicio de <code>Tarea</code> y <code>Usuario</code>.</p> <pre><code>// ... Imports ya existentes\n\n// A\u00f1adimos estos imports necesarios\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.transaction.annotation.Transactional;\n\n@SpringBootTest\n@Sql(scripts = \"/clean-db.sql\")\npublic class EquipoTest {\n\n@Autowired\nprivate EquipoRepository equipoRepository;\n\n// ... Test ya existente\n\n@Test\n@Transactional\npublic void grabarYBuscarEquipo() {\n// GIVEN\n// Un equipo nuevo\nEquipo equipo = new Equipo(\"Proyecto P1\");\n\n// Probamos el constructor vac\u00edo, necesario para que funcione JPA/Hibernate\nEquipo equipo = new Equipo();\n\n// Creamos ya el equipo nuevo\nequipo = new Equipo(\"Proyecto P1\");\n\n// WHEN\n// Salvamos el equipo en la base de datos\nequipoRepository.save(equipo);\n\n// THEN\n// Su identificador se ha actualizado y lo podemos\n// usar para recuperarlo de la base de datos\nLong equipoId = equipo.getId();\nassertThat(equipoId).isNotNull();\nEquipo equipoDB = equipoRepository.findById(equipoId).orElse(null);\nassertThat(equipoDB).isNotNull();\nassertThat(equipoDB.getNombre()).isEqualTo(\"Proyecto P1\");\n}\n}\n</code></pre> <p>Actualizamos tambi\u00e9n el fichero <code>clean-db.sql</code> para que se borre la tabla <code>equipos</code> al final de cada test.</p> src/test/resources/clean-db.sql<pre><code>DELETE FROM tareas;\nDELETE FROM equipos;\nDELETE FROM usuarios;\n</code></pre> <p>Escribe el c\u00f3digo necesario para pase el test y haz un commit con el nombre del apartado como descripci\u00f3n. S\u00fabelo a GitHub y comprueba en el pull request que el test pasa correctamente en el entorno de integraci\u00f3n.</p> <pre><code>$ git add .\n$ git commit -m \"Segundo test - A\u00f1adir y buscar equipo en la base de datos\"\n$ git push\n</code></pre>"},{"location":"03-pruebas-tdd/integration-tdd.html#tercer-test-definicion-de-igualdad-entre-equipos","title":"Tercer test - Definici\u00f3n de igualdad entre equipos","text":"<p>Ahora que hemos introducido el <code>id</code> del equipo escribimos un test para comprobar que dos equipos son iguales. Debes escribir el c\u00f3digo de los m\u00e9todos <code>equals</code> y <code>hashCode</code> (necesario este \u00faltimo para que funcione correctamente la comprobaci\u00f3n de igualdades en las colecciones).</p> <p>Hacemos los tests para que el <code>equals</code> funcione de la siguiente forma:</p> <p>Si alguno de los dos equipos no tiene <code>id</code> (es <code>null</code>), entonces se deben comparar sus nombres. Ahora bien, si los dos equipos tienen <code>id</code>, entonces se deben comparar esos <code>id</code>\".</p> <p>Puedes guiarte por la implementaci\u00f3n de <code>equals</code> y <code>hashCode</code> en <code>Usuario</code>.</p> <pre><code>    @Test\npublic void comprobarIgualdadEquipos() {\n// GIVEN\n// Creamos tres equipos sin id, s\u00f3lo con el nombre\nEquipo equipo1 = new Equipo(\"Proyecto P1\");\nEquipo equipo2 = new Equipo(\"Proyecto P2\");\nEquipo equipo3 = new Equipo(\"Proyecto P2\");\n\n// THEN\n// Comprobamos igualdad basada en el atributo nombre y que el\n// hashCode es el mismo para dos equipos con igual nombre\nassertThat(equipo1).isNotEqualTo(equipo2);\nassertThat(equipo2).isEqualTo(equipo3);\nassertThat(equipo2.hashCode()).isEqualTo(equipo3.hashCode());\n\n// WHEN\n// A\u00f1adimos identificadores y comprobamos igualdad por identificadores\nequipo1.setId(1L);\nequipo2.setId(1L);\nequipo3.setId(2L);\n\n// THEN\n// Comprobamos igualdad basada en el atributo nombre\nassertThat(equipo1).isEqualTo(equipo2);\nassertThat(equipo2).isNotEqualTo(equipo3);\n}\n</code></pre> <p>Escribe el c\u00f3digo necesario para que pase el test y haz un commit.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#cuarto-test-relacion-muchos-a-muchos-entre-equipos-y-usuarios","title":"Cuarto test - Relaci\u00f3n muchos-a-muchos entre equipos y usuarios","text":"<p>Vamos ahora a dise\u00f1ar un test que introduzca la relaci\u00f3n entre equipos y usuarios. Debe ser una relaci\u00f3n muchos-a-muchos: un equipo contiene muchos usuarios y un usuario puede pertenecer a 0, 1 o muchos equipos.</p> <p>En el test hacemos varias cosas: creamos un equipo y un usuario, a\u00f1adimos el usuario al equipo y comprobamos que las relaciones se han actualizado en la base de datos.</p> <p>De la misma forma que en un test anterior, a\u00f1adimos la anotaci\u00f3n <code>@Transactional</code> para que todas las llamadas a objetos repository se hagan en la misma transacci\u00f3n y con la misma conexi\u00f3n a la base de datos.</p> <pre><code>    @Autowired\nprivate UsuarioRepository usuarioRepository;\n\n@Test\n@Transactional\npublic void comprobarRelacionBaseDatos() {\n// GIVEN\n// Un equipo y un usuario en la BD\nEquipo equipo = new Equipo(\"Proyecto 1\");\nequipoRepository.save(equipo);\n\nUsuario usuario = new Usuario(\"user@ua\");\nusuarioRepository.save(usuario);\n\n// WHEN\n// A\u00f1adimos el usuario al equipo\n\nequipo.addUsuario(usuario);\n\n// THEN\n// La relaci\u00f3n entre usuario y equipo pqueda actualizada en BD\n\nEquipo equipoBD = equipoRepository.findById(equipo.getId()).orElse(null);\nUsuario usuarioBD = usuarioRepository.findById(usuario.getId()).orElse(null);\n\nassertThat(equipo.getUsuarios()).hasSize(1);\nassertThat(equipo.getUsuarios()).contains(usuario);\nassertThat(usuario.getEquipos()).hasSize(1);\nassertThat(usuario.getEquipos()).contains(equipo);\n}\n</code></pre> <p>Para que este test funcione hay que crear la relaci\u00f3n muchos-a-muchos entre equipos y usuarios.  Es necesario definir la anotaci\u00f3n <code>@ManyToMany</code> para indicar a JPA c\u00f3mo construir las tablas en la base de datos. Vamos a crear esta relaci\u00f3n como <code>LAZY</code>, porque si fuera <code>EAGER</code> la recuperaci\u00f3n de equipos de la base de datos ser\u00eda muy costosa, traer\u00eda a memoria todos sus usuarios (con sus tareas incluidas).</p> <p>En <code>Equipo.java</code> definimos la tabla <code>equipo_usuario</code> en la que se va a guardar la relaci\u00f3n, e indicamos el papel de cada una de sus dos columnas.</p> <p>Tambi\u00e9n creamos el getter para obtener los usuarios.</p> <p>Y por \u00faltimo a\u00f1adimos el m\u00e9todo que actualiza ambos lados de la relaci\u00f3n. El m\u00e9todo debe a\u00f1adir el usuario a la colecci\u00f3n de usuarios del equipo y a\u00f1adir el equipo a la colecci\u00f3n de equipos del usuario.</p> src/main/java/madstodolist/model/Equipo.java<pre><code>// ... resto de imports\n\nimport java.util.Set;\nimport java.util.HashSet;\n\n@Entity\n@Table(name = \"equipos\")\npublic class Equipo implements Serializable {\n\n// ...\n\nprivate String nombre;\n\n// Declaramos el tipo de recuperaci\u00f3n como LAZY.\n// No har\u00eda falta porque es el tipo por defecto en una\n// relaci\u00f3n a muchos.\n// Al recuperar un equipo NO SE RECUPERA AUTOM\u00c1TICAMENTE\n// la lista de usuarios. S\u00f3lo se recupera cuando se accede al\n// atributo 'usuarios'; entonces se genera una query en la\n// BD que devuelve todos los usuarios del equipo y rellena el\n// atributo.\n\n@ManyToMany(fetch = FetchType.LAZY)\n@JoinTable(name = \"equipo_usuario\",\njoinColumns = { @JoinColumn(name = \"fk_equipo\") },\ninverseJoinColumns = {@JoinColumn(name = \"fk_usuario\")})\nSet&lt;Usuario&gt; usuarios = new HashSet&lt;&gt;();\n\n// ...\n\npublic Set&lt;Usuario&gt; getUsuarios() {\nreturn usuarios;\n}\n\npublic void addUsuario(Usuario usuario) {\n// Hay que actualiar ambas colecciones, porque\n// JPA/Hibernate no lo hace autom\u00e1ticamente\nthis.getUsuarios().add(usuario);\nusuario.getEquipos().add(this);\n}\n\n// ...\n}\n</code></pre> <p>En el fichero <code>Usuario.java</code> definimos la parte inversa de la relaci\u00f3n. El <code>mappedBy</code> indica que la especificaci\u00f3n de la tabla join est\u00e1 en el otro lado de la relaci\u00f3n. Esta relaci\u00f3n tambi\u00e9n es lazy por defecto, al recuperar un usuario no se va a traer a memoria la informaci\u00f3n de sus equipos, hay que pedirla expresamente accediendo a la colecci\u00f3n.</p> src/main/java/madstodolist/model/Usuario.java<pre><code>@Entity\n@Table(name = \"usuarios\")\npublic class Usuario implements Serializable {\n\n// ...\n\n@OneToMany(mappedBy = \"usuario\")\nSet&lt;Tarea&gt; tareas = new HashSet&lt;&gt;();\n\n@ManyToMany(mappedBy = \"usuarios\")\nSet&lt;Equipo&gt; equipos = new HashSet&lt;&gt;();\n\n// ...\n\n// Getters de las relaciones\n\npublic Set&lt;Tarea&gt; getTareas() {\nreturn tareas;\n}\n\npublic Set&lt;Equipo&gt; getEquipos() {\nreturn equipos;\n}\n\n// ...\n\n}\n</code></pre> <p>Tambi\u00e9n actualizamos el fichero de limpieza de datos al final de cada test, para a\u00f1adir la nueva tabla <code>equipo_usuario</code> que mantiene la relaci\u00f3n entre equipos y usuarios.</p> src/test/resources/clean-db.sql<pre><code>DELETE FROM equipo_usuario;\nDELETE FROM tareas;\nDELETE FROM equipos;\nDELETE FROM usuarios;\n</code></pre> <p>Comprueba el test, haz un commit en la rama y s\u00fabelo a GitHub.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#quinto-test-listado-de-equipos","title":"Quinto test - Listado de equipos","text":"<p>Vamos ahora a definir un test para obtener una lista de equipos en el repository. Queremos que el tipo devuelto por el repository sea List.</p> <pre><code>    @Test\n@Transactional\npublic void comprobarFindAll() {\n// GIVEN\n// Dos equipos en la base de datos\nequipoRepository.save(new Equipo(\"Proyecto 2\"));\nequipoRepository.save(new Equipo(\"Proyecto 3\"));\n\n// WHEN\nList&lt;Equipo&gt; equipos = equipoRepository.findAll();\n\n// THEN\nassertThat(equipos).hasSize(2);\n}\n</code></pre> <p>La soluci\u00f3n consiste en a\u00f1adir el m\u00e9todo <code>findAll</code> en la interfaz <code>EquipoRepository</code>, definiendo el tipo devuelto como List. Spring Boot se encarga de construir autom\u00e1ticamente la implementaci\u00f3n de este m\u00e9todo.</p> EquipoRepository.java<pre><code>import java.util.List;\n\npublic interface EquipoRepository extends CrudRepository&lt;Equipo, Long&gt; {\npublic List&lt;Equipo&gt; findAll();\n}\n</code></pre>"},{"location":"03-pruebas-tdd/integration-tdd.html#sexto-test-metodo-de-servicio-para-crear-y-recuperar-equipo","title":"Sexto test - M\u00e9todo de servicio para crear y recuperar equipo","text":"<p>\u00a1Y por fin llegamos a la capa de servicio!</p> <p>Creamos el fichero <code>EquipoServiceTest.java</code> con la llamada al m\u00e9todo de servicio para crear un equipo nuevo y a otro m\u00e9todo de servicio para recuperar un equipo por su identificador.</p> <p>Lo hacemos todo en el m\u00e9todo <code>crearRecuperarTest</code>. En el test no hay que a\u00f1adir la anotaci\u00f3n <code>@Transactional</code> porque queremos probar el uso de los m\u00e9todos de servicio en un contexto similar al que usaremos cuando los llamemos desde el controller. Cuando llamemos desde el controller a los m\u00e9todos de servicio no se usar\u00e1 la anotaci\u00f3n <code>@Transactional</code> para evitar en el c\u00f3digo del controller se pueda acceder a los objetos repository y modificar directamente la base de datos.</p> <p>Tambi\u00e9n debemos usar, tal y como hemos hecho en el resto de la aplicaci\u00f3n, el patr\u00f3n Data Transfer Object y ambos m\u00e9todos de servicio deben devolver un <code>EquipoData</code>.</p> src/test/java/madstodolist/service/EquipoServiceTest.java<pre><code>package madstodolist.service;\n\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.jdbc.Sql;\nimport madstodolist.dto.EquipoData;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n@SpringBootTest\n@Sql(scripts = \"/clean-db.sql\")\npublic class EquipoServiceTest {\n\n@Autowired\nEquipoService equipoService;\n\n@Test\npublic void crearRecuperarEquipo() {\nEquipoData equipo = equipoService.crearEquipo(\"Proyecto 1\");\nassertThat(equipo.getId()).isNotNull();\n\nEquipoData equipoBd = equipoService.recuperarEquipo(equipo.getId());\nassertThat(equipoBd).isNotNull();\nassertThat(equipoBd.getNombre()).isEqualTo(\"Proyecto 1\");\n}\n}\n</code></pre> <p>Para que funcione correctamente el test tenemos que crear la clase <code>EquipoData</code> que define el transfer object. Por el momento, la definimos solo con los atributos <code>id</code> y <code>nombre</code>.</p> src/main/java/madstodolist/dto/EquipoData.java<pre><code>package madstodolist.dto;\n\nimport java.util.Objects;\n\npublic class EquipoData {\nprivate Long id;\nprivate String nombre;\n\npublic void setId(Long id) {\nthis.id = id;\n}\n\npublic Long getId() {\nreturn id;\n}\n\npublic void setNombre(String nombre) {\nthis.nombre = nombre;\n}\n\npublic String getNombre() {\nreturn nombre;\n}\n\n@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\nEquipoData equipo = (EquipoData) o;\nif (id != null &amp;&amp; equipo.id != null)\n// Si tenemos los ID, comparamos por ID\nreturn Objects.equals(id, equipo.id);\n// si no comparamos por campos obligatorios\nreturn nombre.equals(equipo.nombre);\n}\n\n@Override\npublic int hashCode() {\n// Generamos un hash basado en los campos obligatorios\nreturn Objects.hash(nombre);\n}\n}\n</code></pre> <p>Y ahora ya podemos crear la clase <code>EquipoService</code> con los m\u00e9todos <code>crearEquipo</code> y <code>recuperarEquipo</code>. </p> <p>Completa el c\u00f3digo en los lugares indicados.</p> src/main/java/madstodolist/service/EquipoService.java<pre><code>package madstodolist.service;\n\nimport madstodolist.dto.EquipoData;\nimport madstodolist.model.Equipo;\nimport madstodolist.repository.EquipoRepository;\nimport org.modelmapper.ModelMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\npublic class EquipoService {\n\n@Autowired\nEquipoRepository equipoRepository;\n\n@Autowired\nprivate ModelMapper modelMapper;\n\n@Transactional\npublic EquipoData crearEquipo(String nombre) {\n// Completar\n}\n\n@Transactional(readOnly = true)\npublic EquipoData recuperarEquipo(Long id) {\n// Completar\n}\n}\n</code></pre> <p>Tal y como hemos comentado, la anotaci\u00f3n <code>@Transactional</code> se usa en los m\u00e9todos de servicio en los que se trabaja con objetos repository para asegurarnos de que todo el c\u00f3digo del m\u00e9todo se ejecuta en la misma transacci\u00f3n y usando la misma conexi\u00f3n a la base de datos.</p> <p>En aquellos m\u00e9todos en los que no se modifica la base de datos (s\u00f3lo se realiza una consulta) es recomendable utilizar la anotaci\u00f3n con el atributo <code>readOnly = true</code> para hacer m\u00e1s eficiente la conexi\u00f3n con la base de datos.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#septimo-test-metodo-de-servicio-para-el-listado-de-equipos","title":"S\u00e9ptimo test - M\u00e9todo de servicio para el listado de equipos","text":"<p>A\u00f1adimos el test que obliga a crear el m\u00e9todo de servicio que recupera la lista de equipos existentes, ordenada por orden alfab\u00e9tico del nombre del equipo:</p> src/test/java/madstodolist/service/EquipoServiceTest.java<pre><code>// ... imports\n\nimport java.util.List;\n\n// ... public class EquipoServiceTest\n\n@Test\npublic void listadoEquiposOrdenAlfabetico() {\n// GIVEN\n// Dos equipos en la base de datos\nequipoService.crearEquipo(\"Proyecto BBB\");\nequipoService.crearEquipo(\"Proyecto AAA\");\n\n// WHEN\n// Recuperamos los equipos\nList&lt;EquipoData&gt; equipos = equipoService.findAllOrdenadoPorNombre();\n\n// THEN\n// Los equipos est\u00e1n ordenados por nombre\nassertThat(equipos).hasSize(2);\nassertThat(equipos.get(0).getNombre()).isEqualTo(\"Proyecto AAA\");\nassertThat(equipos.get(1).getNombre()).isEqualTo(\"Proyecto BBB\");        }\n}\n</code></pre> <p>Escribe en el servicio el c\u00f3digo estr\u00edctamente necesario para que pase el test. Haz un commit en la rama y s\u00fabelo a GitHub.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#octavo-test-metodos-de-servicio-para-anadir-y-recuperar-usuarios-a-un-equipo","title":"Octavo test - M\u00e9todos de servicio para a\u00f1adir y recuperar usuarios a un equipo","text":"<p>En este test vamos a construir dos m\u00e9todos de servicio con un \u00fanico test. Aunque pueda parecer de que estamos incumpliendo la norma de TDD de avanzar con peque\u00f1os pasos, ambos m\u00e9todos est\u00e1n muy relacionados y ser\u00eda complicado construirlos por separado.</p> <p>El test es el siguiente:</p> src/test/java/madstodolist/Service/EquipoServiceTest.java<pre><code>    @Test\npublic void a\u00f1adirUsuarioAEquipo() {\n// GIVEN\n// Un usuario y un equipo en la base de datos\nUsuarioData usuario = new UsuarioData();\nusuario.setEmail(\"user@ua\");\nusuario.setPassword(\"123\");\nusuario = usuarioService.registrar(usuario);\nEquipoData equipo = equipoService.crearEquipo(\"Proyecto 1\");\n\n// WHEN\n// A\u00f1adimos el usuario al equipo\nequipoService.a\u00f1adirUsuarioAEquipo(equipo.getId(), usuario.getId());\n\n// THEN\n// El usuario pertenece al equipo\nList&lt;UsuarioData&gt; usuarios = equipoService.usuariosEquipo(equipo.getId());\nassertThat(usuarios).hasSize(1);\nassertThat(usuarios.get(0).getEmail()).isEqualTo(\"user@ua\");\n}\n</code></pre> <p>El c\u00f3digo de la soluci\u00f3n es muy sencillo. Para a\u00f1adir un usuario a un equipo usamos el m\u00e9todo implementado anteriormente <code>addUsuario</code> de la entidad <code>Equipo</code>. Y para recuperar todos los usuarios de un equipo usamos la colecci\u00f3n de usuarios y la recorremos para obtener los DTOs, de una forma similar a c\u00f3mo lo hicimos para recuperar la lista de tareas de un usuario:</p> src/main/java/madstodolist/service/EquipoService.java<pre><code>    @Transactional\npublic void a\u00f1adirUsuarioAEquipo(Long id, Long id1) {\nEquipo equipo = equipoRepository.findById(id).orElse(null);\nUsuario usuario = usuarioRepository.findById(id1).orElse(null);\nequipo.addUsuario(usuario);\n}\n\n@Transactional(readOnly = true)\npublic List&lt;UsuarioData&gt; usuariosEquipo(Long id) {\nEquipo equipo = equipoRepository.findById(id).orElse(null);\n// Hacemos uso de Java Stream API para mapear la lista de entidades a DTOs.\nreturn equipo.getUsuarios().stream()\n.map(usuario -&gt; modelMapper.map(usuario, UsuarioData.class))\n.collect(Collectors.toList());\n}\n</code></pre> <p>Hacemos un commit en la rama y lo subimos a GitHub.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#noveno-test-recuperacion-de-equipos-de-un-usuario","title":"Noveno test - Recuperaci\u00f3n de equipos de un usuario","text":"<p>Aunque no es estrictamente necesario para implementar la funcionalidad de listar los equipos, ya que estamos trabajando con la relaci\u00f3n entre equipos y usuarios vamos a definir un m\u00e9todo de servicio que obtenga el otro lado de la relaci\u00f3n. Dado un usuario, queremos obtener todos sus equipos.</p> <p>Lo hacemos a\u00f1adiendo tambi\u00e9n el en servicio <code>EquipoService</code> el m\u00e9todo <code>equiposUsuario</code> con el siguiente test:</p> src/main/java/madstodolist/service/EquipoService.java<pre><code>    @Test\npublic void recuperarEquiposDeUsuario() {\n// GIVEN\n// Un usuario y dos equipos en la base de datos\nUsuarioData usuario = new UsuarioData();\nusuario.setEmail(\"user@ua\");\nusuario.setPassword(\"123\");\nusuario = usuarioService.registrar(usuario);\nEquipoData equipo1 = equipoService.crearEquipo(\"Proyecto 1\");\nEquipoData equipo2 = equipoService.crearEquipo(\"Proyecto 2\");\nequipoService.a\u00f1adirUsuarioAEquipo(equipo1.getId(), usuario.getId());\nequipoService.a\u00f1adirUsuarioAEquipo(equipo2.getId(), usuario.getId());\n\n// WHEN\n// Recuperamos los equipos del usuario\nList&lt;EquipoData&gt; equipos = equipoService.equiposUsuario(usuario.getId());\n\n// THEN\n// El usuario pertenece a los dos equipos\nassertThat(equipos).hasSize(2);\nassertThat(equipos.get(0).getNombre()).isEqualTo(\"Proyecto 1\");\nassertThat(equipos.get(1).getNombre()).isEqualTo(\"Proyecto 2\");\n}\n</code></pre> <p>Escribe en el servicio el c\u00f3digo estr\u00edctamente necesario para que pase el test. Haz un commit en la rama y s\u00fabelo a GitHub.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#decimo-test-excepciones","title":"D\u00e9cimo test - Excepciones","text":"<p>Por \u00faltimo, a\u00f1adimos un test y el c\u00f3digo necesario para obligar a que se lancen excepciones en los m\u00e9todos de servicio cuando no existe el equipo o el usuario.</p> <p>El test es el siguiente:</p> src/main/java/madstodolist/service/EquipoService.java<pre><code>    @Test\npublic void comprobarExcepciones() {\n// Comprobamos las excepciones lanzadas por los m\u00e9todos\n// recuperarEquipo, a\u00f1adirUsuarioAEquipo, usuariosEquipo y equiposUsuario\nassertThatThrownBy(() -&gt; equipoService.recuperarEquipo(1L))\n.isInstanceOf(EquipoServiceException.class);\nassertThatThrownBy(() -&gt; equipoService.a\u00f1adirUsuarioAEquipo(1L, 1L))\n.isInstanceOf(EquipoServiceException.class);\nassertThatThrownBy(() -&gt; equipoService.usuariosEquipo(1L))\n.isInstanceOf(EquipoServiceException.class);\nassertThatThrownBy(() -&gt; equipoService.equiposUsuario(1L))\n.isInstanceOf(EquipoServiceException.class);\n\n// Creamos un equipo pero no un usuario y comprobamos que tambi\u00e9n se lanza una excepci\u00f3n\nEquipoData equipo = equipoService.crearEquipo(\"Proyecto 1\");\nassertThatThrownBy(() -&gt; equipoService.a\u00f1adirUsuarioAEquipo(equipo.getId(), 1L))\n.isInstanceOf(EquipoServiceException.class);\n}\n</code></pre> <p>Escribe en el servicio el c\u00f3digo necesario, haz un commit en la rama y s\u00fabelo a GitHub.</p>"},{"location":"03-pruebas-tdd/integration-tdd.html#cierre-del-issue","title":"Cierre del issue","text":"<p>Cuando hayas terminado todos los ciclos de TDD anteriores habr\u00e1s terminado el issue y testeado e implementado los m\u00e9todos necesarios para la clase de servicio que gestiona el listado de equipos y usuarios de esos equipos.</p> <ul> <li>Comprueba que el pull request est\u00e9 listo para mezclar (GitHub Actions pasa correctamente todos los tests) y realiza la mezcla para int\u00e9gralo en <code>main</code> en GitHub. Comprueba que el issue asociado se ha cerrado y baja los cambios al repositorio local.</li> </ul>"},{"location":"03-pruebas-tdd/integration-tdd.html#vista-y-controller-listado-de-equipos","title":"Vista y controller listado de equipos","text":"<ul> <li> <p>Abre un nuevo issue para implementar el controller y las vistas que permitan listar los equipos y consultar sus miembros (por ejemplo, pulsando en un enlace en el nombre del equipo o con un bot\u00f3n en el listado).</p> </li> <li> <p>Realiza el desarrollo del issue usando varios commits en los que   a\u00f1adas las funcionalidades poco a poco. No hace falta que hagas TDD,   pero a\u00f1ade pruebas para cada m\u00e9todo del controller.</p> </li> </ul>"},{"location":"03-pruebas-tdd/integration-tdd.html#resto-de-historias-de-usuario","title":"Resto de historias de usuario","text":"<p>Debes implementar la historia de usuario de la misma forma que hemos implementado la anterior.</p> <ul> <li>009 Gestionar pertenencia al equipo: Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos.</li> </ul> <p>El m\u00e9todo de servicio que tendr\u00e1s que a\u00f1adir en la fase de TDD es el de eliminar un usuario de un equipo.</p> <p>Los m\u00e9todos de servicio para crear equipos o para a\u00f1adir un usuario a un equipo ya han sido implementados en la historia anterior, por lo que puedes usar esta historia para mejorarlos. Por ejemplo, a\u00f1adir nuevas excepciones si la cadena del nombre es vac\u00eda o si el usuario que se est\u00e1 a\u00f1adiendo ya pertenece al equipo.</p> <p>Importante detalle de implementaci\u00f3n</p> <p>En una relaci\u00f3n muchos-a-muchos como la que existe entre <code>Usuario</code> y <code>Equipo</code> cuando se a\u00f1ade un usuario a un equipo hay que actualizar ambos lados de la relaci\u00f3n, porque JPA/Hibernate no lo hace autom\u00e1ticamente. En el c\u00f3digo de la historia anterior al a\u00f1adir el usuario a la colecci\u00f3n de  usuarios del equipo y tambi\u00e9n a\u00f1ad\u00edamos el equipo a la colecci\u00f3n de equipos del usuario. Lo mismo habr\u00eda que hacer cuando se  elimina un usuario de un equipo.</p> <ul> <li>010 Gesti\u00f3n de equipos (opcional): Como administrador puedo cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa.</li> </ul>"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_5","title":"Pasos a seguir","text":"<ul> <li>Implementa cada historia de usuario usando el mismo proceso que   hemos utilizado para la historia 008. Deber\u00e1s pensar qu\u00e9 servicios   son necesarios para la historia y c\u00f3mo implementarlos haciendo TDD.</li> </ul> <p>Para cada historia haz dos issues: uno con TDD para implementar la   capa de servicio y repository y otro sin TDD para la capa de   controller y vista.</p> <p>Cuando est\u00e9s haciendo TDD completa el c\u00f3digo para pasar los tests,   uno a uno, haciendo un commit despu\u00e9s de cada fase test-code y   otro commit en la fase refactor (en el caso en que tengas que   hacer refactorizaci\u00f3n). </p> <p>Los incrementos de c\u00f3digo introducidos por los tests deben ser   peque\u00f1os. Debe haber entre 15 y 25 l\u00edneas de c\u00f3digo a\u00f1adidas en   las fases de codificaci\u00f3n (sin contar el c\u00f3digo de los tests). No   tomes este n\u00famero de forma demasiado estricta; si en alg\u00fan ciclo hay   que a\u00f1adir 35 l\u00edneas no pasa nada. Tampoco si haces menos   de 15. Pero estar\u00eda mal tener que a\u00f1adir 70 l\u00edneas para resolver un   test.</p> <ul> <li>Cuando termines las historias de usuario (ve movi\u00e9ndolas tambi\u00e9n en   el tablero de Trello) haz el release 1.2.0 con la entrega final de   la pr\u00e1ctica.</li> </ul>"},{"location":"03-pruebas-tdd/integration-tdd.html#6-documentacion-entrega-y-evaluacion","title":"6. Documentaci\u00f3n, entrega y evaluaci\u00f3n","text":"<p>Deber\u00e1s a\u00f1adir una p\u00e1gina de documentaci\u00f3n <code>/doc/practica3.md</code> en la que, al igual que en la pr\u00e1ctica anterior, debes realizar una breve documentaci\u00f3n t\u00e9cnica de entre 500 y 800 palabras sobre lo implementado en las historias de usuario 009 y 010.</p> <p>En la documentaci\u00f3n debes incluir tambi\u00e9n una captura de pantalla en la que se muestren las tablas de la base de datos de desarrollo PostgreSQL en la versi\u00f3n final de la aplicaci\u00f3n. Puedes mostrar, por ejempo, una pantalla con el panel <code>Database</code> de IntelliJ o la herramienta que hayas utilizado.</p> <p>Por ejemplo, puedes incluir en la documentaci\u00f3n lo siguiente. Los puntos 2 en adelante son sobre las historias de usuario 009 y 010.</p> <ol> <li>Pantalla de la base de datos PostgreSQL.</li> <li>Rutas (endpoints) definidas para las acciones y, para cada endpoint o grupo de endpoints,    explicaci\u00f3n sobre:<ol> <li>Clases y m\u00e9todos</li> <li>Plantillas thymeleaf</li> <li>Tests</li> </ol> </li> <li>Explicaci\u00f3n de algunos fragmentos de c\u00f3digo fuente que consideres    interesante en las nuevas funcionalidades implementadas.</li> </ol> <p>Intenta que el documento tenga un formato limpio y se pueda leer f\u00e1cilmente. Para eso utiliza los bloques de c\u00f3digo de Markdown. Puedes mirar como ejemplo el c\u00f3digo Markdown de estas pr\u00e1cticas.</p> <p>Por ejemplo, el c\u00f3digo Markdown de la introducci\u00f3n a Spring Boot se puede ver pulsando el bot\u00f3n <code>Raw</code>. Ver\u00e1s el texto Markdown.</p> <ul> <li>La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y la fecha l\u00edmite de   entrega es el martes 7 de noviembre (actualizado: martes 14 de noviembre).</li> <li>La parte obligatoria punt\u00faa sobre 8 y la opcional sobre 2 puntos.</li> <li>La calificaci\u00f3n de la pr\u00e1ctica se corresponde con 10% de la nota   final de la asignatura.</li> <li>Para realizar la entrega se debe subir a Moodle un ZIP que contenga   todo el proyecto, incluyendo el directorio <code>.git</code> que contiene la   historia Git. Para ello comprime tu directorio local del proyecto   despu\u00e9s de haber hecho un <code>./mvnw clean</code> para eliminar el   directorio <code>target</code> que contiene los binarios compilados. Debes   dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub.</li> <li>Debes subir a DockerHub la imagen docker con la versi\u00f3n final   1.2.0. Es la que me descargar\u00e9 y utilizar\u00e9 para comprobar el   funcionamiento final de la pr\u00e1ctica.</li> </ul> <p>Para la evaluaci\u00f3n se tendr\u00e1 en cuenta:</p> <ul> <li>Desarrollo continuo (los commits deben realizarse a lo largo de   las 3 semanas y no dejar todo para la \u00faltima semana).</li> <li>Correcto desarrollo de la metodolog\u00eda.</li> <li>Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las   caracter\u00edsticas desarrolladas.</li> <li>Documentaci\u00f3n.</li> </ul>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html","title":"Pr\u00e1ctica 4: Trabajo en equipo con GitFlow y despliegue en producci\u00f3n","text":""},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#1-objetivos-y-resumen-de-la-practica","title":"1. Objetivos y resumen de la pr\u00e1ctica","text":"<p>En esta pr\u00e1ctica se pretende conseguir:</p> <ol> <li>Crear los equipos de trabajo en GitHub.</li> <li>Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo.</li> <li>Desplegar la aplicaci\u00f3n usando una base de datos de producci\u00f3n y    mantener esta base de datos.</li> <li>Implementar GitFlow:<ul> <li>Desarrollar nuevas features con GitFlow.</li> <li>Lanzamiento de una versi\u00f3n nueva usando GitFlow.</li> </ul> </li> </ol>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#2-formacion-de-equipos","title":"2. Formaci\u00f3n de equipos","text":"<p>En esta pr\u00e1ctica comenzamos a trabajar en equipos de 3 personas.</p> <p>Cada equipo trabajar\u00e1 con un repositorio com\u00fan seleccionado de uno de los miembros del equipo. Utilizaremos GitHub Classroom para crear el team y el repositorio.</p>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir","title":"Pasos a seguir","text":"<ul> <li> <p>Deb\u00e9is formar equipos de 3 personas. </p> <p>De forma excepcional, ser\u00e1 posible crear equipos de 2 \u00f3 4 personas. En esta pr\u00e1ctica y en la siguiente se deber\u00e1 adaptar la cantidad de trabajo y funcionalidades implementadas en funci\u00f3n del n\u00famero de personas del equipo.</p> <p>Enviad los componentes al foro de Moodle y os asignar\u00e9 un nombre de equipo. Utilizad despu\u00e9s el enlace de GitHub Classroom que enviar\u00e9 al foro de Moodle para crear el equipo y apuntaros a \u00e9l.</p> <p>El primero que use el enlace debe crear el repositorio, escribiendo el nombre del equipo, como se muestra en la siguiente imagen.</p> <p></p> <p>El equipo trabajar\u00e1 con un repositorio creado por GitHub Classroom con el nombre <code>todolist--NOMBRE-EQUIPO</code>. Al igual que en la pr\u00e1ctica 2, el repositorio se crear\u00e1 en la organizaci\u00f3n <code>mads-ua-22-23</code>.</p> <p></p> <p>Una vez que la primera persona ha creado el equipo y el repositorio, las siguientes personas que usan el enlace pueden unirse al equipo creado o crear un nuevo equipo:</p> <p></p> </li> <li> <p>Una vez creado el repositorio deb\u00e9is crear en \u00e9l un tablero para   gestionar las tarjetas con los issues y los pull   requests. Ponedle como nombre el nombre del equipo y creadlo con las mismas   columnas que en las pr\u00e1cticas 2 y 3.</p> </li> <li> <p>Escoged el proyecto que vais a usar como punto de partida de estas   dos \u00faltimas pr\u00e1cticas de entre los proyectos de los miembros del   equipo. Intentad que se un proyecto con c\u00f3digo limpio y f\u00e1cilmente   ampliable.</p> <p>Subidlo al nuevo repositorio, cambiando la URL del <code>origin</code> del repositorio local y haciendo un push:</p> <p><pre><code>$ git remote set-url origin https://github.com/mads-ua-22-23/todolist-NOMBRE-EQUIPO.git\n$ git push -u origin main\n</code></pre> Por \u00faltimo, los otros miembros del equipo deber\u00e1n clonar el repositorio para que todos pod\u00e1is trabajar con \u00e9l en local.</p> </li> <li> <p>Cambiad el nombre del proyecto (en el fichero <code>POM.xml</code> y en el   <code>about.html</code> a <code>todolist-equipo-XX</code>.</p> <p>Haced un commit directamente en <code>main</code> con estos cambios. Comprobad que GitHub Actions sigue funcionando correctamente. </p> </li> </ul>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#3-nuevo-flujo-de-trabajo-para-los-issues","title":"3. Nuevo flujo de trabajo para los issues","text":"<p>Debemos adaptar el flujo de trabajo en GitHub al trabajo en equipo. En cuanto a la gesti\u00f3n de los issues y tablero del proyecto cambiaremos lo siguiente:</p> <ul> <li>Selecci\u00f3n del issue: Al pasar un issue de <code>To do</code>a <code>In   progress</code> se debe asignar un responsable del desarrollo del issue.</li> <li>Nueva rama con el issue: El responsable seleccionado ser\u00e1 el que abra una   rama nueva para el desarrollo del ticket y la subir\u00e1 a   GitHub.</li> <li>Desarrollo: Se trabaja en la rama. Cualquier compa\u00f1ero puede   unirse al ticket y trabajar junto con el responsable, trabajando   sobre la rama.</li> <li>Pull request: Cuando el ticket se ha terminado, el responsable   abre un pull request en GitHub y pone la tarjeta en la columna   <code>In pull request</code>.</li> <li> <p>Revisi\u00f3n de c\u00f3digo: Deb\u00e9is configurar la opci\u00f3n de GitHub que obliga a que   haya un m\u00ednimo de 1 revisor en el pull request.</p> <p>Los miembros del equipo revisan el c\u00f3digo en el pull request (consultar documentaci\u00f3n en GitHub: Reviewing   proposed changes in a pull  request). Al   menos uno de los miembros del equipo debe dar el visto bueno al PR, a\u00f1adiendo una reacci\u00f3n. </p> </li> <li> <p>Integraci\u00f3n del pull request: Cuando un miembro da el OK, el   responsable de la tarea integra el pull request.</p> </li> </ul> <p>Para implementar el trabajo en equipo ser\u00e1 necesario trabajar sobre ramas remotas compartidas. A continuaci\u00f3n explicamos con m\u00e1s detalle algunos aspectos comandos de Git necesarios.</p>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#comandos-git","title":"Comandos Git","text":"<p>Veamos algunos comandos de Git relacionados con el trabajo compartido en repositorios y ramas remotas.</p> <ul> <li> <p>Subir una rama al repositorio remoto (el responsable del issue):</p> <pre><code>$ git checkout -b nueva-rama\n$ git push -u origin nueva-rama\n</code></pre> </li> <li> <p>Descargar por primera vez una rama del repositorio remoto y moverse   a ella (el resto de miembros del equipo):</p> <pre><code>$ (main) git pull\n   * [nueva rama] nueva-rama -&gt; origin/nueva-rama\n$ (main) git branch -r (comprobamos las ramas remotas asegurarnos)\n$ (main) git checkout nueva-rama \n  rama 'nueva-rama' configurada para rastrear 'origin/nueva-rama'.\n  Cambiado a nueva rama 'nueva-rama'\n$ (nueva-rama)\n</code></pre> </li> <li> <p>Subir cambios de la rama remota:</p> <pre><code>$ (nueva-rama) git add .\n$ (nueva-rama) git commit -m \"Mis cambios\"\n$ (nueva-rama) git push\n</code></pre> <p>Si alg\u00fan compa\u00f1ero ha subido cambios a la rama remota que tenemos pendientes de descargar, al hacer un <code>git push</code> tendremos un error en el que nos indica que debemos hacer antes un <code>git pull</code>:</p> <pre><code>% (nueva-rama) git push\nTo https://github.com/domingogallardo/prueba-clase.git\n! [rejected]        nueva-rama -&gt; nueva-rama (fetch first)\nerror: fall\u00f3 el push de algunas referencias a 'https://github.com/domingogallardo/prueba-clase.git'\nayuda: Actualizaciones fueron rechazadas porque el remoto contiene trabajo que\nayuda: no existe localmente. Esto es causado usualmente por otro repositorio\nayuda: realizando push a la misma ref. Quiz\u00e1s quieras integrar primero los cambios\nayuda: remotos (ej. 'git pull ...') antes de volver a hacer push.\n</code></pre> <p>Puede ser que al hacer <code>git pull</code> nos aparezca el siguiente mensaje de error:</p> <pre><code>% (nueva-rama) git pull\nayuda: Hacer un pull sin especificar c\u00f3mo reconciliar las ramas es poco\nayuda: recomendable. Puedes eliminar este mensaje usando uno de los\nayuda: siguientes comandos antes de tu siguiente pull:\nayuda: \nayuda:   git config pull.rebase false  # hacer merge (estrategia por defecto)\nayuda:   git config pull.rebase true   # aplicar rebase\nayuda:   git config pull.ff only       # aplicar solo fast-forward\nayuda: \nayuda: Puedes reemplazar \"git config\" con \"git config --global\" para aplicar\nayuda: la preferencia en todos los repositorios. Puedes tambi\u00e9n pasar --rebase,\nayuda: --no-rebase, o --ff-only en el comando para sobrescribir la configuraci\u00f3n\nayuda: por defecto en cada invocaci\u00f3n.\nfatal: Necesita especificar c\u00f3mo reconciliar las ramas divergentes.\n</code></pre> <p>Debemos especificar entonces c\u00f3mo se van a mezclar los cambios que se bajan de la rama remota con los cambios locales. Para ello elegimos la primera opci\u00f3n, que no se haga un rebase sino un merge:</p> <pre><code>$ (nueva-rama) git config pull.rebase false\n</code></pre> <p>Ahora ya funciona el <code>git pull</code> (har\u00e1 un merge de la rama remota con la rama local):</p> <pre><code>$ (nueva-rama) git pull\n(aparecer\u00e1 un editor en el que tenemos que especificar el mensaje\ndel commit de merge, grabar y salir)\n</code></pre> <p>Y ahora ya podemos hacer <code>push</code>. Se subir\u00e1n nuestros cambios y el commit de merge:</p> <pre><code>$ (nueva-rama) git push\n</code></pre> </li> <li> <p>Comprobar el estado de las ramas locales:</p> <pre><code>$ git branch -vv\n</code></pre> <p>Con la opci\u00f3n <code>-a</code> (<code>git branch -vva</code>) se muestra tambi\u00e9n el estado de las ramas remote tracking de solo lectura (en rojo, y precedidas con el nombre <code>remotes/</code>):</p> <pre><code>$  git branch -vva\n  main                  dd867ac [origin/main] Colocados esquemas en su directorio\n* prueba                8d2d093 [origin/prueba] Correcci\u00f3n\n  remotes/origin/HEAD   -&gt; origin/main\n  remotes/origin/main   dd867ac Colocados esquemas en su directorio\n  remotes/origin/prueba 8d2d093 Correcci\u00f3n\n</code></pre> <p>Este comando no accede directamente al servidor, sino que muestra la informaci\u00f3n de la \u00faltima vez que se accedi\u00f3 a \u00e9l. Si queremos la informaci\u00f3n actualizada podemos hacer un <code>git fetch --all</code> antes:</p> <pre><code>$ git fetch --all\n$ git branch -vva\n</code></pre> <p>Es importante recordar que <code>git fetch</code> (a diferencia de <code>git pull</code>) no modifica los repositorios locales, sino que actualiza las ramas remote tracking.</p> </li> <li> <p>Comprobar cambios remotos: podemos comprobar si alg\u00fan compa\u00f1ero ha subido   alg\u00fan commit a alguna rama, y comprobar esos cambios antes de hacer un <code>merge</code>:</p> <pre><code>$ (main) git fetch --all\n   * Los cambios se descargan a las ramas locales origin/nueva-rama\n$ (main) git diff nueva-rama origin/nueva-rama\n$ (main) git checkout nueva-rama\n$ (nueva-rama) git merge origin/nueva-rama\n</code></pre> </li> <li> <p>Soluci\u00f3n de conflictos en un merge o pull en la nueva rama:</p> <p>Supongamos que hay un conflicto al mezclar los cambios remotos del compa\u00f1ero en la nueva rama (haciendo <code>git pull</code> o <code>git merge</code>). Git detectar\u00e1 el conflicto, modificar\u00e1 los ficheros en conflicto y deberemos editarlos para quedarnos con los cambios deseados:</p> <pre><code>$ (nueva-rama) git pull (o git merge origin/nueva-rama)\n  CONFLICTO (contenido): Conflicto de fusi\u00f3n en README.md\n  Fusi\u00f3n autom\u00e1tica fall\u00f3; arregle los conflictos y luego realice un commit con el resultado.\n$ (nueva-rama) git status\n  Tienes rutas no fusionadas.\n  (arregla los conflictos y ejecuta \"git commit\"\n  (usa \"git merge --abort\" para abortar la fusion)\n\n  Rutas no fusionadas:\n     (usa \"git add &lt;archivo&gt;...\" para marcar una resoluci\u00f3n)\n     modificados por ambos:  README.md\n# Editamos los ficheros en conflicto y nos quedamos con los cambios deseados\n$ (nueva-rama) git add .\n$ (nueva-rama) git commit -m \"Arreglado conflicto\"\n$ (nueva-rama) git push\n</code></pre> <p>Y el resto de compa\u00f1eros deber\u00e1n hacer un <code>git pull</code> para actualizar sus ramas locales.</p> </li> <li> <p>Informaci\u00f3n de los repositorios remotos:</p> <pre><code>$ git remote show origin\n</code></pre> <p>Proporciona informaci\u00f3n del repositorio remoto, todas sus ramas, del local y de la conexi\u00f3n entre ambos.</p> <pre><code>$ git remote -v update\n</code></pre> <p>Proporciona informaci\u00f3n del estado de las ramas remotas y locales (si est\u00e1n actualizadas o hay cambios en algunas no bajadas o subidas).</p> </li> <li> <p>Borrado de ramas remotas desde el terminal:</p> <pre><code>$ git push origin --delete nueva-rama\n$ git remote prune origin\n</code></pre> </li> <li> <p>Si necesitamos en la rama de feature c\u00f3digo que se haya a\u00f1adido en   la rama <code>main</code>.</p> <p>Podemos hacer un merge de la rama <code>main</code> en la rama de feature para incorporar los avances de c\u00f3digo que se han hecho en <code>main</code> y que necesitamos en nuestra nueva rama:</p> <pre><code>$ git checkout nueva-rama\n$ git merge main\n</code></pre> </li> <li> <p>Soluci\u00f3n de conflictos en un pull request:</p> <p>Supongamos que en un pull request GitHub detecta un conflicto entre la nueva rama y la rama <code>main</code>. En lugar de resolver el conflicto en GitHub es recomendable hacerlo en el repositorio local:</p> <pre><code>$ git checkout main\n$ (main) git pull\n$ (main) git checkout nueva-rama\n$ (nueva-rama) git merge main\n# arreglar el conflicto\n$ (nueva-rama) git push\n# ya se puede hacer el merge en GitHub\n</code></pre> </li> </ul>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_1","title":"Pasos a seguir","text":"<ol> <li> <p>A\u00f1adid el milestone 1.3.0 y etiquetad todos los pr\u00f3ximos issues con   \u00e9l. Vamos a probar el nuevo flujo de trabajo descrito anteriormente creando   un nuevo issue denominado <code>Actualizar la p\u00e1gina Acerca de</code>. En la   descripci\u00f3n de issue comentad que se debe modificar la p\u00e1gina para   que muestren todos los miembros del equipo y el nuevo n\u00famero de   versi\u00f3n de la aplicaci\u00f3n (<code>1.3.0-SNAPSHOT</code>).</p> </li> <li> <p>A\u00f1adid la regla de que sea necesario un revisor en los pull    requests. Para ello seleccionar Settings &gt; Branches &gt; Add branch    protection rule, poned como patr\u00f3n del nombre de rama el nombre    completo <code>main</code> y seleccionad Require a pull request before    merging y Require approvals. Poned 1 como n\u00famero de revisores    requeridos.</p> </li> <li> <p>Escoged una persona del equipo como responsable del issue. El   responsable del issue ser\u00e1 el responsable de integrarlo en   <code>main</code> y de solucionar los conflictos que puedan surgir.</p> </li> <li> <p>Probad los comandos Git anteriores en una rama en la que se   resuelva el issue. Cada miembro del equipo deber\u00e1 descargar esa   rama y realizar un commit en el que se a\u00f1ada su nombre a la lista de   autores de la aplicaci\u00f3n.</p> </li> <li> <p>Cread un conflicto entre commits de dos miembros del equipo. Cambiar los dos    la misma l\u00ednea del fichero, haced commit (llamadlo \"Provocando un conflicto\")    e intentad subir los commits a la rama. El \u00faltimo que lo haga no podr\u00e1,    tendr\u00e1 que hacer un <code>pull</code> y se generar\u00e1 un conflicto. Resolved el conflicto    y subir el fichero corregido.</p> </li> <li> <p>Cread el pull request en GitHub, poniendo como responsable del PR al   mismo responsable del issue.</p> </li> <li> <p>Provocad otro conflicto y arregladlo. Para ello se debe a\u00f1adir un   commit en <code>main</code> que entre en conflicto con los cambios realizados   en la rama. Pod\u00e9is a\u00f1adir el commit editando directamente el fichero en   GitHub. Arreglad el conflicto tal y como se explica en el apartado anterior.</p> </li> <li> <p>Por \u00faltimo, revisad el c\u00f3digo, aceptadlo e integrad el PR en    main.</p> </li> </ol>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#4-contenedor-con-la-aplicacion-todolist","title":"4. Contenedor con la aplicaci\u00f3n ToDoList","text":"<p>Una de las cosas que vamos a hacer en esta pr\u00e1ctica (en el siguiente apartado) es poner en producci\u00f3n en uno de vuestros ordenadores la aplicaci\u00f3n ToDoList conect\u00e1ndola con la base de datos. En las pr\u00e1cticas 1 y 2 ya hemos construido el contenedor Docker de la aplicaci\u00f3n, con el siguiente fichero Dockerfile:</p> <pre><code>FROM openjdk:8-jdk-alpine\nCOPY target/*.jar app.jar\nENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/urandom\",\"-jar\",\"/app.jar\"]\n</code></pre> <p>Este Dockerfile tiene un problema importante. El comando de ejecuci\u00f3n es fijo y no permite definir ning\u00fan par\u00e1metro de ejecuci\u00f3n. No es posible, por ejemplo, definir el perfil de Postgres, ni definir ning\u00fan par\u00e1metro de configuraci\u00f3n.</p> <p>Debemos cambiarlo de la siguiente forma:</p> <pre><code>FROM openjdk:8-jdk-alpine\nCOPY target/*.jar app.jar\nENTRYPOINT [\"sh\",\"-c\",\"java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}\"]\n</code></pre> <p>De esta forma podremos llamar al comando docker a\u00f1adiendo al final par\u00e1metros que se van a pasar al comando java. La forma de a\u00f1adir variables de entorno a ese comando java es precedi\u00e9ndolos con dos guiones <code>--</code>. Por ejemplo:</p> <pre><code>$ docker run --rm &lt;usuario&gt;/mads-todolist-equipoXX --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba \n</code></pre> <p>Vamos a probarlo, creando y subiendo la nueva imagen a DockerHub y despleg\u00e1ndola en uno de vuestros ordenadores. Este despliegue es lo que har\u00e9 yo para corregir la pr\u00e1ctica.</p>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_2","title":"Pasos a seguir","text":"<p>Deb\u00e9is hacer lo siguiente:</p> <ol> <li> <p>Creamos un issue llamado <code>Configuraci\u00f3n imagen docker</code> y    trabajamos en la rama <code>imagen-docker</code>.</p> </li> <li> <p>Cambiad el fichero Dockerfile de la aplicaci\u00f3n tal y como se indica en el listado    anterior:</p> ./Dockerfile<pre><code>FROM openjdk:8-jdk-alpine\nCOPY target/*.jar app.jar\nENTRYPOINT [\"sh\",\"-c\",\"java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}\"]\n</code></pre> </li> <li> <p>Modificad el fichero en el directorio <code>main</code> con el perfil <code>postgres</code> para    incluir la opci\u00f3n de usar variables de entorno, al igual que    hicimos en el perfil <code>postgres</code> de test.</p> src/main/resources/application-postgres.properties<pre><code>POSTGRES_HOST=localhost\nPOSTGRES_PORT=5432\nDB_USER=mads\nDB_PASSWD=mads\nspring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads\nspring.datasource.username=${DB_USER}\nspring.datasource.password=${DB_PASSWD}\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect\n</code></pre> </li> <li> <p>Cread la nueva imagen Docker con el nombre    <code>mads-todolist-equipoXX</code> y la etiqueta <code>1.3.0-snapshot</code>. El usuario puede ser cualquier miembro    del equipo, no es necesario que sea el autor del proyecto original.</p> <pre><code>$ ./mvnw package\n$ docker build -t &lt;usuario-docker&gt;/mads-todolist-equipoXX:1.3.0-snapshot . \n</code></pre> </li> <li> <p>Probad que funcionan correctamente los par\u00e1metros de configuraci\u00f3n    en la imagen Docker. Una forma sencilla de hacerlo es comprobar que    se puede definir el perfil de Postgres y modificar alguno de sus    par\u00e1metros. Deber\u00e1 aparecer un mensaje de error de que no se puede    conectar con la base de datos (lo que est\u00e1 bien, porque significa    que s\u00ed que se ha cargado el perfil).</p> <pre><code>$ docker run --rm &lt;usuario&gt;/mads-todolist-equipoXX:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba \n</code></pre> <p> </p> </li> <li> <p>Subid, por \u00faltimo, la imagen a Docker Hub y cerrad el PR y el issue.</p> <pre><code>$ docker login\n$ docker push &lt;usuario-docker&gt;/mads-todolist-equipoXX:1.3.0-snapshot\n</code></pre> </li> </ol>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#5-despliegue-en-produccion-con-bd","title":"5. Despliegue en producci\u00f3n con BD","text":"<p>Vamos a ver c\u00f3mo ejecutar en producci\u00f3n el contenedor con la aplicaci\u00f3n de forma que se conecte con una base de datos postgres.</p> <p>En las pr\u00e1cticas 1 y 2 vimos c\u00f3mo construir una versi\u00f3n en forma de contenedor de nuestra aplicaci\u00f3n Spring Boot y en la pr\u00e1ctica 3 vimos como usar un contenedor de Postgres para definir un servicio de base de datos con el que conectar la aplicaci\u00f3n.</p> <p>En esta pr\u00e1ctica vamos a definir la configuraci\u00f3n en producci\u00f3n definitiva de nuestra aplicaci\u00f3n. Veremos c\u00f3mo poner en marcha dos contenedores y conectarlos entre si. En nuestro caso un contenedor tendr\u00e1 la base de datos postgres y el otro la aplicaci\u00f3n Spring Boot.</p> <p></p> <p>La imagen anterior muestra los dos contenedores conectados por una red. Desde el contenedor con la aplicaci\u00f3n se acceder\u00e1 a la direcci\u00f3n <code>postgres:5432</code> para conectarse con la base de datos. Veremos los comandos de docker para definir una red y para lanzar el contenedor de base de datos en esa direcci\u00f3n de la red.</p> <p>El contenedor de base de datos montar\u00e1 el directorio actual del host en el directorio <code>/mi-host</code> del contenedor. De esta forma este directorio ser\u00e1 compartido y cualquier fichero que coloquemos en ese directorio del contenedor ser\u00e1 visible en el directorio actual del host (y viceversa). Usaremos este directorio para guardar datos de la base de datos, como copias de seguridad o ficheros de migraci\u00f3n.</p> <p>El contenedor de base de datos implementar\u00e1 la base de datos en producci\u00f3n. </p> <p>Base de datos de producci\u00f3n</p> <p>La base de datos de producci\u00f3n es la que mantiene los datos introducidos por los usuarios de la misma. Hay que prestar una atenci\u00f3n especial a esta base de datos y definir pol\u00edticas de respaldo y de control de cambios para evitar que se produzca cualquier p\u00e9rdida de informaci\u00f3n. Veremos que una de las cuestiones que hay que asegurar es que la aplicaci\u00f3n no puede modificar el esquema de datos de esta base de datos. </p> <p>Habr\u00e1 que definir tambi\u00e9n un flujo de trabajo para actualizar la base de datos de producci\u00f3n con los cambios del modelo de datos introducidos por la nuevas funcionalidades (nuevas tablas y nuevas relaciones).</p>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_3","title":"Pasos a seguir","text":"<p>Veamos paso a paso c\u00f3mo crear la configuraci\u00f3n anterior en uno de vuestros ordenadores, que usar\u00e9is como ordenador de despliegue.</p> <ol> <li> <p>Creamos en nuestro ordenador de despliegue una red gestionada por    Docker: </p> <pre><code>$ docker network create network-equipo\n</code></pre> </li> <li> <p>Lanzamos el contenedor con la base de datos usando la red creada   anteriormente y con el nombre <code>db-equipo</code>. Definimos el nombre del   host creado en el contenedor como <code>postgres</code> con el modificador   <code>--network-alias</code>.</p> <pre><code>$ docker run -d --network network-equipo --network-alias postgres -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13\n</code></pre> <p>El modificador <code>-v</code> permite montar el directorio actual en el directorio <code>/mi-host</code> del contenedor. </p> <p>Opci\u00f3n -v de Docker en Windows</p> <p>Si est\u00e1is en Windows deber\u00e9is especificar el directorio actual expl\u00edcitamente, sustituyendo las barras por barras dobles: <pre><code>$ docker run -d --network network-equipo --network-alias postgres -v C:\\\\users\\\\domingo\\\\tmp:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13\n</code></pre></p> <p>Vamos a probar que funciona  correctamente. </p> </li> <li> <p>Nos conectamos al contenedor lanzando un <code>bash</code>    interactivo. Estando en el contenedor creamos un fichero en el    directorio <code>/mi-host</code>, salimos del contenedor y comprobamos que    est\u00e1 en el directorio actual</p> <pre><code>$ docker exec -it db-equipo bash\nroot@e470db191dc6:/# cd /mi-host\nroot@e470db191dc6:/mi-host# echo \"Hola\" &gt; prueba.txt\nroot@e470db191dc6:/mi-host# exit\n$ ls\nprueba.txt\n$ more prueba.txt\nHola\n</code></pre> </li> <li> <p>Con esto ya tenemos configurado y en marcha el contenedor con la    base de datos Postgres. Esta va a ser nuestra base de datos de    producci\u00f3n. Vamos ahora a poner en marcha la aplicaci\u00f3n.</p> <p>Descargamos la \u00faltima versi\u00f3n de nuestra aplicaci\u00f3n y lanzamos el contenedor usando la red definida anteriormente. Los modificadores <code>--spring.profiles.active</code> y <code>--POSTGRES_HOST</code> permiten pasar al contenedor esas variables del entorno.</p> <pre><code>$ docker pull &lt;usuario&gt;/mads-todolist-equipoXX:1.3.0-snapshot\n$ docker run --rm --network network-equipo -p8080:8080 &lt;usuario&gt;/mads-todolist-equipoXX:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=postgres\n</code></pre> <p>\u00a1\u00a1\u00a1Enhorabuena!!! \u00a1Ya tenemos la aplicaci\u00f3n en producci\u00f3n trabajando con la base de datos!</p> <p>Podremos conectarnos a la aplicaci\u00f3n usando el puerto 8080.</p> <p>Probamos la aplicaci\u00f3n y creamos alg\u00fan usuario de prueba. Por \u00faltimo paramos el contenedor y lo volvemos a arrancar para comprobar que los datos son persistentes.</p> </li> <li> <p>Para comprobar que la base de datos est\u00e1 funcionando correctamente    podemos conectarnos al contenedor y examinar la base de datos    <code>mads</code> y alguna de sus tablas:</p> <pre><code>$ docker exec -it db-equipo bash\n# psql -U mads -W mads (nos pedir\u00e1 la contrase\u00f1a: mads)\n# \\l (lista las bases de datos)\n# \\dt (lista las tablas)\n# SELECT * FROM usuarios;\n</code></pre> <p>La base de datos se mantendr\u00e1 mientras que no borremos el contenedor. Podemos pararlo y volver a ponerlo en marcha y seguiremos conservando los datos:</p> <pre><code>$ docker stop db-equipo\n$ docker start db-equipo\n</code></pre> </li> </ol>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#6-perfil-de-produccion-y-mantenimiento-de-la-base-de-datos-de-produccion","title":"6. Perfil de producci\u00f3n y mantenimiento de la base de datos de producci\u00f3n","text":""},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#perfil-de-produccion","title":"Perfil de producci\u00f3n","text":"<p>Una vez que vamos a trabajar en producci\u00f3n con una base de datos, esta base de datos ser\u00e1 un elemento clave de la aplicaci\u00f3n. No debemos bajo ning\u00fan concepto perder datos que se hayan introducido en ella, ya que son datos de nuestros usuarios y clientes.</p> <p>Es imprescindible para ello cambiar el modo con el que la aplicaci\u00f3n construye las tablas de la base de datos. Sabemos que nuestra aplicaci\u00f3n est\u00e1 trabajando con JPA/Hibernate y que las tablas de la base de datos se construyen de forma autom\u00e1tica. Si hay alg\u00fan cambio en las entidades (se a\u00f1ade alg\u00fan atributo o alguna nueva entidad) Spring Boot actualiza las tablas de la base de datos de forma autom\u00e1tica cuando se lanza la aplicaci\u00f3n. Esto es razonable si estamos trabajando en un entorno de desarrollo, pero est\u00e1 totalmente desaconsejado en un entorno de producci\u00f3n.</p> <p>El par\u00e1metro <code>spring.jpa.hibernate.ddl-auto</code> es el que determina el funcionamiento de la actualizaci\u00f3n de las tablas de la base de datos. Su valor puede ser:</p> <ul> <li> <p><code>CREATE</code>: El esquema de datos se crea de nuevo cada vez que se lanza   la aplicaci\u00f3n. Una vez creado, se a\u00f1aden los datos definidos en el   fichero <code>data.sql</code> si el   <code>spring.sql.init.mode</code> tiene como valor <code>always</code>.</p> </li> <li> <p><code>UPDATE</code>: El esquema de datos de la base de datos se actualiza   autom\u00e1ticamente cuando hay un cambio en las entidades de la   aplicaci\u00f3n. As\u00ed es como tenemos configurado el perfil por defecto de   nuestra aplicaci\u00f3n. Si estamos trabajando con la base de datos   Postgres, se actualizar\u00e1 el esquema de datos. Pero esto no es   recomendable para producci\u00f3n, porque no tenemos control de las   instrucciones de actualizaci\u00f3n y pueden resultar en alguna p\u00e9rdida   de datos.</p> </li> <li> <p><code>VALIDATE</code>: El esquema de datos de la base de datos se valida con   respecto al esquema de datos definido por las entidades JPA. Si hay   alguna diferencia, salta una excepci\u00f3n. Este es el valor que hay que   usar cuando lanzamos la aplicaci\u00f3n en producci\u00f3n.</p> </li> </ul> <p>Vamos a definir en la aplicaci\u00f3n un nuevo perfil de ejecuci\u00f3n, llamado <code>postgres-prod</code>, en el que pondremos el valor del par\u00e1metro <code>spring.jpa.hibernate.ddl-auto</code> a <code>VALIDATE</code>. Y ser\u00e1 este el perfil que usaremos para lanzar la aplicaci\u00f3n en uno de vuestros ordenadores, que har\u00e1 de servidor de producci\u00f3n.</p>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#mantenimiento-de-la-base-de-datos-de-produccion","title":"Mantenimiento de la base de datos de producci\u00f3n","text":"<p>En una aplicaci\u00f3n en producci\u00f3n se deben configurar pol\u00edticas estrictas de realizaci\u00f3n de copias de seguridad y de integridad de los datos. Tambi\u00e9n en la gesti\u00f3n de las versiones y en la actualizaci\u00f3n del esquema de datos. </p> <p>Esto \u00faltimo se denomina una migraci\u00f3n de la base de datos y representa un elemento fundamental del mantenimiento en producci\u00f3n de una aplicaci\u00f3n, sobre todo cuando estamos trabajando de una forma \u00e1gil e incremental. Es un tema avanzado muy importante, pero que no podemos abordar en la asignatura por falta de tiempo. Un par de referencias que os pueden ser de utilidad son el art\u00edculo Evolutionary Database Design y herramientas como Flyway que permiten automatizar las migraciones de la base de datos.</p> <p>En la pr\u00e1ctica vamos a trabajar con la base de datos de producci\u00f3n de dos formas:</p> <ol> <li>Realizaremos una copia de seguridad antes de instalar una nueva    versi\u00f3n.</li> <li>Actualizaremos el esquema de datos aplicando un fichero de    migraci\u00f3n que construiremos manualmente.</li> </ol>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#copias-de-seguridad","title":"Copias de seguridad","text":"<p>Si eliminamos el contenedor con la base de datos se perder\u00e1n todos los datos. Para evitar perder los datos, con el contenedor en marcha podemos hacer una copia de seguridad de la base de datos <code>mads</code> en el directorio compartido:</p> <pre><code>$ docker exec -it db-equipo bash\n# pg_dump -U mads --clean mads &gt; /mi-host/backup03092021.sql\n</code></pre> <p>La copia de seguridad se guarda en el directorio compartido. Podemos poner la fecha en el nombre del fichero. Por ejemplo, la copia anterior ha sido creada el 3 de septiembre del 2021.</p> <p>Para restaurar una copia de seguridad basta con ejecutar el fichero SQL en la base de datos:</p> <pre><code>$ docker exec -it db-equipo bash\n# psql -U mads mads &lt; /mi-host/backup03092021.sql\n# exit\n</code></pre>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#migracion-de-la-base-de-datos","title":"Migraci\u00f3n de la base de datos","text":"<p>Podemos obtener el esquema de datos de la aplicaci\u00f3n (la definici\u00f3n de las tablas, sin los datos) conect\u00e1ndonos al contenedor y ejecutando el siguiente comando para guardar el fichero en el directorio compartido:</p> <pre><code>$ docker exec -it db-equipo bash\n# pg_dump -U mads -s mads &gt; /mi-host/schema.sql\n# exit\n</code></pre> <p>Tendremos el esquema de datos en el directorio actual, que hemos montado en el contenedor con la instrucci\u00f3n -V.</p> <p>Los esquemas son instrucciones SQL en texto plano. Supongamos que tenemos una nueva versi\u00f3n de la aplicaci\u00f3n (<code>1.3.0</code>) en la que hemos a\u00f1adido el atributo <code>descripcion</code> a la entidad <code>Equipo</code>.</p> <p>Si generamos el esquema de datos de esta nueva versi\u00f3n y lo llamamos <code>schema-1.3.0.sql</code> lo podemos comparar con el esquema anterior usando el comando de linux <code>diff</code>:</p> <pre><code>% diff sql/schema-1.3.0.sql sql/schema-1.2.0.sql \n41,42c41\n&lt;     nombre character varying(255),\n&lt;     descripcion character varying(255)\n---\n&gt;     nombre character varying(255)\n</code></pre> <p>Por ejemplo, en el ejemplo mostrado, el fichero <code>schema-1.3.0.sql</code> tiene un campo adicional que el fichero <code>schema-1.2.0.sql</code>. Se trata del campo <code>descripcion</code>. En la versi\u00f3n anterior (<code>schema-1.2.0.sql</code>) la tabla <code>equipo</code> se define como:</p> <pre><code>CREATE TABLE public.equipos (\nid bigint NOT NULL,\nnombre character varying(255)\n);\n</code></pre> <p>Mientras que en la versi\u00f3n nueva (<code>schema-1.3.0.sql</code>) se define como:</p> <pre><code>CREATE TABLE public.equipos (\nid bigint NOT NULL,\nnombre character varying(255),\ndescripcion character varying(255)\n);\n</code></pre> <p>Si queremos migrar la base de datos de producci\u00f3n de una versi\u00f3n a otra, debemos crear un script de migraci\u00f3n en el que modifiquemos \u00fanicamente el esquema de datos anterior para adaptarlo al nuevo.</p> <p>En este caso el script lo llamaremos <code>schema-1.2.0-1.3.0.sql</code> y contendr\u00e1 \u00fanicamente la siguiente instrucci\u00f3n:</p> <pre><code>ALTER TABLE public.equipos\nADD COLUMN descripcion character varying(255)\n</code></pre> <p>Para actualizar la base de datos de producci\u00f3n s\u00f3lo tenemos que ejecutar el script anterior:</p> <pre><code>$ docker exec -it db-equipo bash\n$ psql -U mads mads &lt; /mi-host/schema-1.2.0-1.3.0.sql\nALTER TABLE\n$ exit\n</code></pre> <p>De esta forma habremos a\u00f1adido manualmente un campo en la tabla <code>equipos</code>.</p> <p>La aplicaci\u00f3n deber\u00e1 funcionar ahora perfectamente si la lanzamos en modo producci\u00f3n, definiendo la variable que hemos mencionado antes con el modo <code>validate</code>:</p> <pre><code>spring.jpa.hibernate.ddl-auto=validate\n</code></pre>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_4","title":"Pasos a seguir","text":"<ol> <li> <p>Creamos un issue llamado <code>Esquema de datos y perfil de producci\u00f3n</code> y trabajamos    en la rama <code>esquema-datos</code> y en el pull request equivalente.</p> <pre><code>$ git checkout -b esquema-datos\n$ git push -u origin esquema-datos\n</code></pre> </li> <li> <p>Lanzamos la aplicaci\u00f3n en local con el modo <code>postgres</code>, trabajando    sobre la base de datos. Previamente hemos lanzado el contenedor postgres    montando el directorio actual en su directorio <code>/mi-host/</code>:</p> <pre><code>$ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13\n$ ./mvnw spring-boot:run -D spring-boot.run.profiles=postgres\n</code></pre> </li> <li> <p>Al lanzar la aplicaci\u00f3n se habr\u00e1 creado en la base de datos el    esquema de datos. Lo generamos y lo salvamos en el directorio    actual:</p> <pre><code>$ docker exec -it db-equipo bash\n# pg_dump -U mads -s mads &gt; /mi-host/schema-1.2.0.sql\n# exit\n</code></pre> </li> <li> <p>Comprobamos que el esquema de datos se ha creado correctamente y lo    movemos al directorio <code>sql</code> en el directorio ra\u00edz:</p> <pre><code>$ ls -l\nDockerfile\nREADME.md\nmvnw\nmvnw.cmd\npom.xml\nschema-1.2.0.sql\nsrc\ntarget\n$ mkdir sql\n$ mv schema-1.2.0.sql sql\n</code></pre> </li> <li> <p>Creamos un commit con el nuevo fichero con el esquema de datos.</p> </li> <li> <p>Creamos un nuevo fichero con el perfil de producci\u00f3n, que contiene     exactamente la misma configuraci\u00f3n del perfil postgres, excepto la     propiedad <code>spring.jpa.hibernate.ddl-auto</code> que tiene el valor     <code>validate</code>.</p> <p>Fichero ``:</p> /src/main/resources/application-postgres-prod.properties<pre><code>POSTGRES_HOST=localhost\nPOSTGRES_PORT=5432\nDB_USER=mads\nDB_PASSWD=mads\nspring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads\nspring.datasource.username=${DB_USER}\nspring.datasource.password=${DB_PASSWD}\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect\nspring.jpa.hibernate.ddl-auto=validate\n</code></pre> </li> <li> <p>Probamos en local que el perfil funciona correctamente, lanz\u00e1ndolo:</p> <pre><code>$ ./mvnw spring-boot:run -D spring-boot.run.profiles=postgres-prod\n</code></pre> <p>Probamos que realmente valida el esquema de datos, en lugar de actualizarlo. Para ello, paramos y borramos el contenedor postgres y lo lanzamos de nuevo. Esto crear\u00e1 una base de datos vac\u00eda:</p> <pre><code>$ docker container stop db-equipo\n$ docker container rm db-equipo\n$ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13\n</code></pre> <p>Si ahora lanzamos la aplicaci\u00f3n en modo <code>postgres-prod</code> obtendremos un error:</p> <p><pre><code>$ ./mvnw spring-boot:run -D spring-boot.run.profiles=postgres-prod\norg.springframework.beans.factory.BeanCreationException: Error\ncreating bean with name 'entityManagerFactory' defined in class\npath resource  [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: \nInvocation of init method failed; nested exception is\njavax.persistence.PersistenceException: [PersistenceUnit: default]\nUnable to build Hibernate SessionFactory; nested exception is \norg.hibernate.tool.schema.spi.SchemaManagementException: \nSchema-validation: missing table [equipo_usuario]\n</code></pre> 8. Actualizamos el contenedor postgres con el esquema de base de datos    salvado anteriormente:</p> <pre><code>$ docker exec -it db-equipo bash\n# psql -U mads mads &lt; /mi-host/sql/schema-1.2.0.sql\n# exit\n</code></pre> <p>Y arrancamos la aplicaci\u00f3n y comprobamos que ahora s\u00ed que funciona correctamente (la base de datos ya tiene el esquema de datos correcto).</p> </li> <li> <p>Introducimos en la aplicaci\u00f3n algunos datos de prueba y hacemos     una copia de seguridad tal y como se explica     anteriormente. Dejamos el fichero en el directorio <code>sql</code> del     repositorio, indicando la fecha en el nombre del mismo. Por     ejemplo <code>sql/backup15112022.sql</code>.</p> </li> <li> <p>Hacemos un commit, subimos los cambios y cerramos el pull request y    el issue.</p> </li> </ol>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#7-desarrollo-de-la-nueva-version-con-gitflow","title":"7. Desarrollo de la nueva versi\u00f3n con GitFlow","text":"<p>El flujo de trabajo Git que vamos a seguir es muy similar al flujo de trabajo GitFlow (recordad la clase de teor\u00eda)</p>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#ramas-de-largo-recorrido","title":"Ramas de largo recorrido","text":"<p>En GitFlow se publican las distintas versiones del proyecto en la rama long-lived <code>main</code> y se hace el desarrollo en la rama <code>develop</code>. A partir de ahora no desarrollaremos directamente en <code>main</code> sino en <code>develop</code>.</p> <p>En la p\u00e1gina de configuraci\u00f3n del repositorio en GitHub en <code>Settings &gt; Branches &gt; Default branch</code> se puede configurar la rama por defecto contra la que se realizar\u00e1n los commits y la que aparecer\u00e1 en la p\u00e1gina del proyecto. Tendr\u00e9is que definir <code>develop</code>.</p>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#ramas-de-feature","title":"Ramas de feature","text":"<p>Desde el comienzo de trabajo con Git en las pr\u00e1cticas 2 y 3 estamos haciendo un desarrollo basado en ramas de corto recorrido, equivalentes a las ramas de features de GitFlow. </p> <p>Tal y como se comenta en GitFLow estas ramas saldr\u00e1n de <code>develop</code> y se integrar\u00e1n en <code>develop</code>. La diferencia es que en GitFlow estas ramas se integran con la rama de desarrollo manualmente haciendo <code>merge</code>, mientras que nosotros las integramos haciendo un pull request.</p>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_5","title":"Pasos a seguir","text":"<ol> <li> <p>Cread la rama <code>develop</code> y configurarla como rama principal del   proyecto en GitHub. A\u00f1adir en los ajustes del repositorio la regla   para obligar a revisar todos los PR que se mezclen en esta rama. Todos   los otros miembros deber\u00e1n descargarla y moverse a ella en sus   repositorios locales. Esta rama pasar\u00e1 a ser la de desarrollo   principal.</p> </li> <li> <p>Cread dos, tres o cuatro issues (dependiendo del n\u00famero de personas de   vuestro grupo) distintos, simulando nuevas funcionalidades. Deben ser issues   sencillos, que no cuesten demasiado de implementar (mejorar alg\u00fan defecto de la aplicaci\u00f3n,   cambiar alg\u00fan elemento de alguna de las vistas, o algo   similar). Uno de los cambios debe afectar a alguna entidad, por   ejemplo a\u00f1adir un campo de descripci\u00f3n a los equipos y actualizar   las vistas correspondientes para permitir su inicializaci\u00f3n y su   actualizaci\u00f3n.</p> <p>Cada uno de los miembros del equipo ser\u00e1 el responsable de uno de los issues.</p> </li> <li> <p>Configurad el repositorio GitHub para obligar a que cualquier pull   request tenga que tener la revisi\u00f3n de una persona distinta del   responsable del PR.</p> </li> <li> <p>Desarrollad e integrar los issues en <code>develop</code> siguiendo el flujo de   trabajo planteado anteriormente. Deb\u00e9is ir actualizando el tablero   de GitHub se actualiza correctamente.</p> </li> </ol>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#rama-de-release","title":"Rama de release","text":"<p>Hasta ahora hemos hecho los releases en la rama <code>main</code>. A partir de ahora seguiremos la estrategia de GitFlow y haremos ramas de release que salen de <code>develop</code> y se integran en <code>main</code> y en <code>develop</code>.</p> <p>Haremos tambi\u00e9n la integraci\u00f3n haciendo pull request.</p> <p>Una cosa importante que tendremos que hacer en el release es crear el guardar el de datos de la nueva versi\u00f3n y crear el script de migraci\u00f3n de la base de datos.</p>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_6","title":"Pasos a seguir","text":"<p>Vamos a probar el lanzamiento de una release usando el flujo de trabajo GitFlow.</p> <ol> <li> <p>Cread un issue con la tarea Lanzar release 1.3.0.</p> </li> <li> <p>Siguiendo las indicaciones de GitFlow, crear la rama local    <code>release-1.3.0</code> a partir de <code>develop</code>.</p> </li> <li> <p>En esta rama se deben realizar los cambios espec\u00edficos de la    versi\u00f3n. En nuestro caso:</p> <ul> <li>Cambiar en la p\u00e1gina <code>Acerca de</code> \"Versi\u00f3n 1.3.0-SNAPSHOT\" a       \"Versi\u00f3n 1.3.0\" y a\u00f1adir la fecha de publicaci\u00f3n.</li> <li>Cambiar el fichero <code>pom.xml</code>.</li> <li>Generad el esquema de datos de la base de datos postgres   y guardarlo en <code>sql/schema-1.3.0.sql</code>. </li> <li>Comparar este esquema con el esquema anterior y crear el script   de migraci\u00f3n con las instrucciones <code>ALTER TABLE</code> necesarias para   actualizar la base de datos de producci\u00f3n de la versi\u00f3n 1.2.0 a   la 1.3.0. Guardar el script en <code>sql/schema-1.2.0-1.3.0.sql</code>.</li> </ul> </li> <li> <p>Comprobad que funciona correctamente el script de migraci\u00f3n. Para    ello deber\u00e9is simular que pon\u00e9is en marcha la aplicaci\u00f3n en modo    producci\u00f3n trabajando con una actualizaci\u00f3n de la base de datos:</p> <ul> <li>Poner en marcha una base de datos de producci\u00f3n vac\u00eda.</li> <li>Actualizar la base de datos con la copia de seguridad guardada en   el directorio <code>sql</code>.</li> <li>Actualizar la base de datos con el script de migraci\u00f3n   <code>sql/schema-1.2.0-1.3.0.sql</code>, tal y como se explica en el apartado   anterior. </li> <li>Lanzar el contenedor de la aplicaci\u00f3n con el perfil   <code>postgres-prod</code> y comprobar que funciona correctamente la   aplicaci\u00f3n en producci\u00f3n y que se mantienen los datos   anteriores.</li> <li>A\u00f1adir nuevos datos y hacer una nueva copia de seguridad que se   debe guardar tambi\u00e9n en el directorio <code>src</code>, con la fecha actual   como nombre como hicimos anteriormente. Por ejemplo,   <code>src/backup-20112022.sql</code>.</li> <li>Haced un commit para a\u00f1adir esta nueva copia de seguridad al   repositorio. </li> </ul> </li> <li> <p>Publicad la rama <code>release-1.3.0</code> en GitHub y hacer un pull    request sobre <code>main</code>. Una vez mezclado el PR a\u00f1adir la    etiqueta con la nueva versi\u00f3n <code>1.3.0</code> en <code>main</code> creando la    p\u00e1gina de release en GitHub.</p> </li> <li> <p>Mezclar tambi\u00e9n la rama de release con <code>develop</code> (se puede hacer     tambi\u00e9n con un PR).</p> </li> <li> <p>Subir la nueva versi\u00f3n de la imagen de docker a Docker Hub.</p> </li> <li> <p>Una vez hecho esto ya se puede borrar la rama <code>release-1.3.0</code> y las   ramas <code>main</code> y <code>develop</code> estar\u00e1n actualizadas a la nueva   versi\u00f3n.</p> </li> <li> <p>Debemos comprobar que GitHub Actions pasa correctamente todos los    tests de las nuevas caracter\u00edsticas que se a\u00f1aden.</p> </li> </ol>"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#9-documentacion-entrega-y-evaluacion","title":"9. Documentaci\u00f3n, entrega y evaluaci\u00f3n","text":"<p>Deber\u00e9is a\u00f1adir una p\u00e1gina de documentaci\u00f3n <code>/doc/practica4.md</code> en la que deber\u00e9is incluir:</p> <ul> <li>Breve documentaci\u00f3n t\u00e9cnica de los cambios introducidos en la   aplicaci\u00f3n.</li> <li>Detalles del despliegue de producci\u00f3n. Esquemas de datos de las   versiones 1.2.0 y de la versi\u00f3n 1.3.0. Script de migraci\u00f3n de la   base de datos.</li> <li>URL de la imagen Docker de la aplicaci\u00f3n.</li> </ul> <p>Entrega:</p> <ul> <li>La pr\u00e1ctica tiene una duraci\u00f3n de 2 semanas y debe estar terminada   el martes 28 de noviembre.</li> <li>La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 15% en la nota   final de pr\u00e1cticas.</li> <li>Para realizar la entrega uno de los miembros del equipo debe subir a   Moodle un ZIP que contenga todo el proyecto, incluyendo el   directorio <code>.git</code> que contiene la historia Git. Para ello comprime   tu directorio local del proyecto despu\u00e9s de haber hecho un <code>mvn   clean</code> para eliminar el directorio <code>target</code> que contiene los   binarios compilados.</li> </ul> <p>Para la evaluaci\u00f3n se tendr\u00e1 en cuenta:</p> <ul> <li>Desarrollo continuo (los commits deben realizarse a lo largo de   las semanas y no dejar todo para la \u00faltima).</li> <li>Correcto desarrollo de la metodolog\u00eda.</li> <li>Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las   caracter\u00edsticas desarrolladas.</li> <li>Funcionamiento de la aplicaci\u00f3n con las bases de datos de producci\u00f3n   y funcionamiento del script de migraci\u00f3n.</li> <li>Documentaci\u00f3n.</li> </ul>"},{"location":"05-iteracion-scrum/iteracion-scrum.html","title":"Pr\u00e1ctica 5: Sprint final","text":""},{"location":"05-iteracion-scrum/iteracion-scrum.html#objetivos-y-resumen-de-la-practica","title":"Objetivos y resumen de la pr\u00e1ctica","text":"<p>En esta pr\u00e1ctica seguiremos trabajando con los mismos equipos y proyecto que en la pr\u00e1ctica 4.</p> <p>Durante las semanas de la pr\u00e1ctica el equipo realizar\u00e1 una iteraci\u00f3n para desarrollar un sprint completo de Scrum con el que obtener un incremento de la aplicaci\u00f3n <code>TodoList</code>. Usaremos el mismo flujo de trabajo de la pr\u00e1ctica 4 para desarrollar sobre la rama <code>develop</code>:</p> <ul> <li>Una tarjeta en el tablero de Trello para cada historia de   usuario. Cada historia de usuario continuar\u00e1 la numeraci\u00f3n que   comenzamos en la pr\u00e1ctica 3. </li> <li>La historia de usuario se puede descomponer en mas de un issue en   GitHub o hacerla en un \u00fanico issue si es corta. En cualquier caso,   se deber\u00e1n etiquetar los issues con la etiqueta asociada a la   historia de usuario.</li> <li>Cada issue se resuelve en una rama y se integra en <code>develop</code> con un   pull request.</li> <li>En el tablero en GitHub se representan el estado de los issues.</li> <li>El repositorio est\u00e1 conectado a GitHub Actions para hacer la integraci\u00f3n   continua. Se comprueban de forma autom\u00e1tica los tests en las   integraciones de los pull requests en <code>develop</code>.</li> </ul> <p>Al final de la pr\u00e1ctica se lanzar\u00e1 una nueva versi\u00f3n (<code>1.4.0</code>), usando el mismo flujo de trabajo que en la pr\u00e1ctica anterior, y se presentar\u00e1 la aplicaci\u00f3n resultante en una demostraci\u00f3n en clase.</p>"},{"location":"05-iteracion-scrum/iteracion-scrum.html#nuevas-funcionalidades-para-la-aplicacion","title":"Nuevas funcionalidades para la aplicaci\u00f3n","text":"<p>Tenemos que dise\u00f1ar, como responsables del producto (Product Owners), las pr\u00f3ximas funcionalidades a implementar en la aplicaci\u00f3n. Las refinaremos y desarrollaremos durante el resto de la pr\u00e1ctica.</p> <p>Deber\u00e9is reuniros y pensar en c\u00f3mo hacer el producto m\u00e1s interesante para los usuarios. Pensad que quer\u00e9is poner la aplicaci\u00f3n en producci\u00f3n y que est\u00e1is buscando funcionalidades que la hagan interesante para que los usuarios se suscriban a ella.</p> <p>Pod\u00e9is coger ideas del tablero Trello resultante de ideas de cursos pasados y tambi\u00e9n de una aplicaci\u00f3n web muy completa que hace algo similar a lo que estamos construyendo nosotros: todoist (mirad, por ejemplo, el v\u00eddeo explicando sus funcionalidades m\u00e1s importantes).</p> <p>Ten\u00e9is que poneros en el lugar de los usuarios y pensar en funcionalidades que les puedan ser \u00fatiles, resolver alg\u00fan problema. No es cuesti\u00f3n de a\u00f1adir funcionalidades porque s\u00ed, sino que ten\u00e9is que intentar hacer en pocas semanas un producto lo m\u00e1s coherente y \u00fatil posible. </p> <p>El resultado ser\u00e1 un tablero Trello con columnas denominadas Backlog (1) y Backlog (2): en la que se encuentren las descripciones de las funcionalidades candidatas a implementarse en la siguiente pr\u00e1ctica, ordenadas de m\u00e1s interesante a menos (de arriba a abajo y de izquierda a derecha) y etiquetadas con su tama\u00f1o. La imagen de abajo es un ejemplo, con los t\u00edtulos de la mayor\u00eda de las funcionalidades borradas para no dar demasiadas ideas.</p> <p></p> <p>El profesor podr\u00e1 pediros alguna aclaraci\u00f3n sobre las funcionalidades propuestas y la estimaci\u00f3n de tama\u00f1o de las funcionalidades. Tambi\u00e9n se valorar\u00e1 el alcance de las funcionalidades escogidas en la presentaci\u00f3n final de la pr\u00e1ctica, en donde se dar\u00e1 una puntuaci\u00f3n extra a los proyectos en base a las funcionalidades implementadas, su coherencia y usabilidad. </p>"},{"location":"05-iteracion-scrum/iteracion-scrum.html#pasos-a-seguir","title":"Pasos a seguir","text":"<ul> <li> <p>Haced una reuni\u00f3n en la que revis\u00e9is el tablero Trelllo con ejemplos de funcionalidades de cursos pasados y la aplicaci\u00f3n web todoist. Usad esas funcionalidades como ejemplo, pod\u00e9is proponer vosotros nuevas funcionalidades. Deb\u00e9is definir las que vais a incorporar a vuestra aplicaci\u00f3n y estimar su dificultad. Ten\u00e9is que pensar en funcionalidades que puedan ser \u00fatiles y, sobre todo, definir un producto coherente, f\u00e1cil de usar y que puede representar un m\u00ednimo producto viable.</p> <p>En cuanto a la estimaci\u00f3n de la dificultad o tama\u00f1o de la funcionalidad, s\u00f3lo podr\u00e9is definir funcionalidades de tama\u00f1o de 1 y 2 puntos. Si alguna funcionalidad es mayor, deber\u00e9is descomponerla en otras m\u00e1s peque\u00f1as. </p> <p>Los puntos indican un tama\u00f1o relativo. Si estim\u00e1is una historia de usuario en 2 puntos es porque pens\u00e1is que tardar\u00e9is el doble en terminarla que otra de 1 punto.</p> <p>Para estimar el tama\u00f1o pod\u00e9is usar planning pocker: se explica la funcionalidad y cada miembro del equipo elige un n\u00famero: 1, 2, m\u00e1s de 2. Se ense\u00f1an simult\u00e1neamente y se explican las diferencias. El hecho de que haya diferencias normalmente se debe a que existe disparidad en los detalles de la implementaci\u00f3n o del alcance de la funcionalidad. Se ponen en com\u00fan las diferencias, se llegan a acuerdos y se vuelve a hacer otra ronda de planning pocker. Se siguen haciendo rondas hasta que hay un consenso.</p> </li> <li> <p>Deb\u00e9is seleccionar historias que sumen entre 12 y 15 puntos para   implementar en la pr\u00e1ctica. Para los equipos de 2 personas   seleccionar entre 8 y 10 puntos. La pr\u00e1ctica tendr\u00e1 una duraci\u00f3n de   4 semanas, por lo que cada miembro del equipo deber\u00e1 implementar   alrededor de 1 punto por semana.</p> <p>Seleccionad las historias que pens\u00e9is que hacen un producto atractivo, coherente y \u00fatil para el usuario. Ordenad las historias seg\u00fan su valor. Para estimar el valor pod\u00e9is hacer algo similar al planning pocker pero usando los n\u00fameros 1 y 2 como forma de identificar la utilidad o valor de cada historia.</p> </li> <li> <p>Cread un tablero Trello y poned un enlace a \u00e9l en el README del   repositorio. Cread las etiquetas <code>1</code> y <code>2</code> con distintos colores que   indican el tama\u00f1o de cada funcionalidad.</p> </li> <li> <p>A\u00f1adid historias de usuario, ordenadas de mayor a menor importancia   (arriba a la izquierda la m\u00e1s importante y abajo a la derecha la   menos). Cada tarjeta de Trello debe contener:</p> <ul> <li>T\u00edtulo. Aparece en la tarjeta.</li> <li>Descripci\u00f3n. Muy breve, al estilo de las historias de   XP. Pod\u00e9is usar el est\u00e1ndar \"Como XXX quiero XXX para XXX\", o   cualquier otro estilo. Pero siempre debe quedar claro que la   caracter\u00edstica debe ser una nueva funcionalidad que pueda usar o   que note un usuario de la aplicaci\u00f3n.</li> <li>Detalles. Detalles que consider\u00e9is importantes anotar y que   explican m\u00e1s el alcance de la historia.</li> <li>Condiciones de satisfacci\u00f3n. Condiciones que deben cumplirse   para considerar que la historia est\u00e1 terminada. Son   fundamentales a la hora de definir pruebas autom\u00e1ticas y   manuales. Las pruebas se definen a partir de estas condiciones   de satisfacci\u00f3n.</li> </ul> </li> </ul> <p>El profesor podr\u00e1 pediros alguna aclaraci\u00f3n sobre las propuestas y la estimaci\u00f3n de tama\u00f1o de las funcionalidades.</p>"},{"location":"05-iteracion-scrum/iteracion-scrum.html#artefactos-del-sprint","title":"Artefactos del sprint","text":"<p>El equipo utilizar\u00e1 un tablero Trello para documentar el backlog del producto y el tablero de GitHub para el backlog del sprint.</p>"},{"location":"05-iteracion-scrum/iteracion-scrum.html#tablero-trello","title":"Tablero Trello","text":"<p>El tablero Trello contendr\u00e1 el backlog del producto y servir\u00e1 para trabajar con estas historias de usuario en formato de tarjeta, escribirlas r\u00e1pidamente, estimarlas y ordenarlas.</p> <p>Cada tarjeta Trello contendr\u00e1 lo que ya hab\u00e9is hecho anteriormente:</p> <ul> <li>T\u00edtulo de la historia de usuario</li> <li>Descripci\u00f3n </li> <li>Detalles</li> <li>Estimaci\u00f3n del tama\u00f1o de la historia (definido con una etiqueta)</li> </ul> <p>Utilizaremos un tablero en formato Kanban, definiendo cinco columnas que representar\u00e1n las fases por las que pasar\u00e1 cada historia de usuario: <code>Backlog</code>, <code>Seleccionadas</code>, <code>En marcha</code>, <code>En prueba</code> y <code>Terminadas</code>.</p> Tipo de columna Caracter\u00edsticas de las historias Backlog Estimado el tama\u00f1o de la historia y pendiente de elaborar detalles. Seleccionadas Se est\u00e1n elaborando todos los detalles de la historia (p\u00e1gina Google Docs). En marcha Se ha abierto el primer issue en GitHub y el equipo ha comenzado a desarrollar la historia. En prueba La historia completa est\u00e1 integrada en <code>develop</code>. En la tarjeta se debe a\u00f1adir un enlace al commit. Terminadas Se han comprobado las condiciones de satisfacci\u00f3n de la historia."},{"location":"05-iteracion-scrum/iteracion-scrum.html#pasos-a-seguir_1","title":"Pasos a seguir","text":"<p>Durante el desarrollo del sprint, se deber\u00e1 a\u00f1adir en el tablero Trello:</p> <ul> <li> <p>Responsable de la historia de usuario: miembro del equipo que   liderar\u00e1 el desarrollo de la historia. Puede que m\u00e1s de una persona   intervenga en el desarrollo de la historia, pero una persona ser\u00e1 la   responsable. Se debe a\u00f1adir en la ficha de la historia de usuario,   en forma de etiqueta.</p> <p>Todos los miembros del equipo deber\u00e1n realizar un trabajo equitativo, y se repartir\u00e1n las historias de forma que queden tambi\u00e9n equilibrados los tama\u00f1os totales de las historias asignadas a cada uno.</p> </li> <li> <p>Antes de comenzar el desarrollo de una historia su responsable   crear\u00e1a una p\u00e1gina Google Docs de acceso p\u00fablico en la copiar\u00e1,   y ampliar\u00e1 y/o modificar\u00e1 sus detalles. La descripci\u00f3n en Trello hay   que dejarla tal cual, sin modificar. En la p\u00e1gina de Google Docs, el   responsable de la historia de usuario deber\u00e1 incluir, cuando la   seleccione, los siguientes \u00edtems:</p> <ul> <li>T\u00edtulo de historia de usuario</li> <li>Descripci\u00f3n y detalles</li> <li>Borrador del aspecto de la interfaz de usuario resultante. No es   necesario que sea muy detallado ni que se use ninguna   herramienta de mockups, se puede hacer escaneando un dibujo   hecho a mano.</li> <li>Condiciones de satisfacci\u00f3n (COS). Estas condiciones de   satisfacci\u00f3n son esenciales a la hora de determinar el alcance   de la historia y de darla por acabada. Deben estar lo   suficientemente claras como para poder elaborar a partir de   ellas las pruebas manuales de la historia de usuario.</li> </ul> <p>Importante</p> <p>Los detalles de la historia de usuario en Google Docs se escribir\u00e1n s\u00f3lo cuando la historia haya sido seleccionada y est\u00e9 en la columna <code>Seleccionadas</code>. Es recomendable que el paso de una historia a seleccionada se haga cuando se haya terminado la historia anterior con la que se estaba trabajando. De esta forma, cuando escribamos los detalles de la siguiente historia seleccionada ya tendremos el proyecto m\u00e1s avanzado y podremos elaborar mejor los detalles de la nueva historia. </p> <p>Es posible cambiar cosas en la p\u00e1gina de Google Docs con respecto a la descripci\u00f3n de la tarjeta en Trello. Dejad la descripci\u00f3n sin modificar, para tener una referencia de la evoluci\u00f3n del dise\u00f1o del proyecto.</p> </li> <li> <p>Una vez creado el documento Google de la historia de usuario ya se puede comenzar a realizar la implementaci\u00f3n de la misma abriendo el o los issues en GitHub y a\u00f1adiendo al mismo el responsable de su desarrollo.</p> <p>Importante</p> <p>Aunque parezca evidente, lo resalto: hay que pasar las fases de forma ordenada. No podemos empezar a desarrollar una historia de usuario antes de haber terminado todos sus detalles en la p\u00e1gina de Google Docs.</p> </li> <li> <p>Se debe documentar la evoluci\u00f3n del tablero realizando 4 capturas de pantalla y registrando la fecha de cada una.</p> </li> </ul>"},{"location":"05-iteracion-scrum/iteracion-scrum.html#tablero-github","title":"Tablero GitHub","text":"<p>El tablero GitHub contendr\u00e1 el backlog del sprint en el que se visualizar\u00e1n los issues con los trabajos que est\u00e1 realizando el equipo de desarrollo. </p> <p>En los issues podremos tener:</p> <ul> <li>Desarrollo de historias de usuario (en parte o completas)</li> <li>Bugs y refactorizaciones</li> <li>Desarrollos t\u00e9cnicos necesarios no relacionados con una historia de   usuario en concreto</li> </ul> <p>Usaremos las etiquetas para definir el tipo de issue:</p> <ul> <li>C\u00f3digo de historia de usuario</li> <li>Bug</li> <li>Refactorizaci\u00f3n</li> <li>Mejora t\u00e9cnica</li> </ul> <p>Los primeros tipos de issue ser\u00e1n obligatorios y los tres siguientes ser\u00e1n opcionales, dependiendo de si el proyecto lo requiere.</p> <p>En cuanto a las columnas, definiremos el tablero como un tablero Kanban. Usaremos las mismas columnas que hasta ahora, con los issues_ movi\u00e9ndose por ellas seg\u00fan se vayan desarrollando.</p> Tipo de columna Caracter\u00edsticas de los issues Sprint backlog Issues esperando a ser desarrollados. In progress El issue tiene asignado un responsable y se ha abierto una rama para su desarrollo. In pull request El issue tiene un pull request abierto. Done El pull request que se ha resuelto y el issue est\u00e1 integrado en <code>develop</code>. <p>Al igual que el tablero de Trello, se debe documentar la evoluci\u00f3n del tablero de issues realizando 4 capturas de pantalla y registrando la fecha de cada una.</p>"},{"location":"05-iteracion-scrum/iteracion-scrum.html#desarrollo-del-sprint","title":"Desarrollo del sprint","text":"<p>Se deber\u00e1n realizar los siguientes eventos, tomando nota y redactando un informe con la fecha de la reuni\u00f3n, su duraci\u00f3n y su desarrollo:</p> <ol> <li>2 sesiones de pair programming con turnos de 20 minutos (en cada    sesi\u00f3n se deben hacer 4 turnos). Se podr\u00e1n hacer estas sesiones en    clase de pr\u00e1cticas.</li> <li>Retrospectiva del sprint: an\u00e1lisis de qu\u00e9 cosas han funcionado    regular y hay que mejorar y qu\u00e9 cosas han funcionado bien durante    el sprint.</li> </ol>"},{"location":"05-iteracion-scrum/iteracion-scrum.html#desarrollo-de-issues-e-historias","title":"Desarrollo de issues e historias","text":"<ul> <li> <p>Cada miembro del equipo selecciona el issue a desarrollar. Lo normal   es que cada miembro desarrolle un \u00fanico issue de forma concurrente,   aunque podr\u00eda darse el caso de ser m\u00e1s (por ejemplo, si alg\u00fan issue   no puede terminarse por estar bloqueado por otro).</p> </li> <li> <p>Se deben crear ramas para los issues y pull requests con revisi\u00f3n de   c\u00f3digo para integrar los pull requests en <code>develop</code>. Es suficiente con   que haya una \u00fanica aprobaci\u00f3n para integrar el pull request.</p> </li> <li> <p>Seguimos usando GitHub Actions  para la integraci\u00f3n continua.</p> </li> <li> <p>Como hemos hecho hasta ahora, cada issue debe contener tests   autom\u00e1ticos que prueben los cambios.</p> </li> <li> <p>Una vez terminados todos los issues de una historia de usuario, el   responsable de la historia mover\u00e1 su tarjeta en el tablero Trello a   <code>En prueba</code>, se a\u00f1adir\u00e1 en la tarjeta el enlace al commit de develop   en el que se ha realizado la integraci\u00f3n y otro miembro del equipo   realizar\u00e1 las pruebas manuales especificadas en sus COS   utilizando la base de datos Postgres. Cuando se hayan superado   todas las pruebas se pasar\u00e1 la historia a <code>Terminada</code>. Si se   detectara alg\u00fan fallo, se volver\u00e1 la historia a <code>En marcha</code> y se   abrir\u00e1 un issue de tipo <code>bug</code> para resolver el problema.</p> </li> </ul>"},{"location":"05-iteracion-scrum/iteracion-scrum.html#publicacion-de-nueva-version-y-migracion-de-la-base-de-datos","title":"Publicaci\u00f3n de nueva versi\u00f3n y migraci\u00f3n de la base de datos","text":"<p>Al final del desarrollo se deber\u00e1 lanzar una nueva release (1.4.0) en la rama <code>main</code> usando los mismos pasos que en la pr\u00e1ctica anterior. Se debe obtener el esquema de datos de la nueva versi\u00f3n y crear el script de migraci\u00f3n de la base de datos de producci\u00f3n.</p> <p>Como se hizo en la pr\u00e1ctica anterior, se debe hacer una copia de seguridad de algunos datos en producci\u00f3n antes de actualizar la base de datos, aplicar el script de migraci\u00f3n a la base de datos de producci\u00f3n, comprobar que la aplicaci\u00f3n funciona correctamente con las nuevas funcionalidades a\u00f1adiendo algunos nuevos datos y hacer otra copia de seguridad de los datos despu\u00e9s de probar la aplicaci\u00f3n y a\u00f1adir los nuevos datos.</p> <p>Como en la pr\u00e1ctica anterior, ambas copias de seguridad se deben incluir en el directorio <code>sql</code> del repositorio.</p>"},{"location":"05-iteracion-scrum/iteracion-scrum.html#documentacion-del-desarrollo","title":"Documentaci\u00f3n del desarrollo","text":"<ul> <li>Documentar las sesiones de pair programming.</li> <li>Documentar la evoluci\u00f3n de los tableros Trello y GitHub capturando 4   instant\u00e1neas y registrando su fecha.</li> </ul>"},{"location":"05-iteracion-scrum/iteracion-scrum.html#entrega-y-evaluacion","title":"Entrega y evaluaci\u00f3n","text":"<p>La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas (por motivos de calendario se ha modificado a 3 semanas)</p> <ul> <li> <p>Se realizar\u00e1 una revisi\u00f3n del sprint de 15 minutos en las   clases de pr\u00e1cticas y teor\u00eda del 20 de diciembre. La revisi\u00f3n   constar\u00e1 de:</p> <ul> <li>Presentaci\u00f3n con diapositivas en la que se explicar\u00e1 la   metodolog\u00eda seguida en el sprint, las nuevas   funcionalidades introducidas y la puesta en producci\u00f3n de la   nueva versi\u00f3n.</li> <li>Demostraci\u00f3n de las nuevas funcionalidades utilizando la \u00faltima   versi\u00f3n puesta en producci\u00f3n.</li> </ul> <p>El proyecto debe estar terminado el 20 de diciembre</p> <p>En la fecha de la presentaci\u00f3n debe estar completo el nuevo release 1.4.0 del proyecto y debe estar puesto en producci\u00f3n. Despu\u00e9s de la presentaci\u00f3n no podr\u00e9is a\u00f1adir m\u00e1s c\u00f3digo al proyecto. El tiempo restante hasta el 11 de enero es para que termin\u00e9is la documentaci\u00f3n.</p> </li> <li> <p>En la fecha l\u00edmite del 12 de enero deber\u00e1 entregar la pr\u00e1ctica y   tener disponible:</p> <ul> <li>Directorio <code>doc</code> en el repositorio del proyecto en el que se   incluir\u00e1 un documento PDF con la memoria de la   pr\u00e1ctica y un PDF con las diapositivas presentadas en la   demo. En la memoria de la pr\u00e1ctica se incluir\u00e1:<ul> <li>Sprint Backlog: historias de usuario escogidas para el   sprint (copiar la descripci\u00f3n, las condiciones de   satisfacci\u00f3n y el borrador de interfaz de usuario tal y   como aparecen en los documentos subidos a GoogleDocs).</li> <li>Funcionalidades implementadas: breve descripci\u00f3n para el   usuario y breve descripci\u00f3n t\u00e9cnica.</li> <li>Puesta en producci\u00f3n: script de migraci\u00f3n de la base de   datos y breve informe de la puesta en producci\u00f3n.</li> <li>Informe sobre la evoluci\u00f3n del desarrollo: instant\u00e1neas   de los tableros y alguna m\u00e9trica o gr\u00e1fica sobre el desarrollo   (n\u00famero de pull requests cada semana, por ejemplo).</li> <li>Informe sobre las sesiones de pair programming: breve informe de   cada sesi\u00f3n de pair programming explicando c\u00f3mo se ha desarrollado la   sesi\u00f3n y vuestra impresi\u00f3n personal de la pr\u00e1ctica de pair programming   despu\u00e9s de haberla probado.</li> <li>Resultado de la retrospectiva: qu\u00e9 ha ido bien en el   sprint y qu\u00e9 se podr\u00eda mejorar en el siguiente sprint.</li> </ul> </li> <li>El repositorio GitHub deber\u00e1 incluir el tablero con el backlog   del sprint con los issues completados.</li> <li>El tablero de Trello deber\u00e1 incluir el backlog del producto con   las historias de usuario que se deb\u00edan implementar en el sprint   y los enlaces a los documentos Google Docs con sus detalles.</li> <li>Entrega en Moodle la \u00faltima versi\u00f3n del proyecto subida a   GitHub.</li> </ul> </li> </ul> <p>La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas (1 punto en la nota final).</p> <p>La evaluaci\u00f3n se basar\u00e1 en: </p> <ul> <li>Desarrollo continuo de los issues</li> <li>Complejidad de las funcionalidades a\u00f1adidas</li> <li>Correcci\u00f3n del c\u00f3digo</li> <li>Correcto funcionamiento</li> <li>Informe de la pr\u00e1ctica</li> <li>Si el trabajo de alg\u00fan miembro del equipo es significativamente de   menor calidad y/o cantidad que el del resto, se penalizar\u00e1 su   calificaci\u00f3n</li> </ul> <p>A la nota anterior se le sumar\u00e1 una puntaci\u00f3n extra de hasta 0,5 puntos en la nota final que se basar\u00e1 en la demostraci\u00f3n realizada, las funcionalidades implementadas, su coherencia y usabilidad. </p> <p>Al final de la sesi\u00f3n de presentaciones se publicar\u00e1 esta puntuaci\u00f3n extra, que se sumar\u00e1 directamente a la nota final de la asignatura de todos los miembros de los equipos.</p>"},{"location":"06-practica-c4/practica-c4.html","title":"Pr\u00e1ctica extraordinaria para la convocatoria C4","text":""},{"location":"06-practica-c4/practica-c4.html#aplicacion-a-desarrollar","title":"Aplicaci\u00f3n a desarrollar","text":"<p>Debes desarrollar una aplicaci\u00f3n similar a ToDoList. Por ejemplo, una gesti\u00f3n de recetas, una gesti\u00f3n de los libros de tu biblioteca, etc.</p> <p>La aplicaci\u00f3n debe tener como m\u00ednimo:</p> <ul> <li>Login y registro de usuarios</li> <li>Acceso autorizado a p\u00e1ginas de consultas y actualizaci\u00f3n</li> <li>Un m\u00ednimo de tres entidades, con al menos una relaci\u00f3n uno-a-muchos   y una relaci\u00f3n muchos-a-muchos.</li> </ul> <p>Para el desarrollo de la aplicaci\u00f3n deber\u00e1s usar las mismas tecnolog\u00edas que en la pr\u00e1ctica ToDoList: SpringBoot, Thymeleaf, Hibernate.</p> <p>El total de puntos de historias de usuario deber\u00e1 ser similar a los realizados la pr\u00e1ctica de la convocatoria ordinaria, alrededor de 20 puntos.</p> <ul> <li>Historias relacionadas con la gesti\u00f3n b\u00e1sica de recetas, libros,   etc. (alrededor de 8 puntos).</li> <li>Historias  relacionadas con la gesti\u00f3n de usuarios (alrededor de 4 puntos).</li> <li>Historias adicionales que incluyan la relaci\u00f3n muchos-a-muchos   (alrededor de 8 puntos).</li> </ul>"},{"location":"06-practica-c4/practica-c4.html#repositorio-en-github","title":"Repositorio en GitHub","text":"<p>A diferencia de la pr\u00e1ctica 1 en la que us\u00e1bamos Github Classroom, deber\u00e1s crear tu mismo el repositorio con una aplicaci\u00f3n b\u00e1sica de Spring Boot. Puedes empezar haciendo un fork del repositorio domingogallardo/spring-boot-demoapp y a\u00f1adir las dependencias necesarias para trabajar con Hibernate y con la base de datos H2 (consultar el repositorio inicial de la pr\u00e1ctica domingogallardo/mads-todolist-inicial).</p>"},{"location":"06-practica-c4/practica-c4.html#metodologia-de-desarrollo","title":"Metodolog\u00eda de desarrollo","text":"<p>Deber\u00e1s usar la misma metodolog\u00eda que la usada en las pr\u00e1cticas de la convocatoria ordinaria. Consulta los apuntes de las pr\u00e1cticas.</p> <p>En concreto, deber\u00e1s las siguientes metodolog\u00edas desde el principio del desarrollo de la pr\u00e1ctica:</p> <ul> <li>Flujo de trabajo GitFlow con Pull Requests (como en la pr\u00e1ctica 3).</li> <li>GitHub actions y al menos 2 historias de usuario realizadas con TDD (similar a la pr\u00e1ctica 2).</li> <li>Historias  de usuario en Trello, descripci\u00f3n extendida de cada historia de   usuario en Google Docs, tablero de issues en GitHub y dividir cada   historia de usuario en uno o m\u00e1s issues.</li> </ul> <p>El repositorio GitHub se debe compartir con el profesor de la asignatura (usuario: domingogallardo, e-mail: domingo.gallardo@ua.es).</p> <p>El tablero Trello debe ser p\u00fablico y debes incluir su enlace en el README del repositorio.</p>"},{"location":"06-practica-c4/practica-c4.html#entrega","title":"Entrega","text":"<p>La fecha de entrega es la fecha del examen oficial de la convocatoria C4 (10/07/2023)</p> <p>Se habilitar\u00e1 una entrega en Moodle, en la que se debe subir un documento PDF con:</p> <ul> <li>Explicaci\u00f3n t\u00e9cnica de la aplicaci\u00f3n (debe incluir al menos una   descripci\u00f3n de las entidades y de los m\u00e9todos de servicio   definidos).</li> <li>Explicaci\u00f3n de las funcionalidades introducidas (pueden ser las   descripciones extendidas de cada historia de usuario).</li> <li>Enlace al tablero Trello</li> <li>Enlace al repositorio GitHub</li> </ul>"}]}