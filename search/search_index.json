{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Pr\u00e1cticas de la asignatura Metodolog\u00edas \u00c1giles de Desarrollo de Software de la Universidad de Alicante. Pr\u00e1ctica 1 Enunciado de la pr\u00e1ctica Introducci\u00f3n a Spring Boot Resumen de comandos Git Pr\u00e1ctica 2 Pr\u00e1ctica 3 Pr\u00e1ctica 4 Pr\u00e1ctica 5 Construido con MkDocs \u00b6 Versi\u00f3n HTML compilada usando el tema Material de MkDocs . Repositorio en GitHub .","title":"Index"},{"location":"01-intro-spring-boot/comandos-git.html","text":"Resumen de comandos Git \u00b6 Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi). 1. Comandos b\u00e1sicos \u00b6 Configurar el usuario y direcci\u00f3n de correo en git: $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com Inicializar git en un directorio: $ cd /ruta/a/mi/directorio $ git config --global user.name <nombre-usuario> $ git config --global user.email <email> $ git init $ git add . $ git commit -m \"Versi\u00f3n inicial\" Publicar por primera vez el repositorio local en el remoto (en GitHub): $ git remote add origin <url-repo>.git $ git push -u origin main El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama main (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): $ git add <fichero o directorio> El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : $ git commit -m \"Mensaje\" Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): $ git reset HEAD <fichero> Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: $ git commit -a -m \"Mensaje\" Se puede abreviar como $ git commit -am \"Mensaje\"` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: $ git reset --hard HEAD $ git clean -fd (si se ha a\u00f1adido alg\u00fan fichero) Publicar los cambios en el repositorio remoto: $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). $ git log [--oneline] [--graph] [--all] Comprobar las diferencias entre dos commits: $ git diff <hash-previo> <hash-nuevo> Devuelve las cambios que se han introducido desde el commit identificado por y hasta el . 2. Ramas \u00b6 Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: $ git checkout -b nueva-rama M hola.txt (si hay cambios en el espacio de trabajo se llevan a la nueva rama) Switched to a new branch 'nueva-rama' Listar todas las ramas de un repositorio (incluyendo ramas remotas) $ git branch -av main * nueva-rama $ git commit -a -m \"Confirmamos los cambios en la nueva rama\" Moverse a otra rama: $ git checkout main Switched to branch 'main' Mostrar un fichero de una rama (o commit) dado: $ git show <commit o rama>:<nombre-fichero> Comparar dos ramas: $ git diff main nueva-rama El comando git diff main nueva-rama devuelve las diferencias entre las ramas main y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama main . Merge de ramas : Mezclar la rama nueva-rama en la rama main (a\u00f1ade a la main los commits adicionales de la rama nueva-rama ): $ git checkout main $ git merge [--no-ff] nueva-rama -m \"Mensaje de commit\" La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. $ git merge nueva-rama CONFLICT (content): Merge conflict in hola.txt Automatic merge failed; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m \"Arreglado el conflicto en el merge\" $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama main ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : $ git checkout -b experiment # hacemos cambios $ git commit -m \"Cambios en experiment\" $ git checkout main # hacemos cambios $ git commit -a -m \"Cambios en main\" $ git checkout experiment $ git rebase main First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama main ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. \u00a1Cuidado! No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama main y tener una historia lineal: $ git checkout main $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : $ git rebase main CONFLICT (content): Merge conflict in <some-file> # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use \"git reset HEAD <some-file>...\" to unstage) # (use \"git add/rm <some-file>...\" as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add <some-file> $ git rebase --continue Nota Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: $ git log --graph --oneline Borrar una rama: $ git branch -d nueva-rama Deleted branch nueva-rama (was c241d7b) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: $ git branch -D rama Subir una rama al repositorio remoto: $ git push -u origin <rama> Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) $ git fetch $ git checkout -b <rama> origin/<rama> Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) $ git remote show origin Subir todas las ramas y etiquetas: $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: $ git push origin --delete <branchName> 3. Modificar la historia \u00b6 Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: $ git commit --amend [--m \"Nuevo mensaje\"] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: $ git checkout <hash> (o tag, por ejemplo v2.0) You are in 'detached HEAD' state. # Ahora est\u00e1s en un detached HEAD $ git branch * (HEAD detached at 594b606) main $ git checkout -b v2.0.1 Switched to a new branch 'v2.0.1' $ git branch main * v2.0.1 $ git checkout main Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) $ git reset --hard <hash> 4. M\u00e1s informaci\u00f3n \u00b6 Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"Resumen de comandos Git"},{"location":"01-intro-spring-boot/comandos-git.html#resumen-de-comandos-git","text":"Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2. Al final del documento se incluyen enlaces a apartados del libro Pro Git . Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi).","title":"Resumen de comandos Git"},{"location":"01-intro-spring-boot/comandos-git.html#1-comandos-basicos","text":"Configurar el usuario y direcci\u00f3n de correo en git: $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com Inicializar git en un directorio: $ cd /ruta/a/mi/directorio $ git config --global user.name <nombre-usuario> $ git config --global user.email <email> $ git init $ git add . $ git commit -m \"Versi\u00f3n inicial\" Publicar por primera vez el repositorio local en el remoto (en GitHub): $ git remote add origin <url-repo>.git $ git push -u origin main El nombre del repositorio remoto ser\u00e1 origin (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama main (la rama por defecto que se crea al inicializar el repositorio local). Comprobar el estado del repositorio local: $ git status Comprobar las diferencias entre los ficheros modificados en el directorio de trabajo y el \u00faltimo commit: $ git diff A\u00f1adir un fichero al stage (a\u00f1adirlo para el pr\u00f3ximo commit): $ git add <fichero o directorio> El \u00e1rea de stage tambi\u00e9n se llama el index . Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento: Hacer un commit de los ficheros en el stage : $ git commit -m \"Mensaje\" Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final decidimos no a\u00f1adirlo en el siguiente commit): $ git reset HEAD <fichero> Se puede combinar en un \u00fanico comando el add y el commit en ficheros ya a\u00f1adidos al control de versiones: $ git commit -a -m \"Mensaje\" Se puede abreviar como $ git commit -am \"Mensaje\"` Eliminar todos los cambios realizados en el directorio, volviendo al \u00faltimo commit: $ git reset --hard HEAD $ git clean -fd (si se ha a\u00f1adido alg\u00fan fichero) Publicar los cambios en el repositorio remoto: $ git push Consultar los mensajes de los commits (toda la historia de la rama actual). La opci\u00f3n --oneline muestra s\u00f3lo la primera l\u00ednea del mensaje, la opci\u00f3n --graph muestra el grafo de dependencias y la opci\u00f3n --all muestra el grafo completo, no s\u00f3lo aquel en el que estamos ( HEAD ). $ git log [--oneline] [--graph] [--all] Comprobar las diferencias entre dos commits: $ git diff <hash-previo> <hash-nuevo> Devuelve las cambios que se han introducido desde el commit identificado por y hasta el .","title":"1. Comandos b\u00e1sicos"},{"location":"01-intro-spring-boot/comandos-git.html#2-ramas","text":"Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia HEAD la rama actual. Crear una rama nueva: $ git checkout -b nueva-rama M hola.txt (si hay cambios en el espacio de trabajo se llevan a la nueva rama) Switched to a new branch 'nueva-rama' Listar todas las ramas de un repositorio (incluyendo ramas remotas) $ git branch -av main * nueva-rama $ git commit -a -m \"Confirmamos los cambios en la nueva rama\" Moverse a otra rama: $ git checkout main Switched to branch 'main' Mostrar un fichero de una rama (o commit) dado: $ git show <commit o rama>:<nombre-fichero> Comparar dos ramas: $ git diff main nueva-rama El comando git diff main nueva-rama devuelve las diferencias entre las ramas main y nueva-rama : las modificaciones que resultar\u00edan de mezclar la rama nueva-rama en la rama main . Merge de ramas : Mezclar la rama nueva-rama en la rama main (a\u00f1ade a la main los commits adicionales de la rama nueva-rama ): $ git checkout main $ git merge [--no-ff] nueva-rama -m \"Mensaje de commit\" La opci\u00f3n --no-ff no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio. Si en la rama que se mezcla y en la actual hay cambios que afectan a las mismas l\u00edneas de un fichero, git detecta un conflicto y combina esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n de la procedencia. Debemos resolver el conflicto: editarlos a mano y volver a hacer add y commit. $ git merge nueva-rama CONFLICT (content): Merge conflict in hola.txt Automatic merge failed; fix conflicts and then commit the result. # editar a mano el fichero con conflictos $ git commit -a -m \"Arreglado el conflicto en el merge\" $ git merge nueva-rama El comando git status despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente. Rebase de una rama . Si la rama main ha avanzado despu\u00e9s de separar una rama alternativa y queremos incorporar esos cambios en la rama alternativa podemos hacer un git rebase : $ git checkout -b experiment # hacemos cambios $ git commit -m \"Cambios en experiment\" $ git checkout main # hacemos cambios $ git commit -a -m \"Cambios en main\" $ git checkout experiment $ git rebase main First, rewinding head to replay your work on top of it... Applying: Corregido bug1 Applying: Corregido bug2 El comando cambia la historia de la rama: primero la mueve al final de la rama main ( rewind head ) y a partir de ah\u00ed aplica los cambios propios de la rama. \u00a1Cuidado! No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos. Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama main y tener una historia lineal: $ git checkout main $ git merge nueva-rama # Borramos la rama una vez mezclada $ git branch -d nueva-rama Igual que en el merge , al hacer un rebase pueden aparecer conflictos al hacer el rebase , basta con modificar los ficheros con conflictos, a\u00f1adirlos y continuar el rebase : $ git rebase main CONFLICT (content): Merge conflict in <some-file> # hacemos git status para comprobar donde est\u00e1n los conflictos $ git status # Unmerged paths: # (use \"git reset HEAD <some-file>...\" to unstage) # (use \"git add/rm <some-file>...\" as appropriate to mark resolution) # # Editamos los ficheros para corregir los conflictos $ git add <some-file> $ git rebase --continue Nota Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase . Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento. Log en forma de grafo: $ git log --graph --oneline Borrar una rama: $ git branch -d nueva-rama Deleted branch nueva-rama (was c241d7b) S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras. Borrar una rama descartando sus commits: $ git branch -D rama Subir una rama al repositorio remoto: $ git push -u origin <rama> Descargar una rama del repositorio remoto (origin, por ejemplo, el repositorio remoto por defecto) $ git fetch $ git checkout -b <rama> origin/<rama> Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo) $ git remote show origin Subir todas las ramas y etiquetas: $ git push -u -all origin Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer git push para subir los cambios en cualquiera de las ramas presentes. Borrar una rama en repositorio remoto: $ git push origin --delete <branchName>","title":"2. Ramas"},{"location":"01-intro-spring-boot/comandos-git.html#3-modificar-la-historia","text":"Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a mano: $ git commit --amend [--m \"Nuevo mensaje\"] Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage ): $ git reset --soft HEAD^ Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge: $ git reset --merge ORIG_HEAD Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una nueva rama all\u00ed (o no) y volver al commit actual: $ git checkout <hash> (o tag, por ejemplo v2.0) You are in 'detached HEAD' state. # Ahora est\u00e1s en un detached HEAD $ git branch * (HEAD detached at 594b606) main $ git checkout -b v2.0.1 Switched to a new branch 'v2.0.1' $ git branch main * v2.0.1 $ git checkout main Movernos atr\u00e1s a un commit pasado, descartando todos los commits realizados despu\u00e9s ( peligroso ) $ git reset --hard <hash>","title":"3. Modificar la historia"},{"location":"01-intro-spring-boot/comandos-git.html#4-mas-informacion","text":"Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos: Pro Git - Recording Changes to the Repository Pro Git - Basic Branching and Merging Pro Git - Git Branching - Rebasing Tutorial de Atlassian - Merging vs. Rebasing Pro Git - Reset Demystified","title":"4. M\u00e1s informaci\u00f3n"},{"location":"01-intro-spring-boot/intro-spring-boot.html","text":"Introducci\u00f3n a Spring Boot \u00b6 Vamos a trabajar con la versi\u00f3n 2.6.10 de Spring Boot. Se puede consultar toda la documentaci\u00f3n oficial sobre esta versi\u00f3n en este enlace . 1. Aplicaci\u00f3n ejemplo \u00b6 Es muy sencillo crear aplicaciones de Spring Boot desde cero usando la web Spring initializr . En esa p\u00e1gina puedes configurar los metadatos del proyecto y sus dependencias y descargar el proyecto como un ZIP con la estructura de directorios y el POM ya configurados. Nosotros vamos a hacerlo m\u00e1s f\u00e1cil todav\u00eda usando una aplicaci\u00f3n ejemplo en GitHub domingogallardo/spring-boot-demoapp . La aplicaci\u00f3n es un sencillo Hola mundo . En los siguientes apartados explicamos c\u00f3mo lanzarla y c\u00f3mo funciona. 2. Ejecuci\u00f3n de aplicaciones Spring Boot \u00b6 Spring Boot permite ejecutar aplicaciones Spring de forma standalone , sin necesidad de un servidor de aplicaciones. Una aplicaci\u00f3n Spring Boot lleva incluido un servidor web embebido (Tomcat) que se pone en marcha al lanzar la aplicaci\u00f3n y sirve todas las p\u00e1ginas de la aplicaci\u00f3n web. Para lanzar una aplicaci\u00f3n Spring Boot es suficiente tener instalados: JDK Java (8 en adelante) Maven Maven incluso no es necesario si la aplicaci\u00f3n Spring Boot lo tiene ya instalado utilizando Maven Wrapper , como es el caso de la aplicaci\u00f3n ejemplo. Desde el directorio donde est\u00e1 la aplicaci\u00f3n que queremos lanzar podemos arrancarla como una aplicaci\u00f3n Java. Podemos llamar a mvn si tenemos instalado Maven o a ./mvnw para usar Maven Wrapper: $ ./mvnw package $ java -jar target/demoapp-0.0.1-SNAPSHOT.jar Tambi\u00e9n podemos lanzarla usando el plugin spring-boot de Maven: $ ./mvnw spring-boot:run La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio. En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas: http://localhost:8080 http://localhost:8080/saludo/Pepito http://localhost:8080/saludoplantilla/Pepito http://localhost:8080/saludoform 3. Desarrollo y ejecuci\u00f3n con IntelliJ \u00b6 Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Para abrir un proyecto Spring Boot en IntelliJ basta con abrir el directorio donde se encuentre el fichero pom.xml . Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Open o usando la opci\u00f3n File > Open\" o \"File > New > Project from Existing Sources . IntelliJ abre el proyecto correctamente: Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n: Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc: 4. Conceptos de Spring Boot \u00b6 Estructura de la aplicaci\u00f3n \u00b6 Estructura de directorios t\u00edpica de los proyectos Java construidos con Maven: El fichero pom.xml declara las dependencias. Spring Boot proporciona starters que agrupan un conjunto de dependencias comunes. Fichero pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> es.ua.mads </groupId> <artifactId> demoapp </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> demoapp </name> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 2.6.10 </version> </parent> <properties> <java.version> 1.8 </java.version> </properties> <dependencies> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-thymeleaf </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-validation </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <configuration> <argLine> -Dfile.encoding=UTF8 </argLine> </configuration> </plugin> </plugins> </build> </project> En el panel de Maven de IntelliJ se puede consultar las librer\u00edas concretas que se han descargado: En el fichero de configuraci\u00f3n de la aplicaci\u00f3n se definen propiedades que configuran distintos aspectos de la misma, como la base de datos con la que se va a trabajar o el puerto en el que debe ejecutarse. Conforme necesitemos configurar estas propiedades iremos a\u00f1adiendo elementos al fichero. Fichero resources/application.properties spring.application.name = demoapp Controladores \u00b6 Los controladores definen el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Son clases que se suelen colocar en el paquete controller y est\u00e1n anotadas con @Controller . Vemos un ejemplo en la clase SaludoController . Fichero src/main/java/demoapp/controller/SaludoController.java : package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.ResponseBody ; @Controller public class SaludoController { @Autowired private SaludoService service ; @RequestMapping ( \"/saludo/{nombre}\" ) public @ResponseBody String saludo ( @PathVariable ( value = \"nombre\" ) String nombre ) { return service . saluda ( nombre ); } } Los m\u00e9todos en los que se definen las respuestas a las peticiones HTTP est\u00e1n anotados con anotaciones en las que se indica el tipo de petici\u00f3n y la URL a la que se responde. Por ejemplo, en la clase anterior el m\u00e9todo saludo contesta a las peticiones dirigida a la URL /saludo/Ana . La cadena Ana en la URL es decodificada y pasada en el par\u00e1metro nombre al m\u00e9todo. El m\u00e9todo devuelve la respuesta HTTP. La anotaci\u00f3n @ResponseBody construye autom\u00e1ticamente esta respuesta, a\u00f1adiendo como contenido de la misma la cadena devuelta por el servicio. En este caso la respuesta es: HTTP/1.1 200 Content-Type: text/plain;charset=UTF-8 Content-Length: 8 Date: Mon, 02 Sep 2019 14:59:04 GMT Hola Ana Clases de Servicio \u00b6 Es recomendable definir clases de servicio en las que se implementa la l\u00f3gica de negocio de la aplicaci\u00f3n. Las clases controller llaman a las clases servicio, que son las que realmente realizan todo el procesamiento. De esta forma se separan las responsabilidades. Las clases controller se encargan de procesar las peticiones y las respuestas HTTP y las clases de servicio son las que realmente realizan la l\u00f3gica de negocio y devuelven el contenido de las respuestas. Si en alg\u00fan momento hay que a\u00f1adir una nueva capa de presentaci\u00f3n en la que, por ejemplo, se trabaje con objetos JSON, no ser\u00e1 necesario cambiar la capa de servicios, s\u00f3lo a\u00f1adir nuevas clases controller . La separaci\u00f3n de la l\u00f3gica de negocio en las clases de servicio permite tambi\u00e9n realizar tests que trabajan sobre objetos Java, independientes de los formatos de entrada/salida manejados por los controladores. Fichero src/main/java/demoapp/service/SaludoService.java package demoapp.service ; import org.springframework.stereotype.Service ; @Service public class SaludoService { public String saluda ( String nombre ) { return \"Hola \" + nombre ; } } Inyecci\u00f3n de dependencias en Spring \u00b6 Spring Boot utiliza la anotaci\u00f3n @Autowired para inyectar en la variable anotada un objeto nuevo del tipo indicado. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. Hemos utilizado la anotaci\u00f3n en las variables de instancia. En los ejemplos anteriores podemos comprobar estas anotaciones. En la aplicaci\u00f3n ejemplo se define un controlador y un servicio que devuelve un saludo. El servicio se anota con la anotaci\u00f3n @Service y esta anotaci\u00f3n le indica a Spring Boot que la clase que va a poder ser inyectada. En el controlador se necesita instanciar un objeto de la clase SaludoService y se hace usando inyecci\u00f3n de dependencias. Spring Boot se encarga de obtener una instancia y de inyectarla en la variable cuando se inicializa el controlador. Lo vemos en el siguiente c\u00f3digo: @Controller public class SaludoController { @Autowired private SaludoService service ; @RequestMapping ( \"/saludo/{nombre}\" ) public @ResponseBody String saludo ( @PathVariable ( value = \"nombre\" ) String nombre ) { return service . saluda ( nombre ); } } Mediante la inyecci\u00f3n de dependencias el c\u00f3digo es m\u00e1s flexible y es m\u00e1s f\u00e1cil de testear, pudi\u00e9ndose definir mocks que sustituyen los objetos inyectados. M\u00e1s informaci\u00f3n en la documentaci\u00f3n de Spring Boot Spring Beans and Dependency Injection . Alcance de los objetos inyectados \u00b6 Por defecto el alcance ( scope ) de todas las anotaciones de Spring ( @service , @controller , @component , etc.) es un Singleton . Existe una \u00fanica instancia de ese objeto que es la que se inyecta en las variables. Al estar funcionando en una aplicaci\u00f3n web, el singleton que hace de controlador recibir\u00e1 m\u00faltiples peticiones concurrentemente. Cada petici\u00f3n ir\u00e1 en su propio hilo de Java, por lo que m\u00faltiples hilos podr\u00e1n estar ejecutando el mismo c\u00f3digo del controlador. Por ello hay que tener cuidado en no definir variables de instancia mutables (con estado) dentro del controlador (con excepci\u00f3n de los objetos inyectados con la anotaci\u00f3n @Autowired ), porque podr\u00edan producirse errores debidos a condiciones de carrera (un hilo modifica la misma variable que otro est\u00e1 leyendo). Es conveniente que todos los beans (controladores, servicios, etc.) sean objetos sin estado. Tambi\u00e9n es posible definir otros alcances, como @RequestScope o @SessionScope . En el primer caso se crea una instancia nueva del objeto para cada petici\u00f3n HTTP y en el segundo se crea una instancia nueva en cada sesi\u00f3n HTTP. Puedes encontrar m\u00e1s informaci\u00f3n y ejemplos en este enlace . Plantillas Thymeleaf \u00b6 Las p\u00e1ginas HTML devueltas se pueden construir utilizando un lenguaje de plantillas con el framework Thymeleaf . Las plantillas thymeleaf son p\u00e1ginas HTML en las que se introducen objetos Java pasados por los controllers. Las plantillas se incluyen en el directorio resources/templates . Por ejemplo, el siguiente fichero es una sencilla plantilla que muestra un saludo. El objeto mensaje es una cadena que se pasa desde el controller. Fichero src/main/resources/templates/saludo.html <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < h1 th:text = \"'Saludo: ' + ${mensaje}\" > </ h1 > </ html > El controller construye la vista devolviendo el nombre de la plantilla. Y pasa a la plantilla los objetos a mostrar usando un diccionario (la variable model que recibe como par\u00e1metro): Fichero src/main/java/demoapp/controller/SaludoControllerPlantilla.java package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; @Controller public class SaludoControllerPlantilla { @Autowired private SaludoService service ; @RequestMapping ( \"/saludoplantilla/{nombre}\" ) public String saludo ( @PathVariable ( value = \"nombre\" ) String nombre , Model model ) { // Se a\u00f1ade la respuesta a la clave 'mensaje' que se usa // en la plantilla model . addAttribute ( \"mensaje\" , service . saluda ( nombre )); // Se llama a la plantilla 'saludo.html' return \"saludo\" ; } } Formularios y validaci\u00f3n \u00b6 Spring Boor simplifica la declaraci\u00f3n y validaci\u00f3n de formularios usando clases Java que trabajan como modelos del formulario. Por ejemplo, en la aplicaci\u00f3n se define la clase UserData : Fichero src/main/java/demoapp/controller/UserData.java package demoapp.controller ; import javax.validation.constraints.Size ; public class UserData { @Size ( min = 3 , max = 30 ) String nombre ; public void setNombre ( String nombre ) { this . nombre = nombre ; } public String getNombre () { return nombre ; } } Se trata de un objeto con el campo nombre de tipo String al que se le ha a\u00f1adido una anotaci\u00f3n de validaci\u00f3n @Size con el tama\u00f1o m\u00ednimo y m\u00e1ximo que debe tener. Puedes encontrar m\u00e1s informaci\u00f3n sobre otros atributos de validaci\u00f3n en este enlace . El formulario HTML propiamente dicho se define con una plantilla thymeleaf en la que se declara un objeto que tiene el mismo nombre que el nombre de la clase modelo, pero con la primera letra en min\u00fascula. En nuestro caso la clase modelo es UserData , por lo que el objeto del formulario debe llamarse userData . En el formulario podemos usar cualquier campo definido en el objeto modelo. En nuestro caso usamos el \u00fanico campo de tipo String , nombre . Fichero src/main/resources/templates/formRegistro.html <!DOCTYPE HTML> < html xmlns:th = \"http://www.thymeleaf.org\" > < body > < form th:action = \"@{/saludoform}\" th:object = \"${userData}\" method = \"post\" > < table > < tr > < td > Nombre: </ td > < td >< input type = \"text\" th:field = \"*{nombre}\" /></ td > < td th:if = \"${#fields.hasErrors('nombre')}\" th:errors = \"*{nombre}\" ></ td > </ tr > < tr > < td >< button type = \"submit\" > Enviar </ button ></ td > </ tr > </ table > </ form > </ body > </ html > Se define una acci\u00f3n que enviar\u00e1 una petici\u00f3n POST a la URL /saludoform con los datos del formulario. En este caso el nombre. Por \u00faltimo, el controller que lanza el formulario y el que recibe la petici\u00f3n POST con los datos introducidos se definen en el siguiente fichero: Fichero src/main/java/demoapp/controller/SaludoControllerForm.java package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.validation.BindingResult ; import org.springframework.web.bind.annotation.* ; import javax.validation.Valid ; @Controller public class SaludoControllerForm { @Autowired private SaludoService service ; @GetMapping ( \"/saludoform\" ) // Hay que declarar un par\u00e1metro con el tipo usado en el modelo del formulario (UserData) public String saludoForm ( UserData userData ) { return \"formRegistro\" ; } @PostMapping ( \"/saludoform\" ) public String checkPersonInfo ( @ModelAttribute @Valid UserData userData , BindingResult bindingResult , Model model ) { if ( bindingResult . hasErrors ()) { return \"formRegistro\" ; } model . addAttribute ( \"mensaje\" , service . saluda ( userData . getNombre ())); return \"saludo\" ; } } El m\u00e9todo que recibe la petici\u00f3n en /saludoform simplemente devuelve la plantilla con el formulario. Y el m\u00e9todo que recibe los datos es el que responde a la petici\u00f3n POST en la URL /saludoform recibe los datos del formulario en un objeto Java del tipo del modelo del formulario (el par\u00e1metro userData ). Las anotaciones @ModelAttribute y @Valid indican que es un objeto recogido en el formulario sobre el que se ha realizado una validaci\u00f3n. Se detecta si ha habido alg\u00fan error en el m\u00e9todo hasErrors() del bindingResult que se recibe tambi\u00e9n como par\u00e1metro. Si ha habido error, se vuelve a devolver el formulario para que se vuelva a completar. Si no ha habido error se obtiene el nombre introducido en el formulario y se pasa a la plantilla del saludo. Tests \u00b6 A partir de Spring Boot 2.4 se usa JUnit 5 como librer\u00eda de tests. En la aplicaci\u00f3n de demostraci\u00f3n hay varios ejemplos que muestran posibles formas de realizar pruebas en una aplicaci\u00f3n Spring Boot. Spring Boot incluye el framework AssertJ que permite realizar expresiones de prueba con un lenguaje muy expresivo. Los tests se pueden ejecutar usando el comando t\u00edpico de Maven: $ mvn test O tambi\u00e9n, usando el comando de Maven Wrapper: $ ./mvnw test Tambi\u00e9n se pueden lanzar desde el propio IntelliJ, pulsando en el panel del proyecto sobre el directorio de tests con el bot\u00f3n derecho. Los tests se lanzar\u00e1n y aparecer\u00e1 un panel en el que se mostrar\u00e1 si pasan correctamente (verde) o no. Tests sobre clases de servicio \u00b6 Podemos realizar pruebas sobre la capa de servicio, obteniendo una instancia del servicio mediante inyecci\u00f3n de dependencias. En el siguiente ejemplo se muestra c\u00f3mo se prueba el m\u00e9todo de servicio saluda . Fichero src/test/java/demoapp/ServiceTest.java package demoapp ; import demoapp.service.SaludoService ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import static org.assertj.core.api.Assertions.assertThat ; @SpringBootTest public class ServiceTest { @Autowired SaludoService saludo ; @Test public void contexLoads () throws Exception { assertThat ( saludo ). isNotNull (); } @Test public void serviceSaludo () throws Exception { assertThat ( saludo . saluda ( \"Domingo\" )). isEqualTo ( \"Hola Domingo\" ); } } Tests sobre capa web \u00b6 Es posible realizar tests sobre la capa de presentaci\u00f3n sin lanzar realmente el servidor web ni ejecutar realmente las peticiones HTTP. Se obtiene por inyecci\u00f3n de dependencias un mock de la clase MockMvc y se usan m\u00e9todos como perform(get(\"/\")) o perform(post(\"/saludoform\").param(\"nombre\", \"Domingo\")) . En el primer test del ejemplo siguiente se comprueba que una petici\u00f3n GET a la URL / devuelve un c\u00f3digo HTTP OK (200) y una p\u00e1gina HTML con la cadena esperada. En este test lo \u00fanico que se moquea es el servidor web, y se ejecuta el c\u00f3digo real del servicio, del controlador y de la plantilla. Se utilizan los m\u00e9todos andDo y andExpect de la propia librer\u00eda de testeo de Spring Framework y el m\u00e9todo conteainsString de la librer\u00eda de testeo Hamcrest . En el segundo test se realiza una petici\u00f3n POST para comprobar que el formulario funciona correctamente. Fichero src/test/demoapp/MockMvcTest.java package demoapp ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.web.servlet.MockMvc ; import static org.hamcrest.Matchers.containsString ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status ; @SpringBootTest @AutoConfigureMockMvc public class MockMvcTest { @Autowired private MockMvc mockMvc ; // Hacemos una petici\u00f3n GET a un end point y comprobamos que // el HTML resultante es correcto @Test public void shouldReturnDefaultMessage () throws Exception { this . mockMvc . perform ( get ( \"/\" )) . andExpect ( status (). isOk ()) . andExpect ( content (). string ( containsString ( \"Hello World\" ))); } // Podemos hacer tambi\u00e9n una petici\u00f3n POST y pasar los datos // del formulario con el m\u00e9todo .param @Test public void postShoudReturnCorrectResponse () throws Exception { this . mockMvc . perform ( post ( \"/saludoform\" ) . param ( \"nombre\" , \"Domingo\" )) . andExpect ( status (). isOk ()) . andExpect ( content (). string ( containsString ( \"Hola Domingo\" ))); } } Tambi\u00e9n es posible realizar un test \u00fanicamente del controlador y la plantilla de presentaci\u00f3n, moqueando el servicio. Se muestra en el fichero MockServiceTest . Fichero src/test/demoapp/MockServiceTest.java package demoapp ; import demoapp.service.SaludoService ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.mock.mockito.MockBean ; import org.springframework.test.web.servlet.MockMvc ; import static org.hamcrest.Matchers.containsString ; import static org.mockito.Mockito.when ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status ; @SpringBootTest @AutoConfigureMockMvc public class MockServiceTest { @Autowired private MockMvc mockMvc ; // Podemos tambi\u00e9n mockear el servicio @MockBean private SaludoService service ; @Test public void greetingShouldReturnMessageFromService () throws Exception { // Y especificar lo que debe devolver una llamada a uno de sus m\u00e9todos when ( service . saluda ( \"Domingo\" )). thenReturn ( \"Hola Mock Domingo\" ); this . mockMvc . perform ( get ( \"/saludo/Domingo\" )) . andExpect ( status (). isOk ()) . andExpect ( content (). string ( containsString ( \"Hola Mock Domingo\" ))); } } 5. Referencias \u00b6 Puedes encontrar la documentaci\u00f3n de referencia de Spring Boot y Spring en las siguientes p\u00e1ginas, en la pesta\u00f1a Learn : Spring Boot Spring Tambi\u00e9n podemos encontrar tambi\u00e9n una extensa cantidad de tutoriales y gu\u00edas r\u00e1pidas en la web de Spring, en la url https://spring.io/guides . En concreto, hemos usado las siguientes referencias para construir esta primera aplicaci\u00f3n ejemplo: Building an Application with Spring Boot Serving Web Content with Spring MVC Handling Form Submission Validating Form Input Spring Boot Reference Guide 2.6.10 ( HTML , PDF )","title":"Introducci\u00f3n a Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#introduccion-a-spring-boot","text":"Vamos a trabajar con la versi\u00f3n 2.6.10 de Spring Boot. Se puede consultar toda la documentaci\u00f3n oficial sobre esta versi\u00f3n en este enlace .","title":"Introducci\u00f3n a Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#1-aplicacion-ejemplo","text":"Es muy sencillo crear aplicaciones de Spring Boot desde cero usando la web Spring initializr . En esa p\u00e1gina puedes configurar los metadatos del proyecto y sus dependencias y descargar el proyecto como un ZIP con la estructura de directorios y el POM ya configurados. Nosotros vamos a hacerlo m\u00e1s f\u00e1cil todav\u00eda usando una aplicaci\u00f3n ejemplo en GitHub domingogallardo/spring-boot-demoapp . La aplicaci\u00f3n es un sencillo Hola mundo . En los siguientes apartados explicamos c\u00f3mo lanzarla y c\u00f3mo funciona.","title":"1. Aplicaci\u00f3n ejemplo"},{"location":"01-intro-spring-boot/intro-spring-boot.html#2-ejecucion-de-aplicaciones-spring-boot","text":"Spring Boot permite ejecutar aplicaciones Spring de forma standalone , sin necesidad de un servidor de aplicaciones. Una aplicaci\u00f3n Spring Boot lleva incluido un servidor web embebido (Tomcat) que se pone en marcha al lanzar la aplicaci\u00f3n y sirve todas las p\u00e1ginas de la aplicaci\u00f3n web. Para lanzar una aplicaci\u00f3n Spring Boot es suficiente tener instalados: JDK Java (8 en adelante) Maven Maven incluso no es necesario si la aplicaci\u00f3n Spring Boot lo tiene ya instalado utilizando Maven Wrapper , como es el caso de la aplicaci\u00f3n ejemplo. Desde el directorio donde est\u00e1 la aplicaci\u00f3n que queremos lanzar podemos arrancarla como una aplicaci\u00f3n Java. Podemos llamar a mvn si tenemos instalado Maven o a ./mvnw para usar Maven Wrapper: $ ./mvnw package $ java -jar target/demoapp-0.0.1-SNAPSHOT.jar Tambi\u00e9n podemos lanzarla usando el plugin spring-boot de Maven: $ ./mvnw spring-boot:run La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio. En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas: http://localhost:8080 http://localhost:8080/saludo/Pepito http://localhost:8080/saludoplantilla/Pepito http://localhost:8080/saludoform","title":"2. Ejecuci\u00f3n de aplicaciones Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#3-desarrollo-y-ejecucion-con-intellij","text":"Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Para abrir un proyecto Spring Boot en IntelliJ basta con abrir el directorio donde se encuentre el fichero pom.xml . Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Open o usando la opci\u00f3n File > Open\" o \"File > New > Project from Existing Sources . IntelliJ abre el proyecto correctamente: Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n: Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc:","title":"3. Desarrollo y ejecuci\u00f3n con IntelliJ"},{"location":"01-intro-spring-boot/intro-spring-boot.html#4-conceptos-de-spring-boot","text":"","title":"4. Conceptos de Spring Boot"},{"location":"01-intro-spring-boot/intro-spring-boot.html#estructura-de-la-aplicacion","text":"Estructura de directorios t\u00edpica de los proyectos Java construidos con Maven: El fichero pom.xml declara las dependencias. Spring Boot proporciona starters que agrupan un conjunto de dependencias comunes. Fichero pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> es.ua.mads </groupId> <artifactId> demoapp </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> demoapp </name> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 2.6.10 </version> </parent> <properties> <java.version> 1.8 </java.version> </properties> <dependencies> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-thymeleaf </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-validation </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <configuration> <argLine> -Dfile.encoding=UTF8 </argLine> </configuration> </plugin> </plugins> </build> </project> En el panel de Maven de IntelliJ se puede consultar las librer\u00edas concretas que se han descargado: En el fichero de configuraci\u00f3n de la aplicaci\u00f3n se definen propiedades que configuran distintos aspectos de la misma, como la base de datos con la que se va a trabajar o el puerto en el que debe ejecutarse. Conforme necesitemos configurar estas propiedades iremos a\u00f1adiendo elementos al fichero. Fichero resources/application.properties spring.application.name = demoapp","title":"Estructura de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/intro-spring-boot.html#controladores","text":"Los controladores definen el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Son clases que se suelen colocar en el paquete controller y est\u00e1n anotadas con @Controller . Vemos un ejemplo en la clase SaludoController . Fichero src/main/java/demoapp/controller/SaludoController.java : package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.ResponseBody ; @Controller public class SaludoController { @Autowired private SaludoService service ; @RequestMapping ( \"/saludo/{nombre}\" ) public @ResponseBody String saludo ( @PathVariable ( value = \"nombre\" ) String nombre ) { return service . saluda ( nombre ); } } Los m\u00e9todos en los que se definen las respuestas a las peticiones HTTP est\u00e1n anotados con anotaciones en las que se indica el tipo de petici\u00f3n y la URL a la que se responde. Por ejemplo, en la clase anterior el m\u00e9todo saludo contesta a las peticiones dirigida a la URL /saludo/Ana . La cadena Ana en la URL es decodificada y pasada en el par\u00e1metro nombre al m\u00e9todo. El m\u00e9todo devuelve la respuesta HTTP. La anotaci\u00f3n @ResponseBody construye autom\u00e1ticamente esta respuesta, a\u00f1adiendo como contenido de la misma la cadena devuelta por el servicio. En este caso la respuesta es: HTTP/1.1 200 Content-Type: text/plain;charset=UTF-8 Content-Length: 8 Date: Mon, 02 Sep 2019 14:59:04 GMT Hola Ana","title":"Controladores"},{"location":"01-intro-spring-boot/intro-spring-boot.html#clases-de-servicio","text":"Es recomendable definir clases de servicio en las que se implementa la l\u00f3gica de negocio de la aplicaci\u00f3n. Las clases controller llaman a las clases servicio, que son las que realmente realizan todo el procesamiento. De esta forma se separan las responsabilidades. Las clases controller se encargan de procesar las peticiones y las respuestas HTTP y las clases de servicio son las que realmente realizan la l\u00f3gica de negocio y devuelven el contenido de las respuestas. Si en alg\u00fan momento hay que a\u00f1adir una nueva capa de presentaci\u00f3n en la que, por ejemplo, se trabaje con objetos JSON, no ser\u00e1 necesario cambiar la capa de servicios, s\u00f3lo a\u00f1adir nuevas clases controller . La separaci\u00f3n de la l\u00f3gica de negocio en las clases de servicio permite tambi\u00e9n realizar tests que trabajan sobre objetos Java, independientes de los formatos de entrada/salida manejados por los controladores. Fichero src/main/java/demoapp/service/SaludoService.java package demoapp.service ; import org.springframework.stereotype.Service ; @Service public class SaludoService { public String saluda ( String nombre ) { return \"Hola \" + nombre ; } }","title":"Clases de Servicio"},{"location":"01-intro-spring-boot/intro-spring-boot.html#inyeccion-de-dependencias-en-spring","text":"Spring Boot utiliza la anotaci\u00f3n @Autowired para inyectar en la variable anotada un objeto nuevo del tipo indicado. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. Hemos utilizado la anotaci\u00f3n en las variables de instancia. En los ejemplos anteriores podemos comprobar estas anotaciones. En la aplicaci\u00f3n ejemplo se define un controlador y un servicio que devuelve un saludo. El servicio se anota con la anotaci\u00f3n @Service y esta anotaci\u00f3n le indica a Spring Boot que la clase que va a poder ser inyectada. En el controlador se necesita instanciar un objeto de la clase SaludoService y se hace usando inyecci\u00f3n de dependencias. Spring Boot se encarga de obtener una instancia y de inyectarla en la variable cuando se inicializa el controlador. Lo vemos en el siguiente c\u00f3digo: @Controller public class SaludoController { @Autowired private SaludoService service ; @RequestMapping ( \"/saludo/{nombre}\" ) public @ResponseBody String saludo ( @PathVariable ( value = \"nombre\" ) String nombre ) { return service . saluda ( nombre ); } } Mediante la inyecci\u00f3n de dependencias el c\u00f3digo es m\u00e1s flexible y es m\u00e1s f\u00e1cil de testear, pudi\u00e9ndose definir mocks que sustituyen los objetos inyectados. M\u00e1s informaci\u00f3n en la documentaci\u00f3n de Spring Boot Spring Beans and Dependency Injection .","title":"Inyecci\u00f3n de dependencias en Spring"},{"location":"01-intro-spring-boot/intro-spring-boot.html#plantillas-thymeleaf","text":"Las p\u00e1ginas HTML devueltas se pueden construir utilizando un lenguaje de plantillas con el framework Thymeleaf . Las plantillas thymeleaf son p\u00e1ginas HTML en las que se introducen objetos Java pasados por los controllers. Las plantillas se incluyen en el directorio resources/templates . Por ejemplo, el siguiente fichero es una sencilla plantilla que muestra un saludo. El objeto mensaje es una cadena que se pasa desde el controller. Fichero src/main/resources/templates/saludo.html <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < h1 th:text = \"'Saludo: ' + ${mensaje}\" > </ h1 > </ html > El controller construye la vista devolviendo el nombre de la plantilla. Y pasa a la plantilla los objetos a mostrar usando un diccionario (la variable model que recibe como par\u00e1metro): Fichero src/main/java/demoapp/controller/SaludoControllerPlantilla.java package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; @Controller public class SaludoControllerPlantilla { @Autowired private SaludoService service ; @RequestMapping ( \"/saludoplantilla/{nombre}\" ) public String saludo ( @PathVariable ( value = \"nombre\" ) String nombre , Model model ) { // Se a\u00f1ade la respuesta a la clave 'mensaje' que se usa // en la plantilla model . addAttribute ( \"mensaje\" , service . saluda ( nombre )); // Se llama a la plantilla 'saludo.html' return \"saludo\" ; } }","title":"Plantillas Thymeleaf"},{"location":"01-intro-spring-boot/intro-spring-boot.html#formularios-y-validacion","text":"Spring Boor simplifica la declaraci\u00f3n y validaci\u00f3n de formularios usando clases Java que trabajan como modelos del formulario. Por ejemplo, en la aplicaci\u00f3n se define la clase UserData : Fichero src/main/java/demoapp/controller/UserData.java package demoapp.controller ; import javax.validation.constraints.Size ; public class UserData { @Size ( min = 3 , max = 30 ) String nombre ; public void setNombre ( String nombre ) { this . nombre = nombre ; } public String getNombre () { return nombre ; } } Se trata de un objeto con el campo nombre de tipo String al que se le ha a\u00f1adido una anotaci\u00f3n de validaci\u00f3n @Size con el tama\u00f1o m\u00ednimo y m\u00e1ximo que debe tener. Puedes encontrar m\u00e1s informaci\u00f3n sobre otros atributos de validaci\u00f3n en este enlace . El formulario HTML propiamente dicho se define con una plantilla thymeleaf en la que se declara un objeto que tiene el mismo nombre que el nombre de la clase modelo, pero con la primera letra en min\u00fascula. En nuestro caso la clase modelo es UserData , por lo que el objeto del formulario debe llamarse userData . En el formulario podemos usar cualquier campo definido en el objeto modelo. En nuestro caso usamos el \u00fanico campo de tipo String , nombre . Fichero src/main/resources/templates/formRegistro.html <!DOCTYPE HTML> < html xmlns:th = \"http://www.thymeleaf.org\" > < body > < form th:action = \"@{/saludoform}\" th:object = \"${userData}\" method = \"post\" > < table > < tr > < td > Nombre: </ td > < td >< input type = \"text\" th:field = \"*{nombre}\" /></ td > < td th:if = \"${#fields.hasErrors('nombre')}\" th:errors = \"*{nombre}\" ></ td > </ tr > < tr > < td >< button type = \"submit\" > Enviar </ button ></ td > </ tr > </ table > </ form > </ body > </ html > Se define una acci\u00f3n que enviar\u00e1 una petici\u00f3n POST a la URL /saludoform con los datos del formulario. En este caso el nombre. Por \u00faltimo, el controller que lanza el formulario y el que recibe la petici\u00f3n POST con los datos introducidos se definen en el siguiente fichero: Fichero src/main/java/demoapp/controller/SaludoControllerForm.java package demoapp.controller ; import demoapp.service.SaludoService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.validation.BindingResult ; import org.springframework.web.bind.annotation.* ; import javax.validation.Valid ; @Controller public class SaludoControllerForm { @Autowired private SaludoService service ; @GetMapping ( \"/saludoform\" ) // Hay que declarar un par\u00e1metro con el tipo usado en el modelo del formulario (UserData) public String saludoForm ( UserData userData ) { return \"formRegistro\" ; } @PostMapping ( \"/saludoform\" ) public String checkPersonInfo ( @ModelAttribute @Valid UserData userData , BindingResult bindingResult , Model model ) { if ( bindingResult . hasErrors ()) { return \"formRegistro\" ; } model . addAttribute ( \"mensaje\" , service . saluda ( userData . getNombre ())); return \"saludo\" ; } } El m\u00e9todo que recibe la petici\u00f3n en /saludoform simplemente devuelve la plantilla con el formulario. Y el m\u00e9todo que recibe los datos es el que responde a la petici\u00f3n POST en la URL /saludoform recibe los datos del formulario en un objeto Java del tipo del modelo del formulario (el par\u00e1metro userData ). Las anotaciones @ModelAttribute y @Valid indican que es un objeto recogido en el formulario sobre el que se ha realizado una validaci\u00f3n. Se detecta si ha habido alg\u00fan error en el m\u00e9todo hasErrors() del bindingResult que se recibe tambi\u00e9n como par\u00e1metro. Si ha habido error, se vuelve a devolver el formulario para que se vuelva a completar. Si no ha habido error se obtiene el nombre introducido en el formulario y se pasa a la plantilla del saludo.","title":"Formularios y validaci\u00f3n"},{"location":"01-intro-spring-boot/intro-spring-boot.html#tests","text":"A partir de Spring Boot 2.4 se usa JUnit 5 como librer\u00eda de tests. En la aplicaci\u00f3n de demostraci\u00f3n hay varios ejemplos que muestran posibles formas de realizar pruebas en una aplicaci\u00f3n Spring Boot. Spring Boot incluye el framework AssertJ que permite realizar expresiones de prueba con un lenguaje muy expresivo. Los tests se pueden ejecutar usando el comando t\u00edpico de Maven: $ mvn test O tambi\u00e9n, usando el comando de Maven Wrapper: $ ./mvnw test Tambi\u00e9n se pueden lanzar desde el propio IntelliJ, pulsando en el panel del proyecto sobre el directorio de tests con el bot\u00f3n derecho. Los tests se lanzar\u00e1n y aparecer\u00e1 un panel en el que se mostrar\u00e1 si pasan correctamente (verde) o no.","title":"Tests"},{"location":"01-intro-spring-boot/intro-spring-boot.html#5-referencias","text":"Puedes encontrar la documentaci\u00f3n de referencia de Spring Boot y Spring en las siguientes p\u00e1ginas, en la pesta\u00f1a Learn : Spring Boot Spring Tambi\u00e9n podemos encontrar tambi\u00e9n una extensa cantidad de tutoriales y gu\u00edas r\u00e1pidas en la web de Spring, en la url https://spring.io/guides . En concreto, hemos usado las siguientes referencias para construir esta primera aplicaci\u00f3n ejemplo: Building an Application with Spring Boot Serving Web Content with Spring MVC Handling Form Submission Validating Form Input Spring Boot Reference Guide 2.6.10 ( HTML , PDF )","title":"5. Referencias"},{"location":"01-intro-spring-boot/practica1.html","text":"Pr\u00e1ctica 1: Primera aplicaci\u00f3n con Spring Boot \u00b6 En esta pr\u00e1ctica tendremos un primer contacto con Spring Boot, Git y Docker. Los objetivos principales son: Empezar a conocer Spring Boot, ejecutando una sencilla aplicaci\u00f3n hola mundo en Spring Boot. Empezar a conocer el framework de plantillas Thymeleaf, realizando peque\u00f1as modificaciones en la aplicaci\u00f3n que usen un formulario. Trabajar de forma regular, realizando peque\u00f1os commits que se deben subir al repositorio personal de la asignatura en GitHub. Crear una aplicaci\u00f3n desplegable usando Docker Desplegar la aplicaci\u00f3n en el servidor de la asignatura. 1. Instalaci\u00f3n de software \u00b6 Vamos a trabajar bastante con el terminal. En Linux o macOS podemos usar el terminal que viene con el sistema. En Windows se puede usar el terminal Git Bash que se instala en la instalaci\u00f3n de Git para Windows. Es posible desarrollar la pr\u00e1ctica en cualquier sistema operativo. Debemos instalar el siguiente software: Git Java JDK 8 o posterior IntelliJ Ultimate Nota del profesor sobre en el sistema operativo en el que realizar la pr\u00e1ctica Aunque en los apuntes aparezca informaci\u00f3n sobre c\u00f3mo trabajar desde Windows, no puedo garantizar que las instrucciones funcionen correctamente en todas las posibles configuraciones, ni te podr\u00e9 ayudar con posibles problemas, porque no es un sistema operativo que maneje habitualmente. Por tanto, si tienes Windows, te recomiendo que instales una m\u00e1quina virtual Linux y la uses para la pr\u00e1ctica. Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Instalaci\u00f3n b\u00e1sica \u00b6 Linux \u00b6 Para instalar el software en Linux. Instalar Git y Java: $ sudo apt install git $ sudo apt install default-jdk Instalar IntelliJ Ultimate macOS \u00b6 Git y Java vienen instalados con el sistema operativo. Instalar IntelliJ Ultimate Windows \u00b6 Es recomendable instalar git for Windows , que adem\u00e1s de Git instala Git BASH, un terminal Bash integrado en Windows. Adem\u00e1s, hay que instalar Java e IntelliJ Ultimate . Despu\u00e9s de la instalaci\u00f3n b\u00e1sica \u00b6 Es f\u00e1cil probar que funciona el software instalado. Basta con ejecutar desde el terminal: $ git --version $ java -version (imprime la versi\u00f3n de Java) Configuraci\u00f3n del prompt para que aparezca la rama de Git \u00b6 Bash Es tambi\u00e9n bastante \u00fatil configurar el prompt para que aparezca la rama del repositorio Git en que nos encontramos. Para ello se debe a\u00f1adir en el fichero $HOME/.bashrc (linux y Git Bash Windows) o $HOME/.bash_profile (macOS con shell bash ) : parse_git_branch() { git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \\(.*\\)/ (\\1)/' } export PS1=\"\\[\\e[37m\\]\\A \\[\\e[m\\]\\[\\033[32m\\]\\W\\[\\033[33m\\]\\$(parse_git_branch)\\[\\033[00m\\] $ \" Podemos encontrar m\u00e1s opciones de configuraci\u00f3n del prompt en muchas p\u00e1ginas en Internet. Por ejemplo aqu\u00ed . Zsh Si trabajas con el shell zsh que viene por defecto en MacOS, debes a\u00f1adir en el fichero .zshrc lo siguiente: parse_git_branch() { git branch 2> /dev/null | sed -n -e 's/^\\* \\(.*\\)/ [\\1]/p' } setopt PROMPT_SUBST export PROMPT='%1~%F{green}$(parse_git_branch)%f %% ' 2. Creaci\u00f3n del repositorio GitHub con la pr\u00e1ctica \u00b6 Para inicializar el repositorio de GitHub en el que vas a trabajar en esta pr\u00e1ctica debes seguir los siguientes pasos: Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. $ git config --global user.name \"Pepe Perez\" $ git config --global user.email pepe.perez@example.com Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings > Profile y actualizando el campo Name . Una vez logeado en GitHub, pincha en el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Deber\u00e1s aceptar las peticiones de GitHub Classroom y podr\u00e1s aceptar la pr\u00e1ctica Spring Boot Demo App . Se crear\u00e1 autom\u00e1ticamente el repositorio springboot-demo-app-<usuario> en la organizaci\u00f3n mads-ua-22-23 . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial del proyecto demostraci\u00f3n de Spring Boot (es una copia del repositorio domingogallardo/spring-boot-demoapp ). Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-22-23 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas o pulsando en el icono de GitHub: El profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n mads-ua-22-23 y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua-22-23 . 3. Aplicaci\u00f3n Demo de Spring Boot \u00b6 Haremos una primera pr\u00e1ctica sencilla en la que primero pondremos en marcha y publicaremos una aplicaci\u00f3n inicial en Spring Boot y despu\u00e9s a\u00f1adiremos alguna funcionalidad. En el documento Introducci\u00f3n a Spring Boot se explica c\u00f3mo ejecutar una aplicaci\u00f3n Spring Boot y c\u00f3mo lanzar sus tests. Tambi\u00e9n se proporciona una introducci\u00f3n a los distintos componentes de la aplicaci\u00f3n. Debes leerlo y aprender el funcionamiento b\u00e1sico de este framework . Construcci\u00f3n y ejecuci\u00f3n de la aplicaci\u00f3n \u00b6 Lo primero que deber\u00e1s hacer ser\u00e1 descargar la aplicaci\u00f3n demo-spring-boot que tienes en el repositorio creado en el punto anterior y comprobar que funciona correctamente. Debes hacer lo siguiente: Configura un Personal Access Token (PAT) en GitHub para poder autenticarte desde el terminal. Dale todos los permisos de acceso a repositorios y copia la clave generada. Ser\u00e1 la contrase\u00f1a que deber\u00e1s introducir cuando un comando git te la pida. Descarga en tu ordenador el repositorio creado en GitHub en el apartado anterior, usando el comando git clone : $ git clone https://github.com/mads-ua-22-23/springboot-demo-app-<usuario>.git Cuando git te pida autenticaci\u00f3n, usa como nombre de usuario tu usuario de GitHub y como contrase\u00f1a el PAT que has creado anteriormente. Una vez descargado el repositorio con la aplicaci\u00f3n deber\u00e1s ejecutarla desde la l\u00ednea de comandos, probar los tests e importarla en IntelliJ y ejecutar y depurar con el IDE la aplicaci\u00f3n y los tests. Desde el directorio donde est\u00e1 la aplicaci\u00f3n, probamos todos sus tests usando el Maven Wrapper: $ ./mvnw test Para poner en marcha la aplicaci\u00f3n la arrancamos como una aplicaci\u00f3n Java: $ ./mvnw package $ java -jar target/demoapp-0.0.1-SNAPSHOT.jar Tambi\u00e9n podemos lanzarla usando el plugin spring-boot de Maven: $ ./mvnw spring-boot:run La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio. En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas: http://localhost:8080 http://localhost:8080/saludo/Pepito http://localhost:8080/saludoplantilla/Pepito http://localhost:8080/saludoform Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Abre proyecto el en IntelliJ. Debes importar el directorio donde se encuentre el fichero pom.xml . Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Import Project o usando la opci\u00f3n File > Open\" o \"File > New > Project from Existing Sources . Aparecer\u00e1 la pantalla de importaci\u00f3n y seleccionamos el importador Maven : IntelliJ abre el proyecto correctamente: Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n: Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc: Desde la configuraci\u00f3n de Run tambi\u00e9n podemos depurar el proyecto, pulsando el bot\u00f3n de depuraci\u00f3n. Lanza los tests desde el propio IntelliJ, pulsando en el panel del proyecto sobre el directorio de tests con el bot\u00f3n derecho. Los tests se lanzar\u00e1n y aparecer\u00e1 un panel en el que se mostrar\u00e1 si pasan correctamente (verde) o no. Por \u00faltimo, haz alg\u00fan peque\u00f1o cambio a la aplicaci\u00f3n. Cambia el mensaje de saludo que da el controller de la ra\u00edz para incluir tu nombre. Comprueba que los tests pasan (modif\u00edcalos si no es as\u00ed) y que la aplicaci\u00f3n funciona correctamente. Dockerizaci\u00f3n de la aplicaci\u00f3n \u00b6 Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. Las m\u00e1quinas Docker son muy eficientes porque comparten los servicios del sistema operativo en el que se ejecutan, utilizando menos recursos que las m\u00e1quinas virtuales tradicionales. Docker proporciona un sistema muy sencillo de distribuci\u00f3n y puesta en producci\u00f3n de software, ya que las m\u00e1quinas Docker pueden ser distribuidas usando repositorios (como Docker Hub ) y ejecutadas en cualquier ordenador que tenga instalado el Docker Engine . La tecnolog\u00eda es muy popular y se usa en gran cantidad de empresas de desarrollo para simplificar la ejecuci\u00f3n en en m\u00faltiples entornos y para que los contenedores (m\u00e1quinas Docker en ejecuci\u00f3n) se pueden configurar y combinar o ejecutar en clusters usando herramientas como Kubernetes . En nuestro caso, vamos a construir una m\u00e1quina Docker basada en la aplicaci\u00f3n demo. Posteriormente, la publicaremos en Docker Hub y la desplegaremos en un host para ponerla en producci\u00f3n. Instala Docker Desktop . Los usuarios de Linux deb\u00e9is seguir las instrucciones de esta p\u00e1gina para instalar Docker Engine. Usaremos la l\u00ednea de comando para lanzar los comandos Docker. La aplicaci\u00f3n Docker Desktop permite usar una interfaz de usuario para interactuar con im\u00e1genes y contenedores, pero no proporciona ninguna funcionalidad que no est\u00e9 disponible en la l\u00ednea de comando. Una vez instalado puedes probar el tutorial r\u00e1pido (2 minutos) desde Docker Desktop para comprobar que todo funciona correctamente. Tambi\u00e9n puedes desde el terminal comprobar la versi\u00f3n de Docker instalada: $ docker version Crea una cuenta de usuario en Docker Hub . De esta forma tendr\u00e1s un repositorio en el que podr\u00e1s subir las im\u00e1genes de las m\u00e1quinas Docker que construyas. Deber\u00e1s dar un nombre de usuario que ser\u00e1 el que utilizar\u00e1s para publicar estas im\u00e1genes. Crea un fichero llamado Dockerfile (sin extensi\u00f3n) en el directorio ra\u00edz de la aplicaci\u00f3n con el siguiente contenido: Fichero ./Dockerfile : FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"java\" , \"-Djava.security.egd=file:/dev/urandom\" , \"-jar\" , \"/app.jar\" ] El fichero Dockerfile consiste en un conjunto secuencial de instrucciones con las que se construye la m\u00e1quina Docker: FROM : este comando indica la m\u00e1quina base sobre la que se van a ejecutar el resto de comandos. En nuestro caso una m\u00e1quina de la organizaci\u00f3n openjdk que contiene la distribuci\u00f3n 8 del Java Development Kit (JDK) y que est\u00e1 basada en una distribuci\u00f3n linux Alpine. El primer paso de la construcci\u00f3n de nuestra m\u00e1quina Docker consiste por tanto en descargar esta m\u00e1quina openjdk:8-jdk-alpine y usarla como m\u00e1quina base. COPY : este comando indica que se debe copiar un fichero o conjunto de ficheros de la m\u00e1quina host (el directorio en el que estamos) en la m\u00e1quina base. En este caso se copia el fichero JAR que constituye nuestra aplicaci\u00f3n que est\u00e1 situado en el directorio ./target y se copia en la m\u00e1quina Docker con el nombre app.jar . ENTRYPOINT : este comando indica el comando a ejecutar cuando se pone en marcha la m\u00e1quina Docker. En este caso se lanza la aplicaci\u00f3n ( app.jar ) con el comando java -jar . El modificador -Djava.security.egd hace que se inicialice el generador de n\u00fameros aleatorios de Java usando el fichero del sistema /dev/urandom en lugar del fichero por defecto /dev/random . Es necesario para resolver un bug que aparece al ejecutar el contenedor en un servidor alojado DigitalOcean (el servidor de la asignatura, en el que pondr\u00e1s la aplicaci\u00f3n en producci\u00f3n, usa ese servicio). Aseg\u00farate de que en el directorio ra\u00edz de la aplicaci\u00f3n est\u00e1 el fichero JAR resultado de la compilaci\u00f3n de la aplicaci\u00f3n. Tal y como se explica en la introducci\u00f3n a Spring Boot , el fichero .jar es el ejecutable Java de la aplicaci\u00f3n, que se crea cuando con el objetivo package de Maven: $ ./mvnw package $ ls -l ./target/*.jar ./target/demoapp-0.0.1-SNAPSHOT.jar Ya puedes construir la m\u00e1quina Docker con el siguiente comando, desde el directorio ra\u00edz de la aplicaci\u00f3n (en el que debe estar el fichero Dockerfile anterior): $ docker build -t <usuario-docker>/spring-boot-demoapp . Comprueba que la imagen se ha creado correctamente. Debe aparecer en el Docker Desktop y con el comando docker image ls : $ docker image ls REPOSITORY TAG domingogallardo/spring-boot-demoapp latest Nota para usuarios de Mac M1 Los ordenadores Mac M1 tienen una arquitectura ARM que no es compatible con la arquitectura del servidor de la asignatura en el que se va a poner la aplicaci\u00f3n en producci\u00f3n (AMD). Docker puede generar una imagen que contenga las dos arquitecturas. Debes seguir los pasos que se indican en este enlace . Pon en marcha un la imagen con la aplicaci\u00f3n: $ docker run -p 8080:8080 <usuario-docker>/spring-boot-demoapp El comando docker run pone en marcha la imagen indicada, creando lo que se denomina un contenedor Docker . Es similar a una m\u00e1quina virtual en ejecuci\u00f3n. El par\u00e1metro -p 8080:8080 indica que el puerto interno 8080 del contenedor se va a mapear en el puerto 8080 del host . De esta forma podremos conectarnos desde el host a la aplicaci\u00f3n Spring Boot en funcionamiento. Ver\u00e1s que en la consola aparecen los mensajes de salida de la aplicaci\u00f3n Spring Boot que se ejecuta en el contenedor. Prueba a abrir un navegador y conectarte a la URL localhost:8080 . Deber\u00e1s ver el mensaje de saludo de la aplicaci\u00f3n ejecut\u00e1ndose en el contendor. Haciendo ctrl+c puedes parar el contenedor. El efecto es similar a suspender una m\u00e1quina virtual. Puedes ver el identificador del contenedor con el comando: $ docker container ls -a CONTAINER ID IMAGE NAMES 5bd9d0b055a9 domingogallardo/spring-boot-demoapp inspiring_feynman Puedes usar tanto el ID del contenedor ( 5bd9d0b055a9 ) como su nombre ( inspiring_feynman ) para identificarlo. Estando parado, puedes volver a poner en marcha el contenedor haciendo: $ docker container start <identificador> Tambi\u00e9n podemos parar el contenedor: $ docker container stop <identificador> Y borrarlo definitivamente con $ docker container rm <identificador> Otros comandos \u00fatiles de Docker son: docker run -d : lanza el contendor en modo background . docker run --rm : lanza el contenedor de forma que al pararlo se borra autom\u00e1ticamente. docker container logs <identificador> : muestra los logs del contenedor indicado. En la aplicaci\u00f3n Docker Engine podemos realizar tambi\u00e9n muchos de estos comandos interactuando directamente con la interfaz. Pru\u00e9balo. Ahora que has comprobado que el fichero Dockerfile funciona correctamente debes a\u00f1adirlo a git y subirlo al respositorio GitHub: $ git status $ git add . $ git status $ git commit -m \"A\u00f1adido Dockerfile\" $ git push Vamos a terminar publicando la imagen en tu cuenta de Docker Hub. Ve a Docker Hub y log\u00e9ate. Crea un repositorio con el nombre spring-boot-demoapp . En ese repositorio vas a subir la imagen con el mismo nombre. En un repositorio Docker puedes mantener m\u00faltiples versiones de una misma imagen, usando tags . IMPORTANTE : Escribe un enlace a al repositorio en Docker Hub en el fichero README.md del repositorio de GitHub. De esta forma podr\u00e9 consultar y descargar las im\u00e1genes que publiques en Docker Hub. Una vez creado el repositorio puedes publicar la imagen en \u00e9l loge\u00e1ndote desde la l\u00ednea de comando (introduce tu usuario y contrase\u00f1a de Docker Hub) y con el comando docker push : $ docker login $ docker push <usuario-docker>/spring-boot-demoapp Ver\u00e1s que autom\u00e1ticamente se asigna la etiqueta latest (etiqueta por defecto) a la imagen y que \u00e9sta se sube al repositorio. Podr\u00edas asignar una etiqueta espec\u00edfica a la imagen con el comando docker tag . Por ejemplo, si quisi\u00e9ramos fijar esta imagen con la versi\u00f3n 1.0 podr\u00edamos hacerlo con el siguiente comando: $ docker tag <usario-docker>/spring-boot-demoapp <usuario-docker>/spring-boot-demoapp:1.0 Comprueba en la p\u00e1gina web del repositorio que se ha subido. El repositorio es p\u00fablico y cualquiera puede descargar la imagen haciendo: $ docker pull <usuario-docker>/spring-boot-demoapp Al no indicar la etiqueta, se descargar\u00eda la imagen etiquetada con latest . Si quisi\u00e9ramos descargar una versi\u00f3n concreta habr\u00eda que especificar la etiqueta: $ docker pull <usuario-docker>/spring-boot-demoapp:1.0 Puesta en producci\u00f3n de la aplicaci\u00f3n \u00b6 Por \u00faltimo deber\u00e1s poner en producci\u00f3n la aplicaci\u00f3n, conect\u00e1ndote al servidor linux de la asignatura y poniendo all\u00ed en marcha la aplicaci\u00f3n. Consulta en el foro de Moodle la direcci\u00f3n IP del servidor linux de la asignatura y tu usuario. Con\u00e9ctate al servidor con tu usuario con la contrese\u00f1a mads22 y cambia tu contrase\u00f1a. Por ejemplo, si tu usuario es alu02 y la direcci\u00f3n IP del servidor es 160.66.120.177 : $ ssh alu02@160.66.120.177 $ passwd Comprueba si alguien m\u00e1s est\u00e1 utilizando el servidor: $ who alu02 pts/1 2021-08-11 07:01 (80.29.50.137) Si alg\u00fan otro compa\u00f1ero est\u00e1 usando el servidor puede ser posible que se ralentice o que ya el puerto 8080 ya est\u00e9 ocupado por la aplicaci\u00f3n del compa\u00f1ero. En este \u00faltimo caso puedes usar un puerto diferente para poner la aplicaci\u00f3n en producci\u00f3n. Descarga tu imagen de la aplicaci\u00f3n y ponla en funcionamiento: $ docker pull <usuario-docker>/spring-boot-demoapp $ docker run --rm --name spring-boot-alu<num> -p 8080:8080 <usuario-docker>/spring-boot-demoapp El indicador --rm hace que cuando se pare el contenedor autom\u00e1ticamente se borre. De esta forma evitamos tener que borrarlo a mano despu\u00e9s. El indicador --name define el nombre del contenedor. Ponemos nuestro nombre, para poder identificar qui\u00e9nes han creado cada contenedor. En el caso en que otro compa\u00f1ero tenga la aplicaci\u00f3n en marcha en ese puerto aparecer\u00e1 el siguiente mensaje de error: docker: Error response from daemon: driver failed programming ... Bind for 0.0.0.0:8080 failed: port is already allocated. En ese caso puedes usar otro puerto. El primer puerto es el que se refiere al host y el segundo a la aplicaci\u00f3n corriendo en el contenedor. Por ejemplo, puedes usar el puerto 8081 : $ docker run --rm --name spring-boot-alu02 -p 8081:8080 <usuario-docker>/spring-boot-demoapp Comprueba que la aplicaci\u00f3n funciona correctamente conect\u00e1ndote desde tu navegador al servidor linux de la asignatura y al puerto correctamente: http://161.35.65.197:8080 . \u00a1Enhorabuena, ya tienes tu aplicaci\u00f3n en producci\u00f3n!. Puedes llamar a cualquier amigo para que se conecte a esa URL y la pruebe. Si en alg\u00fan momento tenemos problemas de espacio en el disco duro, podemos borrar la imagen y el contenedor: $ docker container ls -a $ docker container rm spring-boot-alu02 $ docker image ls -a $ docker image rm <nombre-imagen> o <image-id> $ exit No guardar ficheros en el servidor de la asignatura El servidor de la asignatura tiene una capacidad limitada de disco duro y debemos tener cuidado de no sobrepasarla entre todos. Por ello, no debes guardar ning\u00fan fichero ajeno a la asignatura en este servidor. 4. Estudia el funcionamiento de la aplicaci\u00f3n y su arquitectura \u00b6 En el documento Introducci\u00f3n a Spring Boot se comenta el c\u00f3digo fuente de la aplicaci\u00f3n Spring Boot con la que estamos trabajando. L\u00e9elo despacio, revisando tambi\u00e9n el c\u00f3digo fuente, para entender los aspectos b\u00e1sicos (controladores, servicios, inyecci\u00f3n de dependencias, plantillas) del funcionamiento de Spring Boot. Estudia tambi\u00e9n despacio el funcionamiento de los tests y el funcionamiento del formulario y la validaci\u00f3n. Puedes ver un ejemplo adicional de validaci\u00f3n de un formulario en el repositorio domingogallardo/spring-boot-validate . Ver\u00e1s tambi\u00e9n ah\u00ed varios ejemplos de tests en los que se realiza una petici\u00f3n POST pasando par\u00e1metros y se obtiene informaci\u00f3n del modelo resultante, llamando al m\u00e9todo model() . El siguiente es un ejemplo de uno de los tests: @Test public void checkPersonInfoWhenNameTooShortThenFailure () throws Exception { mockMvc . perform ( post ( \"/\" ) . param ( \"name\" , \"R\" ) . param ( \"age\" , \"20\" )) . andExpect ( model (). hasErrors ()); } 5. A\u00f1adimos alguna funcionalidad sencilla a la aplicaci\u00f3n \u00b6 Para demostrar que comprendes el funcionamiento de una aplicaci\u00f3n Spring Boot, debes a\u00f1adir alguna funcionalidad sencilla a la aplicaci\u00f3n Demo que realice lo siguiente: Leer datos de un formulario usando Thymeleaf y realizar alguna validaci\u00f3n . Llamar a un m\u00e9todo de servicio que procese los datos le\u00eddos. Mostrar el resultado devuelto por el servicio en una p\u00e1gina Thymeleaf. Tests de la capa de servicio y de la capa de presentaci\u00f3n (controllers web). En la p\u00e1gina principal de la aplicaci\u00f3n debe aparecer tu nombre y apellidos. Muy importante, debemos desarrollar la aplicaci\u00f3n en peque\u00f1os commits . Cada commit debe compilar correctamente y a\u00f1adir una peque\u00f1a funcionalidad. Debemos subir los commits al repositorio personal de GitHub. Debes definir t\u00fa la funcionalidad a implementar. Por ejemplo, cualquiera de los siguientes ejemplos o alguno similar que se te ocurra: Pal\u00edndroma: lee una palabra y comprueba si es pal\u00edndroma. N\u00famero par: lee un n\u00famero y comprueba si es par Cuadrado: lee dos n\u00fameros y comprueba si el segundo es el cuadrado del primero Calculadora: lee un par de n\u00fameros y una operaci\u00f3n y devuelve el resultado. Cuando compruebes que los tests funcionan correctamente y que la aplicaci\u00f3n funciona bien en local, debes crear la m\u00e1quina Docker con la etiqueta final y probar que funciona bien en producci\u00f3n en el servidor de la asignatura. 6. Comandos Git \u00b6 Comandos Git necesarios para realizar la pr\u00e1ctica: git clone git status git add git commit git push git log Puedes encontrar m\u00e1s informaci\u00f3n sobre estos comandos en el documento Resumen de comandos Git que resume los conceptos m\u00e1s importantes de Git necesarios para estas primeras pr\u00e1cticas de la asignatura. 7. Entrega \u00b6 La pr\u00e1ctica tiene una duraci\u00f3n de 1 semana y debe estar terminada el martes 21 de septiembre. El mi\u00e9rcoles 22 de septiembre el profesor comprobar\u00e1 en clase de pr\u00e1cticas el funcionamiento de la pr\u00e1ctica en producci\u00f3n. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 10% en la nota final de pr\u00e1cticas. Para realizar la entrega debes hacer lo siguiente: Realizar la aplicaci\u00f3n en el repositorio creado e ir subiendo los commits a GitHub conforme se van realizando. Actualizar el fichero README.md con la URL del repositorio Docker Hub donde se ha subido la m\u00e1quina Docker final. A\u00f1adir una p\u00e1gina de documentaci\u00f3n doc/practica1.md en la que se explique la funcionalidad y el c\u00f3digo a\u00f1adido. Incluir en la documentaci\u00f3n la URL de los repositorios en GitHub y en Docker Hub. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . Entregar en Moodle un ZIP con el directorio del proyecto (incluyendo el directorio .git con el repositorio git), despu\u00e9s de haber hecho ./mvnw clean para eliminar los binarios compilados. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de toda la semana y no dejar todo para el \u00faltimo d\u00eda). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Importante Despu\u00e9s de entregar la pr\u00e1ctica deber\u00e1s ponerla en producci\u00f3n en el servidor de la asignatura y el profesor comprobar\u00e1 que funciona correctamente. Lo haremos en el horario de clase de pr\u00e1cticas.","title":"Enunciado de la pr\u00e1ctica"},{"location":"01-intro-spring-boot/practica1.html#practica-1-primera-aplicacion-con-spring-boot","text":"En esta pr\u00e1ctica tendremos un primer contacto con Spring Boot, Git y Docker. Los objetivos principales son: Empezar a conocer Spring Boot, ejecutando una sencilla aplicaci\u00f3n hola mundo en Spring Boot. Empezar a conocer el framework de plantillas Thymeleaf, realizando peque\u00f1as modificaciones en la aplicaci\u00f3n que usen un formulario. Trabajar de forma regular, realizando peque\u00f1os commits que se deben subir al repositorio personal de la asignatura en GitHub. Crear una aplicaci\u00f3n desplegable usando Docker Desplegar la aplicaci\u00f3n en el servidor de la asignatura.","title":"Pr\u00e1ctica 1: Primera aplicaci\u00f3n con Spring Boot"},{"location":"01-intro-spring-boot/practica1.html#1-instalacion-de-software","text":"Vamos a trabajar bastante con el terminal. En Linux o macOS podemos usar el terminal que viene con el sistema. En Windows se puede usar el terminal Git Bash que se instala en la instalaci\u00f3n de Git para Windows. Es posible desarrollar la pr\u00e1ctica en cualquier sistema operativo. Debemos instalar el siguiente software: Git Java JDK 8 o posterior IntelliJ Ultimate Nota del profesor sobre en el sistema operativo en el que realizar la pr\u00e1ctica Aunque en los apuntes aparezca informaci\u00f3n sobre c\u00f3mo trabajar desde Windows, no puedo garantizar que las instrucciones funcionen correctamente en todas las posibles configuraciones, ni te podr\u00e9 ayudar con posibles problemas, porque no es un sistema operativo que maneje habitualmente. Por tanto, si tienes Windows, te recomiendo que instales una m\u00e1quina virtual Linux y la uses para la pr\u00e1ctica. Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA.","title":"1. Instalaci\u00f3n de software"},{"location":"01-intro-spring-boot/practica1.html#instalacion-basica","text":"","title":"Instalaci\u00f3n b\u00e1sica"},{"location":"01-intro-spring-boot/practica1.html#despues-de-la-instalacion-basica","text":"Es f\u00e1cil probar que funciona el software instalado. Basta con ejecutar desde el terminal: $ git --version $ java -version (imprime la versi\u00f3n de Java)","title":"Despu\u00e9s de la instalaci\u00f3n b\u00e1sica"},{"location":"01-intro-spring-boot/practica1.html#2-creacion-del-repositorio-github-con-la-practica","text":"Para inicializar el repositorio de GitHub en el que vas a trabajar en esta pr\u00e1ctica debes seguir los siguientes pasos: Inicializa tu nombre de usuario y tu correo en Git. El nombre de usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits . Pon tu nombre y apellido. $ git config --global user.name \"Pepe Perez\" $ git config --global user.email pepe.perez@example.com Crea una cuenta en GitHub. Puedes usar el nombre de usuario que quieras (o usar el que ya tienes), pero escribe correctamente tu nombre y apellidos en el perfil usando la opci\u00f3n Settings > Profile y actualizando el campo Name . Una vez logeado en GitHub, pincha en el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Deber\u00e1s aceptar las peticiones de GitHub Classroom y podr\u00e1s aceptar la pr\u00e1ctica Spring Boot Demo App . Se crear\u00e1 autom\u00e1ticamente el repositorio springboot-demo-app-<usuario> en la organizaci\u00f3n mads-ua-22-23 . Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial del proyecto demostraci\u00f3n de Spring Boot (es una copia del repositorio domingogallardo/spring-boot-demoapp ). Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-22-23 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas o pulsando en el icono de GitHub: El profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n mads-ua-22-23 y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n accediendo a https://github.com/mads-ua-22-23 .","title":"2. Creaci\u00f3n del repositorio GitHub con la pr\u00e1ctica"},{"location":"01-intro-spring-boot/practica1.html#3-aplicacion-demo-de-spring-boot","text":"Haremos una primera pr\u00e1ctica sencilla en la que primero pondremos en marcha y publicaremos una aplicaci\u00f3n inicial en Spring Boot y despu\u00e9s a\u00f1adiremos alguna funcionalidad. En el documento Introducci\u00f3n a Spring Boot se explica c\u00f3mo ejecutar una aplicaci\u00f3n Spring Boot y c\u00f3mo lanzar sus tests. Tambi\u00e9n se proporciona una introducci\u00f3n a los distintos componentes de la aplicaci\u00f3n. Debes leerlo y aprender el funcionamiento b\u00e1sico de este framework .","title":"3. Aplicaci\u00f3n Demo de Spring Boot"},{"location":"01-intro-spring-boot/practica1.html#construccion-y-ejecucion-de-la-aplicacion","text":"Lo primero que deber\u00e1s hacer ser\u00e1 descargar la aplicaci\u00f3n demo-spring-boot que tienes en el repositorio creado en el punto anterior y comprobar que funciona correctamente. Debes hacer lo siguiente: Configura un Personal Access Token (PAT) en GitHub para poder autenticarte desde el terminal. Dale todos los permisos de acceso a repositorios y copia la clave generada. Ser\u00e1 la contrase\u00f1a que deber\u00e1s introducir cuando un comando git te la pida. Descarga en tu ordenador el repositorio creado en GitHub en el apartado anterior, usando el comando git clone : $ git clone https://github.com/mads-ua-22-23/springboot-demo-app-<usuario>.git Cuando git te pida autenticaci\u00f3n, usa como nombre de usuario tu usuario de GitHub y como contrase\u00f1a el PAT que has creado anteriormente. Una vez descargado el repositorio con la aplicaci\u00f3n deber\u00e1s ejecutarla desde la l\u00ednea de comandos, probar los tests e importarla en IntelliJ y ejecutar y depurar con el IDE la aplicaci\u00f3n y los tests. Desde el directorio donde est\u00e1 la aplicaci\u00f3n, probamos todos sus tests usando el Maven Wrapper: $ ./mvnw test Para poner en marcha la aplicaci\u00f3n la arrancamos como una aplicaci\u00f3n Java: $ ./mvnw package $ java -jar target/demoapp-0.0.1-SNAPSHOT.jar Tambi\u00e9n podemos lanzarla usando el plugin spring-boot de Maven: $ ./mvnw spring-boot:run La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio. En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas: http://localhost:8080 http://localhost:8080/saludo/Pepito http://localhost:8080/saludoplantilla/Pepito http://localhost:8080/saludoform Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate . Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA. Abre proyecto el en IntelliJ. Debes importar el directorio donde se encuentre el fichero pom.xml . Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Import Project o usando la opci\u00f3n File > Open\" o \"File > New > Project from Existing Sources . Aparecer\u00e1 la pantalla de importaci\u00f3n y seleccionamos el importador Maven : IntelliJ abre el proyecto correctamente: Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n: Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc: Desde la configuraci\u00f3n de Run tambi\u00e9n podemos depurar el proyecto, pulsando el bot\u00f3n de depuraci\u00f3n. Lanza los tests desde el propio IntelliJ, pulsando en el panel del proyecto sobre el directorio de tests con el bot\u00f3n derecho. Los tests se lanzar\u00e1n y aparecer\u00e1 un panel en el que se mostrar\u00e1 si pasan correctamente (verde) o no. Por \u00faltimo, haz alg\u00fan peque\u00f1o cambio a la aplicaci\u00f3n. Cambia el mensaje de saludo que da el controller de la ra\u00edz para incluir tu nombre. Comprueba que los tests pasan (modif\u00edcalos si no es as\u00ed) y que la aplicaci\u00f3n funciona correctamente.","title":"Construcci\u00f3n y ejecuci\u00f3n de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica1.html#dockerizacion-de-la-aplicacion","text":"Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. Las m\u00e1quinas Docker son muy eficientes porque comparten los servicios del sistema operativo en el que se ejecutan, utilizando menos recursos que las m\u00e1quinas virtuales tradicionales. Docker proporciona un sistema muy sencillo de distribuci\u00f3n y puesta en producci\u00f3n de software, ya que las m\u00e1quinas Docker pueden ser distribuidas usando repositorios (como Docker Hub ) y ejecutadas en cualquier ordenador que tenga instalado el Docker Engine . La tecnolog\u00eda es muy popular y se usa en gran cantidad de empresas de desarrollo para simplificar la ejecuci\u00f3n en en m\u00faltiples entornos y para que los contenedores (m\u00e1quinas Docker en ejecuci\u00f3n) se pueden configurar y combinar o ejecutar en clusters usando herramientas como Kubernetes . En nuestro caso, vamos a construir una m\u00e1quina Docker basada en la aplicaci\u00f3n demo. Posteriormente, la publicaremos en Docker Hub y la desplegaremos en un host para ponerla en producci\u00f3n. Instala Docker Desktop . Los usuarios de Linux deb\u00e9is seguir las instrucciones de esta p\u00e1gina para instalar Docker Engine. Usaremos la l\u00ednea de comando para lanzar los comandos Docker. La aplicaci\u00f3n Docker Desktop permite usar una interfaz de usuario para interactuar con im\u00e1genes y contenedores, pero no proporciona ninguna funcionalidad que no est\u00e9 disponible en la l\u00ednea de comando. Una vez instalado puedes probar el tutorial r\u00e1pido (2 minutos) desde Docker Desktop para comprobar que todo funciona correctamente. Tambi\u00e9n puedes desde el terminal comprobar la versi\u00f3n de Docker instalada: $ docker version Crea una cuenta de usuario en Docker Hub . De esta forma tendr\u00e1s un repositorio en el que podr\u00e1s subir las im\u00e1genes de las m\u00e1quinas Docker que construyas. Deber\u00e1s dar un nombre de usuario que ser\u00e1 el que utilizar\u00e1s para publicar estas im\u00e1genes. Crea un fichero llamado Dockerfile (sin extensi\u00f3n) en el directorio ra\u00edz de la aplicaci\u00f3n con el siguiente contenido: Fichero ./Dockerfile : FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"java\" , \"-Djava.security.egd=file:/dev/urandom\" , \"-jar\" , \"/app.jar\" ] El fichero Dockerfile consiste en un conjunto secuencial de instrucciones con las que se construye la m\u00e1quina Docker: FROM : este comando indica la m\u00e1quina base sobre la que se van a ejecutar el resto de comandos. En nuestro caso una m\u00e1quina de la organizaci\u00f3n openjdk que contiene la distribuci\u00f3n 8 del Java Development Kit (JDK) y que est\u00e1 basada en una distribuci\u00f3n linux Alpine. El primer paso de la construcci\u00f3n de nuestra m\u00e1quina Docker consiste por tanto en descargar esta m\u00e1quina openjdk:8-jdk-alpine y usarla como m\u00e1quina base. COPY : este comando indica que se debe copiar un fichero o conjunto de ficheros de la m\u00e1quina host (el directorio en el que estamos) en la m\u00e1quina base. En este caso se copia el fichero JAR que constituye nuestra aplicaci\u00f3n que est\u00e1 situado en el directorio ./target y se copia en la m\u00e1quina Docker con el nombre app.jar . ENTRYPOINT : este comando indica el comando a ejecutar cuando se pone en marcha la m\u00e1quina Docker. En este caso se lanza la aplicaci\u00f3n ( app.jar ) con el comando java -jar . El modificador -Djava.security.egd hace que se inicialice el generador de n\u00fameros aleatorios de Java usando el fichero del sistema /dev/urandom en lugar del fichero por defecto /dev/random . Es necesario para resolver un bug que aparece al ejecutar el contenedor en un servidor alojado DigitalOcean (el servidor de la asignatura, en el que pondr\u00e1s la aplicaci\u00f3n en producci\u00f3n, usa ese servicio). Aseg\u00farate de que en el directorio ra\u00edz de la aplicaci\u00f3n est\u00e1 el fichero JAR resultado de la compilaci\u00f3n de la aplicaci\u00f3n. Tal y como se explica en la introducci\u00f3n a Spring Boot , el fichero .jar es el ejecutable Java de la aplicaci\u00f3n, que se crea cuando con el objetivo package de Maven: $ ./mvnw package $ ls -l ./target/*.jar ./target/demoapp-0.0.1-SNAPSHOT.jar Ya puedes construir la m\u00e1quina Docker con el siguiente comando, desde el directorio ra\u00edz de la aplicaci\u00f3n (en el que debe estar el fichero Dockerfile anterior): $ docker build -t <usuario-docker>/spring-boot-demoapp . Comprueba que la imagen se ha creado correctamente. Debe aparecer en el Docker Desktop y con el comando docker image ls : $ docker image ls REPOSITORY TAG domingogallardo/spring-boot-demoapp latest Nota para usuarios de Mac M1 Los ordenadores Mac M1 tienen una arquitectura ARM que no es compatible con la arquitectura del servidor de la asignatura en el que se va a poner la aplicaci\u00f3n en producci\u00f3n (AMD). Docker puede generar una imagen que contenga las dos arquitecturas. Debes seguir los pasos que se indican en este enlace . Pon en marcha un la imagen con la aplicaci\u00f3n: $ docker run -p 8080:8080 <usuario-docker>/spring-boot-demoapp El comando docker run pone en marcha la imagen indicada, creando lo que se denomina un contenedor Docker . Es similar a una m\u00e1quina virtual en ejecuci\u00f3n. El par\u00e1metro -p 8080:8080 indica que el puerto interno 8080 del contenedor se va a mapear en el puerto 8080 del host . De esta forma podremos conectarnos desde el host a la aplicaci\u00f3n Spring Boot en funcionamiento. Ver\u00e1s que en la consola aparecen los mensajes de salida de la aplicaci\u00f3n Spring Boot que se ejecuta en el contenedor. Prueba a abrir un navegador y conectarte a la URL localhost:8080 . Deber\u00e1s ver el mensaje de saludo de la aplicaci\u00f3n ejecut\u00e1ndose en el contendor. Haciendo ctrl+c puedes parar el contenedor. El efecto es similar a suspender una m\u00e1quina virtual. Puedes ver el identificador del contenedor con el comando: $ docker container ls -a CONTAINER ID IMAGE NAMES 5bd9d0b055a9 domingogallardo/spring-boot-demoapp inspiring_feynman Puedes usar tanto el ID del contenedor ( 5bd9d0b055a9 ) como su nombre ( inspiring_feynman ) para identificarlo. Estando parado, puedes volver a poner en marcha el contenedor haciendo: $ docker container start <identificador> Tambi\u00e9n podemos parar el contenedor: $ docker container stop <identificador> Y borrarlo definitivamente con $ docker container rm <identificador> Otros comandos \u00fatiles de Docker son: docker run -d : lanza el contendor en modo background . docker run --rm : lanza el contenedor de forma que al pararlo se borra autom\u00e1ticamente. docker container logs <identificador> : muestra los logs del contenedor indicado. En la aplicaci\u00f3n Docker Engine podemos realizar tambi\u00e9n muchos de estos comandos interactuando directamente con la interfaz. Pru\u00e9balo. Ahora que has comprobado que el fichero Dockerfile funciona correctamente debes a\u00f1adirlo a git y subirlo al respositorio GitHub: $ git status $ git add . $ git status $ git commit -m \"A\u00f1adido Dockerfile\" $ git push Vamos a terminar publicando la imagen en tu cuenta de Docker Hub. Ve a Docker Hub y log\u00e9ate. Crea un repositorio con el nombre spring-boot-demoapp . En ese repositorio vas a subir la imagen con el mismo nombre. En un repositorio Docker puedes mantener m\u00faltiples versiones de una misma imagen, usando tags . IMPORTANTE : Escribe un enlace a al repositorio en Docker Hub en el fichero README.md del repositorio de GitHub. De esta forma podr\u00e9 consultar y descargar las im\u00e1genes que publiques en Docker Hub. Una vez creado el repositorio puedes publicar la imagen en \u00e9l loge\u00e1ndote desde la l\u00ednea de comando (introduce tu usuario y contrase\u00f1a de Docker Hub) y con el comando docker push : $ docker login $ docker push <usuario-docker>/spring-boot-demoapp Ver\u00e1s que autom\u00e1ticamente se asigna la etiqueta latest (etiqueta por defecto) a la imagen y que \u00e9sta se sube al repositorio. Podr\u00edas asignar una etiqueta espec\u00edfica a la imagen con el comando docker tag . Por ejemplo, si quisi\u00e9ramos fijar esta imagen con la versi\u00f3n 1.0 podr\u00edamos hacerlo con el siguiente comando: $ docker tag <usario-docker>/spring-boot-demoapp <usuario-docker>/spring-boot-demoapp:1.0 Comprueba en la p\u00e1gina web del repositorio que se ha subido. El repositorio es p\u00fablico y cualquiera puede descargar la imagen haciendo: $ docker pull <usuario-docker>/spring-boot-demoapp Al no indicar la etiqueta, se descargar\u00eda la imagen etiquetada con latest . Si quisi\u00e9ramos descargar una versi\u00f3n concreta habr\u00eda que especificar la etiqueta: $ docker pull <usuario-docker>/spring-boot-demoapp:1.0","title":"Dockerizaci\u00f3n de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica1.html#puesta-en-produccion-de-la-aplicacion","text":"Por \u00faltimo deber\u00e1s poner en producci\u00f3n la aplicaci\u00f3n, conect\u00e1ndote al servidor linux de la asignatura y poniendo all\u00ed en marcha la aplicaci\u00f3n. Consulta en el foro de Moodle la direcci\u00f3n IP del servidor linux de la asignatura y tu usuario. Con\u00e9ctate al servidor con tu usuario con la contrese\u00f1a mads22 y cambia tu contrase\u00f1a. Por ejemplo, si tu usuario es alu02 y la direcci\u00f3n IP del servidor es 160.66.120.177 : $ ssh alu02@160.66.120.177 $ passwd Comprueba si alguien m\u00e1s est\u00e1 utilizando el servidor: $ who alu02 pts/1 2021-08-11 07:01 (80.29.50.137) Si alg\u00fan otro compa\u00f1ero est\u00e1 usando el servidor puede ser posible que se ralentice o que ya el puerto 8080 ya est\u00e9 ocupado por la aplicaci\u00f3n del compa\u00f1ero. En este \u00faltimo caso puedes usar un puerto diferente para poner la aplicaci\u00f3n en producci\u00f3n. Descarga tu imagen de la aplicaci\u00f3n y ponla en funcionamiento: $ docker pull <usuario-docker>/spring-boot-demoapp $ docker run --rm --name spring-boot-alu<num> -p 8080:8080 <usuario-docker>/spring-boot-demoapp El indicador --rm hace que cuando se pare el contenedor autom\u00e1ticamente se borre. De esta forma evitamos tener que borrarlo a mano despu\u00e9s. El indicador --name define el nombre del contenedor. Ponemos nuestro nombre, para poder identificar qui\u00e9nes han creado cada contenedor. En el caso en que otro compa\u00f1ero tenga la aplicaci\u00f3n en marcha en ese puerto aparecer\u00e1 el siguiente mensaje de error: docker: Error response from daemon: driver failed programming ... Bind for 0.0.0.0:8080 failed: port is already allocated. En ese caso puedes usar otro puerto. El primer puerto es el que se refiere al host y el segundo a la aplicaci\u00f3n corriendo en el contenedor. Por ejemplo, puedes usar el puerto 8081 : $ docker run --rm --name spring-boot-alu02 -p 8081:8080 <usuario-docker>/spring-boot-demoapp Comprueba que la aplicaci\u00f3n funciona correctamente conect\u00e1ndote desde tu navegador al servidor linux de la asignatura y al puerto correctamente: http://161.35.65.197:8080 . \u00a1Enhorabuena, ya tienes tu aplicaci\u00f3n en producci\u00f3n!. Puedes llamar a cualquier amigo para que se conecte a esa URL y la pruebe. Si en alg\u00fan momento tenemos problemas de espacio en el disco duro, podemos borrar la imagen y el contenedor: $ docker container ls -a $ docker container rm spring-boot-alu02 $ docker image ls -a $ docker image rm <nombre-imagen> o <image-id> $ exit No guardar ficheros en el servidor de la asignatura El servidor de la asignatura tiene una capacidad limitada de disco duro y debemos tener cuidado de no sobrepasarla entre todos. Por ello, no debes guardar ning\u00fan fichero ajeno a la asignatura en este servidor.","title":"Puesta en producci\u00f3n de la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica1.html#4-estudia-el-funcionamiento-de-la-aplicacion-y-su-arquitectura","text":"En el documento Introducci\u00f3n a Spring Boot se comenta el c\u00f3digo fuente de la aplicaci\u00f3n Spring Boot con la que estamos trabajando. L\u00e9elo despacio, revisando tambi\u00e9n el c\u00f3digo fuente, para entender los aspectos b\u00e1sicos (controladores, servicios, inyecci\u00f3n de dependencias, plantillas) del funcionamiento de Spring Boot. Estudia tambi\u00e9n despacio el funcionamiento de los tests y el funcionamiento del formulario y la validaci\u00f3n. Puedes ver un ejemplo adicional de validaci\u00f3n de un formulario en el repositorio domingogallardo/spring-boot-validate . Ver\u00e1s tambi\u00e9n ah\u00ed varios ejemplos de tests en los que se realiza una petici\u00f3n POST pasando par\u00e1metros y se obtiene informaci\u00f3n del modelo resultante, llamando al m\u00e9todo model() . El siguiente es un ejemplo de uno de los tests: @Test public void checkPersonInfoWhenNameTooShortThenFailure () throws Exception { mockMvc . perform ( post ( \"/\" ) . param ( \"name\" , \"R\" ) . param ( \"age\" , \"20\" )) . andExpect ( model (). hasErrors ()); }","title":"4. Estudia el funcionamiento de la aplicaci\u00f3n y su arquitectura"},{"location":"01-intro-spring-boot/practica1.html#5-anadimos-alguna-funcionalidad-sencilla-a-la-aplicacion","text":"Para demostrar que comprendes el funcionamiento de una aplicaci\u00f3n Spring Boot, debes a\u00f1adir alguna funcionalidad sencilla a la aplicaci\u00f3n Demo que realice lo siguiente: Leer datos de un formulario usando Thymeleaf y realizar alguna validaci\u00f3n . Llamar a un m\u00e9todo de servicio que procese los datos le\u00eddos. Mostrar el resultado devuelto por el servicio en una p\u00e1gina Thymeleaf. Tests de la capa de servicio y de la capa de presentaci\u00f3n (controllers web). En la p\u00e1gina principal de la aplicaci\u00f3n debe aparecer tu nombre y apellidos. Muy importante, debemos desarrollar la aplicaci\u00f3n en peque\u00f1os commits . Cada commit debe compilar correctamente y a\u00f1adir una peque\u00f1a funcionalidad. Debemos subir los commits al repositorio personal de GitHub. Debes definir t\u00fa la funcionalidad a implementar. Por ejemplo, cualquiera de los siguientes ejemplos o alguno similar que se te ocurra: Pal\u00edndroma: lee una palabra y comprueba si es pal\u00edndroma. N\u00famero par: lee un n\u00famero y comprueba si es par Cuadrado: lee dos n\u00fameros y comprueba si el segundo es el cuadrado del primero Calculadora: lee un par de n\u00fameros y una operaci\u00f3n y devuelve el resultado. Cuando compruebes que los tests funcionan correctamente y que la aplicaci\u00f3n funciona bien en local, debes crear la m\u00e1quina Docker con la etiqueta final y probar que funciona bien en producci\u00f3n en el servidor de la asignatura.","title":"5. A\u00f1adimos alguna funcionalidad sencilla a la aplicaci\u00f3n"},{"location":"01-intro-spring-boot/practica1.html#6-comandos-git","text":"Comandos Git necesarios para realizar la pr\u00e1ctica: git clone git status git add git commit git push git log Puedes encontrar m\u00e1s informaci\u00f3n sobre estos comandos en el documento Resumen de comandos Git que resume los conceptos m\u00e1s importantes de Git necesarios para estas primeras pr\u00e1cticas de la asignatura.","title":"6. Comandos Git"},{"location":"01-intro-spring-boot/practica1.html#7-entrega","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 1 semana y debe estar terminada el martes 21 de septiembre. El mi\u00e9rcoles 22 de septiembre el profesor comprobar\u00e1 en clase de pr\u00e1cticas el funcionamiento de la pr\u00e1ctica en producci\u00f3n. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 10% en la nota final de pr\u00e1cticas. Para realizar la entrega debes hacer lo siguiente: Realizar la aplicaci\u00f3n en el repositorio creado e ir subiendo los commits a GitHub conforme se van realizando. Actualizar el fichero README.md con la URL del repositorio Docker Hub donde se ha subido la m\u00e1quina Docker final. A\u00f1adir una p\u00e1gina de documentaci\u00f3n doc/practica1.md en la que se explique la funcionalidad y el c\u00f3digo a\u00f1adido. Incluir en la documentaci\u00f3n la URL de los repositorios en GitHub y en Docker Hub. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . Entregar en Moodle un ZIP con el directorio del proyecto (incluyendo el directorio .git con el repositorio git), despu\u00e9s de haber hecho ./mvnw clean para eliminar los binarios compilados. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de toda la semana y no dejar todo para el \u00faltimo d\u00eda). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Importante Despu\u00e9s de entregar la pr\u00e1ctica deber\u00e1s ponerla en producci\u00f3n en el servidor de la asignatura y el profesor comprobar\u00e1 que funciona correctamente. Lo haremos en el horario de clase de pr\u00e1cticas.","title":"7. Entrega"},{"location":"02-todolist/practica2.html","text":"Pr\u00e1ctica 2: Aplicaci\u00f3n ToDoList \u00b6 1. Objetivos \u00b6 En pr\u00e1ctica 2 vamos a trabajar sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . Esta parte tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando los tableros del proyecto (en Trello y en GitHub). Al igual que en la pr\u00e1ctica 1 usaremos GitHub Classroom para crear un repositorio individual con el que realizar\u00e1s la pr\u00e1ctica. El proyecto base ser\u00e1 la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . En este repositorio se ha seguido una metodolog\u00eda similar a la que vamos a utilizar en este pr\u00e1ctica y puedes examinarlo para ver distintos elementos: Issues cerrados Pull Requests mezclados Tablero de issues Tablero Trello de historias de usuario Debes leer la introducci\u00f3n a Spring Boot para entender los conceptos fundamentales del framework. 2. Aplicaci\u00f3n inicial \u00b6 La aplicaci\u00f3n con la que vamos a trabajar es una t\u00edpica aplicaci\u00f3n ToDo que sirve para gestionar tareas pendientes. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es mads-todolist . 3. La aplicaci\u00f3n ToDoList \u00b6 La aplicaci\u00f3n mads-todolist-inicial es la versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante toda la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista en la pr\u00e1ctica 1. Entre otros, tiene los siguientes elementos: Distintos comandos HTTP: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban la capa de servicios y la de presentaci\u00f3n. Vamos a ver con un poco m\u00e1s de detalle d\u00f3nde puedes encontrar en el c\u00f3digo todos estos elementos. Configuraci\u00f3n de la aplicaci\u00f3n \u00b6 Los distintos par\u00e1metros de la aplicaci\u00f3n Spring Boot se configuran un fichero de propiedades. El fichero de propiedades por defecto es application.properties . Fichero /src/main/resources/application.properties : spring.application.name = mads-todolist spring.datasource.url = jdbc:h2:mem:dev spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect spring.jpa.hibernate.ddl-auto = update logging.level.org.hibernate.SQL = debug logging.level.madstodolist = debug spring.sql.init.mode = always # cargar los datos despues de que Hibernate inicialice # los esquemas de datos # https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes#sql-script-datasource-initialization spring.jpa.defer-datasource-initialization = true spring.h2.console.enabled = true spring.h2.console.path = /h2-console # Deshabilitamos Open EntityManager in View # https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/html/data.html#data.sql.jpa-and-spring-data.open-entity-manager-in-view # Ver tambien https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/hibernate5/support/OpenSessionInViewInterceptor.html # y https://www.baeldung.com/spring-open-session-in-view spring.jpa.open-in-view = false Entre otras cosas, se define las caracter\u00edsticas de la fuente de datos con la que trabaja la aplicaci\u00f3n (la base de datos en memoria H2): El par\u00e1metro spring.jpa.hibernate.ddl-auto=update hace que Hibernate actualice autom\u00e1ticamente los esquemas de la base de datos, construy\u00e9ndolos a partir de las clases Entity . En un entorno de producci\u00f3n el valor de esta propiedad deber\u00e1 ser validate para no modificar la base de datos de producci\u00f3n. El par\u00e1metro spring.sql.init.mode=always hace que se carguen datos iniciales en la base de datos al arrancar la aplicaci\u00f3n. El par\u00e1metro spring.jpa.defer-datasource-initialization=true hace que los datos se carguen despu\u00e9s de que Hibernate haya actualizado el esquema de datos. Los datos iniciales de la aplicaci\u00f3n se encuentran en el fichero data.sql : Fichero /src/main/resources/data.sql : /* Populate tables */ INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Base de datos H2 en memoria en desarrollo En esta pr\u00e1ctica vamos a trabajar \u00fanicamente con la base de datos en memoria. Esto significa que los datos que introduzcamos van a estar presentes mientras que la aplicaci\u00f3n est\u00e9 funcionando. Cuando matemos la aplicaci\u00f3n y la volvamos a reiniciar s\u00f3lo estar\u00e1n los datos iniciales, los datos que se cargan del fichero data.sql . En la pr\u00e1ctica 3 utilizaremos una base de datos real, que deberemos gestionar tambi\u00e9n en producci\u00f3n. En concreto, se tratar\u00e1 de una base de datos PostgresSQL. Por \u00faltimo, el par\u00e1metro spring.jpa.open-in-view=false deshabilita una caracter\u00edstica de Spring denominada open in view que mantiene abierta la conexi\u00f3n de la base de datos de forma autom\u00e1tica en cada petici\u00f3n HTTP. Se trata de una caracter\u00edstica que facilita el trabajo con las relaciones lazy entre entidades, pero puede introducir errores no deseados al permitir acceder a la base de datos en la capa controller . Al deshabilitar esta caracter\u00edstica tendremos que gestionar manualmente las relaciones lazy , recuper\u00e1ndolas en la capa de servicio, en donde s\u00ed que mantenemos abierta la conexi\u00f3n con la base de datos. Lo veremos m\u00e1s adelante con m\u00e1s detalle. Otras configuraciones \u00b6 Es posible definir otras configuraciones e indicar en el comando de ejecuci\u00f3n de la aplicaci\u00f3n Spring Boot qu\u00e9 fichero de configuraci\u00f3n usar. Lo veremos en la pr\u00e1ctica 3. En esta pr\u00e1ctica se define otra configuraci\u00f3n en el directorio de test, que es la que se carga cuando se lanzan los tests: Fichero src/test/resources/application.properties : spring.datasource.url = jdbc:h2:mem:test spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect spring.jpa.hibernate.ddl-auto = create logging.level.org.hibernate.SQL = debug # Es necesario definir el sql.init.mode a never para evitar # que se carguen los datos de src/main/resources/data.sql spring.sql.init.mode = never # obligamos a que Hibernate inicialice los esquemas de datos # https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes#sql-script-datasource-initialization spring.jpa.defer-datasource-initialization = true # Deshabilitamos Open EntityManager in View # https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/html/data.html#data.sql.jpa-and-spring-data.open-entity-manager-in-view # Ver tambien https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/hibernate5/support/OpenSessionInViewInterceptor.html # y https://www.baeldung.com/spring-open-session-in-view spring.jpa.open-in-view = false Una diferencia con el fichero de configuraci\u00f3n de desarrollo es el nombre de la fuente de datos, el modo del spring.jpa.hibernate.ddl-auto , que es create y el fichero de datos iniciales que se carga al ejecutar los tests. La otra diferencia importante es que evitamos que se carguen los datos poniendo el par\u00e1metro spring.sql.init.mode a never . Cargaremos los datos de prueba manualmente en los tests. Gesti\u00f3n de persistencia con JPA \u00b6 Para la gesti\u00f3n de la persistencia de los datos en la aplicaci\u00f3n Spring Boot usaremos Spring Data JPA . Se trata de un API de Spring Boot que se construye sobre JPA ( Java Persistence API ), el ORM ( Object Relational Mapping ) est\u00e1ndar de Java. La implementaci\u00f3n de JPA que utiliza Spring Boot es Hibernate . Spring Data JPA usa todos los conceptos de JPA y a\u00f1ade algunos adicionales que facilitan aun m\u00e1s su utilizaci\u00f3n, como es la definici\u00f3n de interfaces Repository con m\u00e9todos CRUD est\u00e1ndar para las entidades. Definici\u00f3n del modelo de datos \u00b6 El framework JPA permite definir el esquema de la base de datos usando anotaciones en las clases denominadas de entidad. Para cada clase de entidad se define una tabla en la base de datos, con columnas que se mapean con sus atributos. Por ejemplo, la clase Usuario que se lista a continuaci\u00f3n define la tabla usuarios en la base de datos. Los distintos atributos ( login , email , ...) se corresponden con las columnas de la tabla. El atributo id se corresponde con la clave primaria de la tabla. JPA define varias estrategias para obtener esa clave primera, y se ha escogido la estrategia @GeneratedValue(strategy = GenerationType.IDENTITY) que define una columna que se autoincrementa en cada operaci\u00f3n de inserci\u00f3n de un nuevo registro en la tabla. Adem\u00e1s de los atributos, en la clase se define un constructor con los atributos obligatorios para definir un usuario (en nuestro caso el correo electronico), los getters y setters de todas las propiedades (necesario para JPA) y los m\u00e9todos equals y hashCode para comparar usuarios. Los m\u00e9todos equals y hashCode son necesarios para buscar instancias de la entidad en colecciones y JPA los usa para no incluir instancias repetidas en los resultados de las queries. El m\u00e9todo equals proporcionado no es el que genera IntelliJ por defecto, sino que hay que considerar si la instancia ha sido ya vinculada a la base de datos o no. En el caso en que la instancia ya est\u00e9 vinculada a la base de datos, tendr\u00e1 una clave primaria asignada y \u00e9sta ser\u00e1 la que se usar\u00e1 para comparar. En el caso en que la instancia no est\u00e9 vinculada (se acaba de crear o la estamos usando para alguna parte de la l\u00f3gica de negocio y no se va a persistir) se comparan los atributos obligatorios (en este caso el correo electr\u00f3nico). Fichero src/main/java/madstodolist/model/Usuario.java : package madstodolist.model ; import javax.persistence.* ; import javax.validation.constraints.NotNull ; import java.io.Serializable ; import java.util.Date ; import java.util.HashSet ; import java.util.Objects ; import java.util.Set ; @Entity @Table ( name = \"usuarios\" ) public class Usuario implements Serializable { private static final long serialVersionUID = 1L ; @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) private Long id ; @NotNull private String email ; private String nombre ; private String password ; @Column ( name = \"fecha_nacimiento\" ) @Temporal ( TemporalType . DATE ) private Date fechaNacimiento ; // Definimos el tipo de fetch como EAGER para que // cualquier consulta que devuelve un usuario rellene autom\u00e1ticamente // toda su lista de tareas // CUIDADO!! No es recomendable hacerlo en aquellos casos en los // que la relaci\u00f3n pueda traer a memoria una gran cantidad de entidades @OneToMany ( mappedBy = \"usuario\" , fetch = FetchType . EAGER ) Set < Tarea > tareas = new HashSet <> (); // Constructor vac\u00edo necesario para JPA/Hibernate. // No debe usarse desde la aplicaci\u00f3n. public Usuario () {} // Constructor p\u00fablico con los atributos obligatorios. En este caso el correo electr\u00f3nico. public Usuario ( String email ) { this . email = email ; } public Long getId () { return id ; } public void setId ( Long id ) { this . id = id ; } public String getEmail () { return email ; } public void setEmail ( String email ) { this . email = email ; } public String getNombre () { return nombre ; } public void setNombre ( String nombre ) { this . nombre = nombre ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } public Date getFechaNacimiento () { return fechaNacimiento ; } public void setFechaNacimiento ( Date fechaNacimiento ) { this . fechaNacimiento = fechaNacimiento ; } public Set < Tarea > getTareas () { return tareas ; } public void setTareas ( Set < Tarea > tareas ) { this . tareas = tareas ; } @Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; Usuario usuario = ( Usuario ) o ; if ( id != null && usuario . id != null ) // Si tenemos los ID, comparamos por ID return Objects . equals ( id , usuario . id ); // sino comparamos por campos obligatorios return email . equals ( usuario . email ); } @Override public int hashCode () { // Generamos un hash basado en los campos obligatorios return Objects . hash ( email ); } } En la definici\u00f3n de la entidad tambi\u00e9n se incluyen relaciones con otras entidades. En este caso un Usuario tiene muchas Tarea s (una relaci\u00f3n una-a-muchos). La relaci\u00f3n uno-a-muchos se representa en la base de datos con una clave ajena. El atributo mappedBy indica que la clave ajena se va a guardar en la columna correspondiente con el atributo usuario de la entidad Tarea . La definici\u00f3n de Tarea es la siguiente: Fichero src/main/java/madstodolist/model/Tarea.java : package madstodolist.model ; import javax.persistence.* ; import javax.validation.constraints.NotNull ; import java.io.Serializable ; import java.util.Objects ; @Entity @Table ( name = \"tareas\" ) public class Tarea implements Serializable { private static final long serialVersionUID = 1L ; @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) private Long id ; @NotNull private String titulo ; @NotNull // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = \"usuario_id\" ) private Usuario usuario ; // Constructor vac\u00edo necesario para JPA/Hibernate. // No debe usarse desde la aplicaci\u00f3n. public Tarea () {} // Al crear una tarea la asociamos autom\u00e1ticamente a un // usuario. Actualizamos por tanto la lista de tareas del // usuario. public Tarea ( Usuario usuario , String titulo ) { this . usuario = usuario ; this . titulo = titulo ; usuario . getTareas (). add ( this ); } public Long getId () { return id ; } public void setId ( Long id ) { this . id = id ; } public String getTitulo () { return titulo ; } public void setTitulo ( String titulo ) { this . titulo = titulo ; } public Usuario getUsuario () { return usuario ; } public void setUsuario ( Usuario usuario ) { this . usuario = usuario ; } @Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass () != o . getClass ()) return false ; Tarea tarea = ( Tarea ) o ; if ( id != null && tarea . id != null ) // Si tenemos los ID, comparamos por ID return Objects . equals ( id , tarea . id ); // sino comparamos por campos obligatorios return titulo . equals ( tarea . titulo ) && usuario . equals ( tarea . usuario ); } @Override public int hashCode () { return Objects . hash ( titulo , usuario ); } } Recuperaci\u00f3n eager y lazy de las colecciones \u00b6 Como hemos visto anteriormente, en la aplicaci\u00f3n se define la relaci\u00f3n uno-a-muchos entre usuarios y tareas: un usuario tiene muchas tareas. Por defecto, todas las relaciones a-muchos en JPA se definen de tipo LAZY . La caracter\u00edstica de los atributos marcados como lazy en JPA es que no se traen a memoria cuando se recupera la entidad, sino cuando se consultan expl\u00edcitamente accediendo al atributo. Para que se traigan a memoria la conexi\u00f3n con la base de datos debe estar abierta . Una forma de hacerlo, la que usamos en la aplicaci\u00f3n, es marcando el m\u00e9todo que accede a las entidades con la anotaci\u00f3n @Transactional . Las entidades que usemos en los m\u00e9todos con esa anotaci\u00f3n estar\u00e1n conectadas a la base de datos y podremos recuperar sus relaciones lazy . Una vez terminada la transacci\u00f3n, por ejemplo fuera del m\u00e9todo anotado con @Transactional , si intentamos acceder a una relaci\u00f3n lazy sin haberla inicializado se producir\u00e1 un error. En la pr\u00e1ctica 3 definiremos una relaci\u00f3n lazy y explicaremos c\u00f3mo gestionarla en la capa de servicios. En esta pr\u00e1ctica, sin embargo, usaremos relaciones de tipo EAGER . En el caso de definir un relaci\u00f3n entre entidades de tipo EAGER , JPA traer\u00e1 siempre a memoria todos los elementos cuando se recupere cualquier entidad. Hemos definido de esta forma la relaci\u00f3n entre un usuario y sus tareas. Por ejemplo, cuando se realice una b\u00fasqueda y se recupere un usuario, se recuperar\u00e1n tambi\u00e9n autom\u00e1ticamente todas sus tareas y se inicializar\u00e1 en memoria la colecci\u00f3n de tareas del usuario. En general, no es conveniente definir una relaci\u00f3n como eager porque puede provocar problemas de rendimiento en el caso en que haya muchos elementos relacionados. Pero si no hay muchos datos en la relaci\u00f3n y los vamos a usar con frecuencia, s\u00ed que es aconsejable usar el tipo EAGER para facilitar el manejo de la entidad. El c\u00f3digo queda como hemos visto anteriormente: @Entity public class Usuario { ... // Definimos el tipo de fetch como EAGER para que // cualquier consulta que devuelve un usuario rellene autom\u00e1ticamente // toda su lista de tareas // CUIDADO!! No es recomendable hacerlo en aquellos casos en los // que la relaci\u00f3n pueda traer a memoria una gran cantidad de entidades @OneToMany ( mappedBy = \"usuario\" , fetch = FetchType . EAGER ) List < Tarea > tareas = new ArrayList < Tarea > (); ... } @Entity public class Tarea { ... // Relaci\u00f3n muchos-a-uno entre tareas y usuario @ManyToOne // Nombre de la columna en la BD que guarda f\u00edsicamente // el ID del usuario con el que est\u00e1 asociado una tarea @JoinColumn ( name = \"usuario_id\" ) private Usuario usuario ; ... } Note La diferencia entre recuperaci\u00f3n lazy y recuperaci\u00f3n eager de las relaciones es uno de los conceptos que causan m\u00e1s problemas al trabajar con Hibernate. Te recomiendo que lo estudies bien. Un ejercicio que te recomiendo es cambiar el atributo anterior a LAZY y comprobar qu\u00e9 errores se producen en el c\u00f3digo y en los tests. Clases Repository \u00b6 Spring define la clase gen\u00e9rica CrudRepository que contienen m\u00e9todos por defecto para actualizar las entidades y realizar queries sobre ellas. Para dejar abierta la posibilidad de cambiar la implementaci\u00f3n, se definen con interfaces. public interface CrudRepository < T , ID extends Serializable > extends Repository < T , ID > { < S extends T > S save ( S entity ); Optional < T > findById ( ID primaryKey ); Iterable < T > findAll (); long count (); void delete ( T entity ); boolean existsById ( ID primaryKey ); // \u2026 more functionality omitted. } Para usar estos m\u00e9todos con nuestras entidades basta con definir interfaces que extienden esta clase gen\u00e9rica. Por ejemplo, la interfaz TareaRepository : Fichero src/main/java/madstodolist/model/TareaRepository.java : package madstodolist.model ; import org.springframework.data.repository.CrudRepository ; public interface TareaRepository extends CrudRepository < Tarea , Long > {} Una vez definida la interfaz, ya podemos inyectar una instancia de repository y usarla en las clases de servicio. Por ejemplo, mostramos el m\u00e9todo de servicio que modifica el t\u00edtulo de una tarea: @Service public class TareaService { @Autowired private UsuarioRepository usuarioRepository ; @Autowired private TareaRepository tareaRepository ; ... @Transactional public Tarea modificaTarea ( Long idTarea , String nuevoTitulo ) { Tarea tarea = tareaRepository . findById ( idTarea ). orElse ( null ); if ( tarea == null ) { throw new TareaServiceException ( \"No existe tarea con id \" + idTarea ); } tarea . setTitulo ( nuevoTitulo ); tareaRepository . save ( tarea ); return tarea ; } ... } En el cuerpo del m\u00e9todo se llama al m\u00e9todo findById del repositorio que realiza una b\u00fasqueda en la base de datos y al m\u00e9todo save que actualiza el valor de la entidad. La anotaci\u00f3n @Transactional hace dos cosas. En primer lugar, abre una conexi\u00f3n con la base de datos y hace que todas las llamadas a las clases repository se realicen usando esa conexi\u00f3n. Las entidades est\u00e1n conectadas a la base de datos durante todas las sentencias que se ejecutan dentro del m\u00e9todo anotado y cualquier cambio en ellas se propaga a la base de datos (en este caso el t\u00edtulo de la tarea). Adem\u00e1s, y muy importante, las relaciones lazy pueden recuperarse sin problemas accediendo a los atributos correspondientes de las entidades. En segundo lugar, la anotaci\u00f3n @Transactional , como su nombre indica, hace que las acciones sobre la base de datos se ejecuten de forma transaccional. Se abre la transacci\u00f3n al del m\u00e9todo y se cierra al final. Si sucede alguna excepci\u00f3n durante su ejecuci\u00f3n la transacci\u00f3n se deshace. La interfaz UsuarioRepository es similar. Fichero src/main/java/madstodolist/model/UsuarioRepository.java : package madstodolist.model ; import org.springframework.data.repository.CrudRepository ; import java.util.Optional ; public interface UsuarioRepository extends CrudRepository < Usuario , Long > { Optional < Usuario > findByEmail ( String s ); } La diferencia es que se a\u00f1ade un m\u00e9todo findByEmail que hace que Spring construya autom\u00e1ticamente una consulta sobre la base de datos. Al usar como nombre del m\u00e9todo el nombre de la propiedad de la entidad ( email ), Spring puede generar autom\u00e1ticamente la consulta. Puedes consultar una lista completa de las traducciones de nombres de m\u00e9todos a consultas a la base de datos en este enlace de la documentaci\u00f3n de Spring Boot. Tambi\u00e9n es posible definir expl\u00edcitamente en el Repository la consulta a realizar a la base de datos utilizando la anotaci\u00f3n @Query . Puedes encontrar varios ejemplos en este enlace . Servicios \u00b6 La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es crear, obtener o modificar los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Como hemos comentado anteriormente, los m\u00e9todos de la capa de servicios estar\u00e1n anotados con @Transactional actualizar correctamente la base de datos y las conexiones lazy y para garantizar la transaccionalidad. Por ejemplo, la clase UsuarioService se define como se muestra a continuaci\u00f3n. Fichero src/main/java/madstodolist/service/UsuarioService.java : npackage madstodolist . service ; import madstodolist.model.Usuario ; import madstodolist.model.UsuarioRepository ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import org.springframework.transaction.annotation.Transactional ; import java.util.Optional ; @Service public class UsuarioService { public enum LoginStatus { LOGIN_OK , USER_NOT_FOUND , ERROR_PASSWORD } @Autowired private UsuarioRepository usuarioRepository ; @Transactional ( readOnly = true ) public LoginStatus login ( String eMail , String password ) { Optional < Usuario > usuario = usuarioRepository . findByEmail ( eMail ); if ( ! usuario . isPresent ()) { return LoginStatus . USER_NOT_FOUND ; } else if ( ! usuario . get (). getPassword (). equals ( password )) { return LoginStatus . ERROR_PASSWORD ; } else { return LoginStatus . LOGIN_OK ; } } // Se a\u00f1ade un usuario en la aplicaci\u00f3n. // El email y password del usuario deben ser distinto de null // El email no debe estar registrado en la base de datos @Transactional public Usuario registrar ( Usuario usuario ) { Optional < Usuario > usuarioBD = usuarioRepository . findByEmail ( usuario . getEmail ()); if ( usuarioBD . isPresent ()) throw new UsuarioServiceException ( \"El usuario \" + usuario . getEmail () + \" ya est\u00e1 registrado\" ); else if ( usuario . getEmail () == null ) throw new UsuarioServiceException ( \"El usuario no tiene email\" ); else if ( usuario . getPassword () == null ) throw new UsuarioServiceException ( \"El usuario no tiene password\" ); else return usuarioRepository . save ( usuario ); } @Transactional ( readOnly = true ) public Usuario findByEmail ( String email ) { return usuarioRepository . findByEmail ( email ). orElse ( null ); } @Transactional ( readOnly = true ) public Usuario findById ( Long usuarioId ) { return usuarioRepository . findById ( usuarioId ). orElse ( null ); } } Fichero src/main/java/madstodolist/service/UsuarioServiceException.java : package madstodolist.service ; public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException ( String message ) { super ( message ); } } Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas. Controllers \u00b6 Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen dos clases controller: LoginController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. Los controllers usan clases auxiliares en las que se guardan los datos introducidos en los formularios. Por ejemplo, la clase LoginController usa las clases LoginData y RegistroData . Fichero src/main/java/madstodolist/controller/LoginController.java : package madstodolist.controller ; import madstodolist.authentication.ManagerUserSession ; import madstodolist.model.Usuario ; import madstodolist.service.TareaService ; import madstodolist.service.UsuarioService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.validation.BindingResult ; import org.springframework.web.bind.annotation.GetMapping ; import org.springframework.web.bind.annotation.ModelAttribute ; import org.springframework.web.bind.annotation.PostMapping ; import javax.servlet.http.HttpSession ; import javax.validation.Valid ; @Controller public class LoginController { @Autowired UsuarioService usuarioService ; @Autowired ManagerUserSession managerUserSession ; @GetMapping ( \"/\" ) public String home ( Model model ) { return \"redirect:/login\" ; } @GetMapping ( \"/login\" ) public String loginForm ( Model model ) { model . addAttribute ( \"loginData\" , new LoginData ()); return \"formLogin\" ; } @PostMapping ( \"/login\" ) public String loginSubmit ( @ModelAttribute LoginData loginData , Model model , HttpSession session ) { // Llamada al servicio para comprobar si el login es correcto UsuarioService . LoginStatus loginStatus = usuarioService . login ( loginData . geteMail (), loginData . getPassword ()); if ( loginStatus == UsuarioService . LoginStatus . LOGIN_OK ) { Usuario usuario = usuarioService . findByEmail ( loginData . geteMail ()); managerUserSession . logearUsuario ( usuario . getId ()); return \"redirect:/usuarios/\" + usuario . getId () + \"/tareas\" ; } else if ( loginStatus == UsuarioService . LoginStatus . USER_NOT_FOUND ) { model . addAttribute ( \"error\" , \"No existe usuario\" ); return \"formLogin\" ; } else if ( loginStatus == UsuarioService . LoginStatus . ERROR_PASSWORD ) { model . addAttribute ( \"error\" , \"Contrase\u00f1a incorrecta\" ); return \"formLogin\" ; } return \"formLogin\" ; } @GetMapping ( \"/registro\" ) public String registroForm ( Model model ) { model . addAttribute ( \"registroData\" , new RegistroData ()); return \"formRegistro\" ; } @PostMapping ( \"/registro\" ) public String registroSubmit ( @Valid RegistroData registroData , BindingResult result , Model model ) { if ( result . hasErrors ()) { return \"formRegistro\" ; } if ( usuarioService . findByEmail ( registroData . geteMail ()) != null ) { model . addAttribute ( \"registroData\" , registroData ); model . addAttribute ( \"error\" , \"El usuario \" + registroData . geteMail () + \" ya existe\" ); return \"formRegistro\" ; } Usuario usuario = new Usuario ( registroData . geteMail ()); usuario . setPassword ( registroData . getPassword ()); usuario . setFechaNacimiento ( registroData . getFechaNacimiento ()); usuario . setNombre ( registroData . getNombre ()); usuarioService . registrar ( usuario ); return \"redirect:/login\" ; } @GetMapping ( \"/logout\" ) public String logout ( HttpSession session ) { managerUserSession . logout (); return \"redirect:/login\" ; } } Fichero src/main/java/madstodolist/controller/LoginData.java : package madstodolist.controller ; public class LoginData { private String eMail ; private String password ; public String geteMail () { return eMail ; } public void seteMail ( String eMail ) { this . eMail = eMail ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } } Peticiones y rutas \u00b6 Las rutas ( endpoints ) que se definen en los controllers para realizar las acciones de la aplicaci\u00f3n son: LoginController GET /login : devuelve el formulario de login POST /login : realiza el login GET /registro : devuelve el formulario de registro POST /registro : realiza el registro GET /logout : realiza la salida del usuario de la aplicaci\u00f3n TareaController GET /usuarios/{id}/tareas/nueva : devuelve el formulario para a\u00f1adir una tarea al usuario con identificador {id} POST /usuarios/{id}/tareas/nueva : a\u00f1ade una tarea nueva a un usuario GET /usuarios/{id}/tareas : devuelve el listado de tareas de un usuario GET /tareas/{id}/editar\" : devuelve el formulario para editar una tarea POST /tareas/{id}/editar : a\u00f1ade una tarea modificada DELETE /tareas/{id} : realiza el borrado de una tarea Vistas \u00b6 Todas las vistas de la aplicaci\u00f3n comparten la misma cabecera y pie de p\u00e1gina. Para centralizar estos elementos se usa la caracter\u00edstica de fragmentos de Thymeleaf. Los fragmentos comunes se definen en el fichero fragments.html . Fichero src/main/resources/templates/fragments.html : <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:fragment = \"head (titulo)\" > < meta charset = \"UTF-8\" /> < title th:text = \"${titulo}\" ></ title > < link rel = \"stylesheet\" th:href = \"@{/css/bootstrap.min.css}\" > </ head > < div th:fragment = \"javascript\" > < script th:src = \"@{/js/jquery.min.js}\" ></ script > < script th:src = \"@{/js/popper.min.js}\" ></ script > < script th:src = \"@{/js/bootstrap.min.js}\" ></ script > </ div > /html> Vemos que las vistas usan el framework CSS Bootstrap (en concreto, la versi\u00f3n Bootstrap 4.6 ) y varias librer\u00edas JavaScript. Ambos se encuentran en el directorio src/main/resources/static/ , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Spring Boot. La vista principal de la aplicaci\u00f3n es el listado de tareas que vemos a continuaci\u00f3n. Fichero src/main/resources/templates/listaTareas.html : <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:replace = \"fragments :: head (titulo='Login')\" ></ head > < body > < div class = \"container-fluid\" > < div class = \"row mt-3\" > < div class = \"col\" > < h2 th:text = \"'Listado de tareas de ' + ${usuario.nombre}\" ></ h2 > </ div > </ div > < div class = \"row mt-3\" > < div class = \"col\" > < table class = \"table table-striped\" > < thead > < tr > < th > Id </ th > < th > Tarea </ th > < th > Acci\u00f3n </ th > </ tr > </ thead > < tbody > < tr th:each = \"tarea: ${tareas}\" > < td th:text = \"${tarea.id}\" ></ td > < td th:text = \"${tarea.titulo}\" ></ td > < td >< a class = \"btn btn-primary btn-xs\" th:href = \"@{/tareas/{id}/editar(id=${tarea.id})}\" /> editar </ a > < a class = \"btn btn-danger btn-xs\" href = \"#\" onmouseover = \"\" style = \"cursor: pointer;\" th:onclick = \"'del(\\'/tareas/' + ${tarea.id} + '\\')'\" > borrar </ a > </ td > </ tr > </ tbody > </ table > < p >< a class = \"btn btn-primary\" th:href = \"@{/usuarios/{id}/tareas/nueva(id=${usuario.id})}\" > Nueva tarea </ a > < a class = \"btn btn-link\" href = \"/logout\" > Salir </ a ></ p > </ div > </ div > < div class = \"row mt-2\" > < div class = \"col\" > < div class = \"alert alert-success alert-dismissible fade show\" role = \"alert\" th:if = \"${!#strings.isEmpty(mensaje)}\" > < span th:text = \"${mensaje}\" ></ span > < button type = \"button\" class = \"close\" data-dismiss = \"alert\" aria-label = \"Close\" > < span aria-hidden = \"true\" > &times; </ span > </ button > </ div > </ div > </ div > </ div > </ div > < div th:replace = \"fragments::javascript\" /> <!-- Ejemplo de uso de Ajax para lanzar una petici\u00f3n DELETE y borrar una tarea --> < script type = \"text/javascript\" > function del ( urlBorrar ) { if ( confirm ( '\u00bfEst\u00e1s seguro/a de que quieres borrar la tarea?' )) { $ . ajax ({ url : urlBorrar , type : 'DELETE' , success : function ( results ) { //refresh the page location . reload (); } }); } } </ script > </ body > </ html > La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n de iteraci\u00f3n sobre la lista de tares para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se construyen las URLs a las que hacer la petici\u00f3n usando el identificador de la tarea. Autenticaci\u00f3n y control de acceso \u00b6 En la aplicaci\u00f3n se realiza una autenticaci\u00f3n y un control de acceso muy sencillo usando la sesi\u00f3n HTTP (clase HttpSession ). Esta sesi\u00f3n se implementa en Spring Boot con una cookie que se pasa desde el navegador hasta el servidor en cada petici\u00f3n. El manejo de la clase HttpSession es muy sencillo: es un diccionario en el que podemos a\u00f1adir datos. En el servidor podemos obtener los datos de la sesi\u00f3n consultando el diccionario. La implementaci\u00f3n de la autenticaci\u00f3n y del control de acceso se realiza con en la clase ManagerUserSesion : Fichero src/main/java/madstodolist/authentication/ManagerUserSesion.java : package madstodolist.authentication ; import madstodolist.controller.exception.UsuarioNoLogeadoException ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Component ; import javax.servlet.http.HttpSession ; @Component public class ManagerUserSession { @Autowired HttpSession session ; // A\u00f1adimos el id de usuario en la sesi\u00f3n HTTP para hacer // una autorizaci\u00f3n sencilla. En los m\u00e9todos de controllers // comprobamos si el id del usuario logeado coincide con el obtenido // desde la URL public void logearUsuario ( Long idUsuario ) { session . setAttribute ( \"idUsuarioLogeado\" , idUsuario ); } public Long usuarioLogeado () { return ( Long ) session . getAttribute ( \"idUsuarioLogeado\" ); } public void logout () { session . setAttribute ( \"idUsuarioLogeado\" , null ); } } Se implementa como un componente Spring con la anotaci\u00f3n @Component . La referencia a la clase HttpSession se obtiene por inyecci\u00f3n de dependencias con la anotaci\u00f3n de spring Boot @Autowired . La anotaci\u00f3n @Component permite inyectar un ManagerUserSession en los controllers para gestionar all\u00ed el usuario que est\u00e1 logeado y mockearlo en los tests. Pruebas manuales y autom\u00e1ticas \u00b6 Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que vamos introduciendo funcionan correctamente. Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre una base de datos con valores iniciales. Estos valores iniciales se cargan en la aplicaci\u00f3n al comenzar. Fichero src/main/resources/data.sql : /* Populate tables */ INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); En los tests autom\u00e1ticos se cargan los datos de prueba al comienzo de cada test y, usando la anotaci\u00f3n @Sql , se limpian las tablas con el script clean-db.sql . @Sql ( scripts = \"/clean-db.sql\" , executionPhase = AFTER_TEST_METHOD ) public class TareaTest { ... Fichero src/test/resources/clean-db.sql : DELETE FROM tareas ; DELETE FROM usuarios ; Tests de las entidades y de la capa repository \u00b6 Se realizan tests autom\u00e1ticos sobre las entidades y repository: TareaTest.java UsuarioTest.java : Veamos, por ejemplo, el fichero TareaTest.java : Fichero src/test/java/madstodolist/TareaTest.java : package madstodolist ; import madstodolist.model.Tarea ; import madstodolist.model.TareaRepository ; import madstodolist.model.Usuario ; import madstodolist.model.UsuarioRepository ; import org.junit.jupiter.api.Assertions ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.jdbc.Sql ; import org.springframework.transaction.annotation.Transactional ; import java.util.Set ; import static org.assertj.core.api.Assertions.assertThat ; import static org.springframework.test.context.jdbc.Sql.ExecutionPhase.AFTER_TEST_METHOD ; @SpringBootTest @Sql ( scripts = \"/clean-db.sql\" , executionPhase = AFTER_TEST_METHOD ) public class TareaTest { @Autowired UsuarioRepository usuarioRepository ; @Autowired TareaRepository tareaRepository ; // // Tests modelo Tarea en memoria, sin la conexi\u00f3n con la BD // @Test public void crearTarea () { // GIVEN // Un usuario nuevo creado en memoria, sin conexi\u00f3n con la BD, Usuario usuario = new Usuario ( \"juan.gutierrez@gmail.com\" ); // WHEN // se crea una nueva tarea con ese usuario, Tarea tarea = new Tarea ( usuario , \"Pr\u00e1ctica 1 de MADS\" ); // THEN // el t\u00edtulo y el usuario de la tarea son los correctos. assertThat ( tarea . getTitulo ()). isEqualTo ( \"Pr\u00e1ctica 1 de MADS\" ); assertThat ( tarea . getUsuario ()). isEqualTo ( usuario ); } @Test public void laListaDeTareasDeUnUsuarioSeActualizaEnMemoriaConUnaNuevaTarea () { // GIVEN // Un usuario nuevo creado en memoria, sin conexi\u00f3n con la BD, Usuario usuario = new Usuario ( \"juan.gutierrez@gmail.com\" ); // WHEN // se crea una tarea de ese usuario, Set < Tarea > tareas = usuario . getTareas (); Tarea tarea = new Tarea ( usuario , \"Pr\u00e1ctica 1 de MADS\" ); // THEN // la tarea creada se ha a\u00f1adido a la lista de tareas del usuario. assertThat ( usuario . getTareas ()). contains ( tarea ); assertThat ( tareas ). contains ( tarea ); } @Test public void comprobarIgualdadTareasSinId () { // GIVEN // Creadas tres tareas sin identificador, y dos de ellas con // la misma descripci\u00f3n Usuario usuario = new Usuario ( \"juan.gutierrez@gmail.com\" ); Tarea tarea1 = new Tarea ( usuario , \"Pr\u00e1ctica 1 de MADS\" ); Tarea tarea2 = new Tarea ( usuario , \"Pr\u00e1ctica 1 de MADS\" ); Tarea tarea3 = new Tarea ( usuario , \"Pagar el alquiler\" ); // THEN // son iguales (Equal) las tareas que tienen la misma descripci\u00f3n. assertThat ( tarea1 ). isEqualTo ( tarea2 ); assertThat ( tarea1 ). isNotEqualTo ( tarea3 ); } @Test public void comprobarIgualdadTareasConId () { // GIVEN // Creadas tres tareas con distintas descripciones y dos de ellas // con el mismo identificador, Usuario usuario = new Usuario ( \"juan.gutierrez@gmail.com\" ); Tarea tarea1 = new Tarea ( usuario , \"Pr\u00e1ctica 1 de MADS\" ); Tarea tarea2 = new Tarea ( usuario , \"Lavar la ropa\" ); Tarea tarea3 = new Tarea ( usuario , \"Pagar el alquiler\" ); tarea1 . setId ( 1L ); tarea2 . setId ( 2L ); tarea3 . setId ( 1L ); // THEN // son iguales (Equal) las tareas que tienen el mismo identificador. assertThat ( tarea1 ). isEqualTo ( tarea3 ); assertThat ( tarea1 ). isNotEqualTo ( tarea2 ); } // // Tests TareaRepository. // El c\u00f3digo que trabaja con repositorios debe // estar en un entorno transactional, para que todas las peticiones // est\u00e9n en la misma conexi\u00f3n a la base de datos, las entidades est\u00e9n // conectadas y sea posible acceder a colecciones LAZY. // @Test @Transactional public void guardarTareaEnBaseDatos () { // GIVEN // Un usuario en la base de datos. Usuario usuario = new Usuario ( \"user@ua\" ); usuarioRepository . save ( usuario ); Tarea tarea = new Tarea ( usuario , \"Pr\u00e1ctica 1 de MADS\" ); // WHEN // salvamos la tarea en la BD, tareaRepository . save ( tarea ); // THEN // se actualiza el id de la tarea, assertThat ( tarea . getId ()). isNotNull (); // y con ese identificador se recupera de la base de datos la tarea // con los valores correctos de las propiedades y la relaci\u00f3n con // el usuario actualizado tambi\u00e9n correctamente (la relaci\u00f3n entre tarea // y usuario es EAGER). Tarea tareaBD = tareaRepository . findById ( tarea . getId ()). orElse ( null ); assertThat ( tareaBD . getTitulo ()). isEqualTo ( tarea . getTitulo ()); assertThat ( tareaBD . getUsuario ()). isEqualTo ( usuario ); } @Test @Transactional public void salvarTareaEnBaseDatosConUsuarioNoBDLanzaExcepcion () { // GIVEN // Un usuario nuevo que no est\u00e1 en la BD // y una tarea asociada a ese usuario, Usuario usuario = new Usuario ( \"juan.gutierrez@gmail.com\" ); Tarea tarea = new Tarea ( usuario , \"Pr\u00e1ctica 1 de MADS\" ); // WHEN // THEN // se lanza una excepci\u00f3n al intentar salvar la tarea en la BD Assertions . assertThrows ( Exception . class , () -> { tareaRepository . save ( tarea ); }); } @Test @Transactional public void unUsuarioTieneUnaListaDeTareas () { // GIVEN // Un usuario con 2 tareas en la base de datos Usuario usuario = new Usuario ( \"user@ua\" ); usuarioRepository . save ( usuario ); Long usuarioId = usuario . getId (); Tarea tarea1 = new Tarea ( usuario , \"Pr\u00e1ctica 1 de MADS\" ); Tarea tarea2 = new Tarea ( usuario , \"Renovar el DNI\" ); tareaRepository . save ( tarea1 ); tareaRepository . save ( tarea2 ); // WHEN // recuperamos el ususario de la base de datos, Usuario usuarioRecuperado = usuarioRepository . findById ( usuarioId ). orElse ( null ); // THEN // su lista de tareas tambi\u00e9n se recupera, porque se ha // definido la relaci\u00f3n de usuario y tareas como EAGER. assertThat ( usuarioRecuperado . getTareas ()). hasSize ( 2 ); } @Test @Transactional public void a\u00f1adirUnaTareaAUnUsuarioEnBD () { // GIVEN // Un usuario en la base de datos Usuario usuario = new Usuario ( \"user@ua\" ); usuarioRepository . save ( usuario ); Long usuarioId = usuario . getId (); // WHEN // Creamos una nueva tarea con el usuario recuperado de la BD // y la salvamos, Usuario usuarioBD = usuarioRepository . findById ( usuarioId ). orElse ( null ); Tarea tarea = new Tarea ( usuarioBD , \"Pr\u00e1ctica 1 de MADS\" ); tareaRepository . save ( tarea ); Long tareaId = tarea . getId (); // THEN // la tarea queda guardada en la BD asociada al usuario Tarea tareaBD = tareaRepository . findById ( tareaId ). orElse ( null ); assertThat ( tareaBD ). isEqualTo ( tarea ); assertThat ( tarea . getUsuario ()). isEqualTo ( usuarioBD ); // y si recuperamos el usuario se obtiene la nueva tarea usuarioBD = usuarioRepository . findById ( usuarioId ). orElse ( null ); assertThat ( usuarioBD . getTareas ()). contains ( tareaBD ); } @Test @Transactional public void cambioEnLaEntidadEnTransactionalModificaLaBD () { // GIVEN // Un usuario y una tarea en la base de datos Usuario usuario = new Usuario ( \"user@ua\" ); usuarioRepository . save ( usuario ); Tarea tarea = new Tarea ( usuario , \"Pr\u00e1ctica 1 de MADS\" ); tareaRepository . save ( tarea ); // Recuperamos la tarea Long tareaId = tarea . getId (); tarea = tareaRepository . findById ( tareaId ). orElse ( null ); // WHEN // modificamos la descripci\u00f3n de la tarea tarea . setTitulo ( \"Esto es una prueba\" ); // THEN // la descripci\u00f3n queda actualizada en la BD. Tarea tareaBD = tareaRepository . findById ( tareaId ). orElse ( null ); assertThat ( tareaBD . getTitulo ()). isEqualTo ( tarea . getTitulo ()); } } Te recomiendo que leas con cuidado los tests y sus comentarios. Son muy \u00fatiles para entender el funcionamiento de la aplicaci\u00f3n (en este caso de las entidades y de la capa repository ). Utilizamos el formato GIVEN, WHEN, THEN para estructurar el test. En la parte GIVEN se preparan los datos, en la parte WHEN se lanza el m\u00e9todo o m\u00e9todos que se quieren probar y en la parte THEN se comprueban los resultados. Se realizan distintos tipos de tests dentro de la misma clase: Pruebas sobre las entidades por si solas, sin conexi\u00f3n con la base de datos. Son lo que se denomina tests del modelo. Pruebas sobre la capa repository , en las que se comprueban que las operaciones de b\u00fasqueda y actualizaci\u00f3n funcionan correctamente sobre la base de datos. En muchas de estas pruebas se necesita realizar m\u00e1s de una sentencia con la misma conexi\u00f3n a la base de datos o acceder a atributos lazy . Para esto es necesario usar la anotaci\u00f3n @Transactional . Tests de la capa de servicios \u00b6 Tambi\u00e9n se realizan tests sobre la capa de servicio: TareaServiceTest.java UsuarioServiceTest.java Estos tests comprueban que los m\u00e9todos de servicio funcionan correctamente y modifican la base de datos tal y como se pretende en cada operaci\u00f3n. Veamos, por ejemplo, el fichero TareaServiceTest.java : Fichero src/test/java/madstodolist/TareaServiceTest.java : package madstodolist ; import madstodolist.model.Usuario ; import madstodolist.service.UsuarioService ; import madstodolist.service.UsuarioServiceException ; import org.junit.jupiter.api.Assertions ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.jdbc.Sql ; import static org.assertj.core.api.Assertions.assertThat ; import static org.springframework.test.context.jdbc.Sql.ExecutionPhase.AFTER_TEST_METHOD ; @SpringBootTest @Sql ( scripts = \"/clean-db.sql\" , executionPhase = AFTER_TEST_METHOD ) public class UsuarioServiceTest { @Autowired private UsuarioService usuarioService ; // M\u00e9todo para inicializar los datos de prueba en la BD // Devuelve el identificador del usuario de la BD Long addUsuarioBD () { Usuario usuario = new Usuario ( \"user@ua\" ); usuario . setNombre ( \"Usuario Ejemplo\" ); usuario . setPassword ( \"123\" ); usuario = usuarioService . registrar ( usuario ); return usuario . getId (); } @Test public void servicioLoginUsuario () { // GIVEN // Un usuario en la BD addUsuarioBD (); // WHEN // intentamos logear un usuario y contrase\u00f1a correctos UsuarioService . LoginStatus loginStatus1 = usuarioService . login ( \"user@ua\" , \"123\" ); // intentamos logear un usuario correcto, con una contrase\u00f1a incorrecta UsuarioService . LoginStatus loginStatus2 = usuarioService . login ( \"user@ua\" , \"000\" ); // intentamos logear un usuario que no existe, UsuarioService . LoginStatus loginStatus3 = usuarioService . login ( \"pepito.perez@gmail.com\" , \"12345678\" ); // THEN // el valor devuelto por el primer login es LOGIN_OK, assertThat ( loginStatus1 ). isEqualTo ( UsuarioService . LoginStatus . LOGIN_OK ); // el valor devuelto por el segundo login es ERROR_PASSWORD, assertThat ( loginStatus2 ). isEqualTo ( UsuarioService . LoginStatus . ERROR_PASSWORD ); // y el valor devuelto por el tercer login es USER_NOT_FOUND. assertThat ( loginStatus3 ). isEqualTo ( UsuarioService . LoginStatus . USER_NOT_FOUND ); } @Test public void servicioRegistroUsuario () { // GIVEN // Creado un usuario nuevo, con una contrase\u00f1a Usuario usuario = new Usuario ( \"usuario.prueba2@gmail.com\" ); usuario . setPassword ( \"12345678\" ); // WHEN // registramos el usuario, usuarioService . registrar ( usuario ); // THEN // el usuario se a\u00f1ade correctamente al sistema. Usuario usuarioBaseDatos = usuarioService . findByEmail ( \"usuario.prueba2@gmail.com\" ); assertThat ( usuarioBaseDatos ). isNotNull (); assertThat ( usuarioBaseDatos . getPassword ()). isEqualTo ( usuario . getPassword ()); } @Test public void servicioRegistroUsuarioExcepcionConNullPassword () { // GIVEN // Un usuario creado sin contrase\u00f1a, Usuario usuario = new Usuario ( \"usuario.prueba@gmail.com\" ); // WHEN, THEN // intentamos registrarlo, se produce una excepci\u00f3n de tipo UsuarioServiceException Assertions . assertThrows ( UsuarioServiceException . class , () -> { usuarioService . registrar ( usuario ); }); } @Test public void servicioRegistroUsuarioExcepcionConEmailRepetido () { // GIVEN // Un usuario en la BD addUsuarioBD (); // WHEN // Creamos un usuario con un e-mail ya existente en la base de datos, Usuario usuario = new Usuario ( \"user@ua\" ); usuario . setPassword ( \"12345678\" ); // THEN // si lo registramos, se produce una excepci\u00f3n de tipo UsuarioServiceException Assertions . assertThrows ( UsuarioServiceException . class , () -> { usuarioService . registrar ( usuario ); }); } @Test public void servicioRegistroUsuarioDevuelveUsuarioConId () { // GIVEN // Dado un usuario con contrase\u00f1a nuevo y sin identificador, Usuario usuario = new Usuario ( \"usuario.prueba@gmail.com\" ); usuario . setPassword ( \"12345678\" ); // WHEN // lo registramos en el sistema, usuarioService . registrar ( usuario ); // THEN // se actualiza el identificador del usuario assertThat ( usuario . getId ()). isNotNull (); // con el identificador que se ha guardado en la BD. Usuario usuarioBD = usuarioService . findById ( usuario . getId ()); assertThat ( usuarioBD ). isEqualTo ( usuario ); } @Test public void servicioConsultaUsuarioDevuelveUsuario () { // GIVEN // Un usuario en la BD Long usuarioId = addUsuarioBD (); // WHEN // recuperamos un usuario usando su e-mail, Usuario usuario = usuarioService . findByEmail ( \"user@ua\" ); // THEN // el usuario obtenido es el correcto. assertThat ( usuario . getId ()). isEqualTo ( usuarioId ); assertThat ( usuario . getEmail ()). isEqualTo ( \"user@ua\" ); assertThat ( usuario . getNombre ()). isEqualTo ( \"Usuario Ejemplo\" ); } } Para conseguir que los tests sean independientes y evitar que datos introducidos o modificados en un test afecten a otros tests, limpiamos las tablas de la base de datos al final de cada test usando la anotaci\u00f3n @Sql : @Sql ( scripts = \"/clean-db.sql\" , executionPhase = AFTER_TEST_METHOD ) public class TareaServiceTest { Los datos de prueba se introducen al principio de cada test. Tests de la capa controller \u00b6 Por \u00faltimo, tambi\u00e9n realizamos tests sobre los controllers: UsuarioWebTest.java TareaWebTest.java En estos tests se comprueba que el resultado de realizar un GET o un POST sobre los endpoints correspondientes devuelven un HTML que contiene alguna cadena que coincide con lo esperado. Existen dos enfoques a la hora de definir estos tests. Podemos, al igual que hemos hecho en los tests de servicio, introducir los datos de prueba al comienzo de cada test. Podemos mockear los servicios para que devuelvan los datos que nos interesan. Utilizamos ambos enfoques para que aprendas a trabajar con los dos. En la clase TareaWebTest se utilizan los datos de prueba de la base de datos y en la clase UsuarioWebTest se mockean los servicios. La utilizaci\u00f3n de mocks es muy \u00fatil tambi\u00e9n para poder testear los m\u00e9todos que tienen un acceso restringido al usuario que hace la operaci\u00f3n. Por ejemplo, la consulta o modificaci\u00f3n de una tarea. Mockeamos el managerUserSession para simular que el usuario est\u00e1 logeado. Mostramos a continuaci\u00f3n los ficheros de test de controllers. Fichero src/test/java/madstodolist/TareaWebTest.java : package madstodolist ; import madstodolist.authentication.ManagerUserSession ; import madstodolist.model.Tarea ; import madstodolist.model.Usuario ; import madstodolist.service.TareaService ; import madstodolist.service.UsuarioService ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.mock.mockito.MockBean ; import org.springframework.test.context.jdbc.Sql ; import org.springframework.test.web.servlet.MockMvc ; import static org.hamcrest.Matchers.* ; import static org.mockito.Mockito.when ; import static org.springframework.test.context.jdbc.Sql.ExecutionPhase.AFTER_TEST_METHOD ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.* ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.* ; @SpringBootTest @AutoConfigureMockMvc @Sql ( scripts = \"/clean-db.sql\" , executionPhase = AFTER_TEST_METHOD ) public class TareaWebTest { @Autowired private MockMvc mockMvc ; // Declaramos los servicios como Autowired @Autowired private TareaService tareaService ; @Autowired private UsuarioService usuarioService ; // Moqueamos el managerUserSession para poder moquear el usuario logeado @MockBean private ManagerUserSession managerUserSession ; class DosIds { Long usuarioId ; Long tareaId ; public DosIds ( Long usuarioId , Long tareaId ) { this . usuarioId = usuarioId ; this . tareaId = tareaId ; } } // M\u00e9todo para inicializar los datos de prueba en la BD // Devuelve una pareja de identificadores del usuario y la primera tarea a\u00f1adida DosIds addUsuarioTareasBD () { Usuario usuario = new Usuario ( \"user@ua\" ); usuario . setPassword ( \"123\" ); usuario = usuarioService . registrar ( usuario ); Tarea tarea1 = tareaService . nuevaTareaUsuario ( usuario . getId (), \"Lavar coche\" ); tareaService . nuevaTareaUsuario ( usuario . getId (), \"Renovar DNI\" ); return new DosIds ( usuario . getId (), tarea1 . getId ()); } @Test public void listaTareas () throws Exception { // GIVEN // Un usuario con dos tareas en la BD Long usuarioId = addUsuarioTareasBD (). usuarioId ; // Moqueamos el m\u00e9todo usuarioLogeado para que devuelva el usuario 1L, // el mismo que se est\u00e1 usando en la petici\u00f3n. De esta forma evitamos // que salte la excepci\u00f3n de que el usuario que est\u00e1 haciendo la // petici\u00f3n no est\u00e1 logeado. when ( managerUserSession . usuarioLogeado ()). thenReturn ( usuarioId ); // WHEN, THEN // se realiza la petici\u00f3n GET al listado de tareas del usuario, // el HTML devuelto contiene las descripciones de sus tareas. String url = \"/usuarios/\" + usuarioId . toString () + \"/tareas\" ; this . mockMvc . perform ( get ( url )) . andExpect (( content (). string ( allOf ( containsString ( \"Lavar coche\" ), containsString ( \"Renovar DNI\" ) )))); } @Test public void getNuevaTareaDevuelveForm () throws Exception { // GIVEN // Un usuario con dos tareas en la BD Long usuarioId = addUsuarioTareasBD (). usuarioId ; // Ver el comentario en el primer test when ( managerUserSession . usuarioLogeado ()). thenReturn ( usuarioId ); // WHEN, THEN // si ejecutamos una petici\u00f3n GET para crear una nueva tarea de un usuario, // el HTML resultante contiene un formulario y la ruta con // la acci\u00f3n para crear la nueva tarea. String urlPeticion = \"/usuarios/\" + usuarioId . toString () + \"/tareas/nueva\" ; String urlAction = \"action=\\\"/usuarios/\" + usuarioId . toString () + \"/tareas/nueva\\\"\" ; this . mockMvc . perform ( get ( urlPeticion )) . andExpect (( content (). string ( allOf ( containsString ( \"form method=\\\"post\\\"\" ), containsString ( urlAction ) )))); } @Test public void postNuevaTareaDevuelveRedirectYA\u00f1adeTarea () throws Exception { // GIVEN // Un usuario con dos tareas en la BD Long usuarioId = addUsuarioTareasBD (). usuarioId ; // Ver el comentario en el primer test when ( managerUserSession . usuarioLogeado ()). thenReturn ( usuarioId ); // WHEN, THEN // realizamos la petici\u00f3n POST para a\u00f1adir una nueva tarea, // el estado HTTP que se devuelve es un REDIRECT al listado // de tareas. String urlPost = \"/usuarios/\" + usuarioId . toString () + \"/tareas/nueva\" ; String urlRedirect = \"/usuarios/\" + usuarioId . toString () + \"/tareas\" ; this . mockMvc . perform ( post ( urlPost ) . param ( \"titulo\" , \"Estudiar examen MADS\" )) . andExpect ( status (). is3xxRedirection ()) . andExpect ( redirectedUrl ( urlRedirect )); // y si despu\u00e9s consultamos el listado de tareas con una petici\u00f3n // GET el HTML contiene la tarea a\u00f1adida. this . mockMvc . perform ( get ( urlRedirect )) . andExpect (( content (). string ( containsString ( \"Estudiar examen MADS\" )))); } @Test public void deleteTareaDevuelveOKyBorraTarea () throws Exception { // GIVEN // Un usuario con dos tareas en la BD DosIds dosIds = addUsuarioTareasBD (); Long usuarioId = dosIds . usuarioId ; Long tareaLavarCocheId = dosIds . tareaId ; // Ver el comentario en el primer test when ( managerUserSession . usuarioLogeado ()). thenReturn ( usuarioId ); // WHEN, THEN // realizamos la petici\u00f3n DELETE para borrar una tarea, // se devuelve el estado HTTP que se devuelve es OK, String urlDelete = \"/tareas/\" + tareaLavarCocheId . toString (); this . mockMvc . perform ( delete ( urlDelete )) . andExpect ( status (). isOk ()); // y cuando se pide un listado de tareas del usuario, la tarea borrada ya no aparece. String urlListado = \"/usuarios/\" + usuarioId + \"/tareas\" ; this . mockMvc . perform ( get ( urlListado )) . andExpect ( content (). string ( allOf ( not ( containsString ( \"Lavar coche\" )), containsString ( \"Renovar DNI\" )))); } @Test public void editarTareaActualizaLaTarea () throws Exception { // GIVEN // Un usuario con dos tareas en la BD DosIds dosIds = addUsuarioTareasBD (); Long usuarioId = dosIds . usuarioId ; Long tareaLavarCocheId = dosIds . tareaId ; // Ver el comentario en el primer test when ( managerUserSession . usuarioLogeado ()). thenReturn ( usuarioId ); // WHEN, THEN // realizamos una petici\u00f3n POST al endpoint para editar una tarea String urlEditar = \"/tareas/\" + tareaLavarCocheId + \"/editar\" ; String urlRedirect = \"/usuarios/\" + usuarioId + \"/tareas\" ; this . mockMvc . perform ( post ( urlEditar ) . param ( \"titulo\" , \"Limpiar cristales coche\" )) . andExpect ( status (). is3xxRedirection ()) . andExpect ( redirectedUrl ( urlRedirect )); // Y si realizamos un listado de las tareas del usuario // ha cambiado el t\u00edtulo de la tarea modificada String urlListado = \"/usuarios/\" + usuarioId + \"/tareas\" ; this . mockMvc . perform ( get ( urlListado )) . andExpect ( content (). string ( containsString ( \"Limpiar cristales coche\" ))); } } Fichero src/test/java/madstodolist/UsuarioWebTest.java : package madstodolist ; import madstodolist.model.Usuario ; import madstodolist.service.UsuarioService ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.mock.mockito.MockBean ; import org.springframework.test.web.servlet.MockMvc ; import static org.hamcrest.Matchers.containsString ; import static org.mockito.Mockito.when ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.* ; @SpringBootTest @AutoConfigureMockMvc // // A diferencia de los tests web de tarea, donde us\u00e1bamos los datos // de prueba de la base de datos, aqu\u00ed vamos a practicar otro enfoque: // moquear el usuarioService. public class UsuarioWebTest { @Autowired private MockMvc mockMvc ; // Moqueamos el usuarioService. // En los tests deberemos proporcionar el valor devuelto por las llamadas // a los m\u00e9todos de usuarioService que se van a ejecutar cuando se realicen // las peticiones a los endpoint. @MockBean private UsuarioService usuarioService ; @Test public void servicioLoginUsuarioOK () throws Exception { // GIVEN // Moqueamos la llamada a usuarioService.login para que // devuelva un LOGIN_OK y la llamada a usuarioServicie.findByEmail // para que devuelva un usuario determinado. Usuario anaGarcia = new Usuario ( \"ana.garcia@gmail.com\" ); anaGarcia . setId ( 1L ); when ( usuarioService . login ( \"ana.garcia@gmail.com\" , \"12345678\" )) . thenReturn ( UsuarioService . LoginStatus . LOGIN_OK ); when ( usuarioService . findByEmail ( \"ana.garcia@gmail.com\" )) . thenReturn ( anaGarcia ); // WHEN, THEN // Realizamos una petici\u00f3n POST al login pasando los datos // esperados en el mock, la petici\u00f3n devolver\u00e1 una redirecci\u00f3n a la // URL con las tareas del usuario this . mockMvc . perform ( post ( \"/login\" ) . param ( \"eMail\" , \"ana.garcia@gmail.com\" ) . param ( \"password\" , \"12345678\" )) . andExpect ( status (). is3xxRedirection ()) . andExpect ( redirectedUrl ( \"/usuarios/1/tareas\" )); } @Test public void servicioLoginUsuarioNotFound () throws Exception { // GIVEN // Moqueamos el m\u00e9todo usuarioService.login para que devuelva // USER_NOT_FOUND when ( usuarioService . login ( \"pepito.perez@gmail.com\" , \"12345678\" )) . thenReturn ( UsuarioService . LoginStatus . USER_NOT_FOUND ); // WHEN, THEN // Realizamos una petici\u00f3n POST con los datos del usuario mockeado y // se debe devolver una p\u00e1gina que contenga el mensaja \"No existe usuario\" this . mockMvc . perform ( post ( \"/login\" ) . param ( \"eMail\" , \"pepito.perez@gmail.com\" ) . param ( \"password\" , \"12345678\" )) . andExpect ( content (). string ( containsString ( \"No existe usuario\" ))); } @Test public void servicioLoginUsuarioErrorPassword () throws Exception { // GIVEN // Moqueamos el m\u00e9todo usuarioService.login para que devuelva // ERROR_PASSWORD when ( usuarioService . login ( \"ana.garcia@gmail.com\" , \"000\" )) . thenReturn ( UsuarioService . LoginStatus . ERROR_PASSWORD ); // WHEN, THEN // Realizamos una petici\u00f3n POST con los datos del usuario mockeado y // se debe devolver una p\u00e1gina que contenga el mensaja \"Contrase\u00f1a incorrecta\" this . mockMvc . perform ( post ( \"/login\" ) . param ( \"eMail\" , \"ana.garcia@gmail.com\" ) . param ( \"password\" , \"000\" )) . andExpect ( content (). string ( containsString ( \"Contrase\u00f1a incorrecta\" ))); } } 4. Metodolog\u00eda de desarrollo \u00b6 En cuanto a la metodolog\u00eda de desarrollo, en esta pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues, labels, milestones, etc. JUnit y las caracter\u00edsticas de testing de Spring Boot para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Existen muchos proyectos que tienen un desarrollo abierto, transparente, en GitHub. Podemos aprender de sus metodolog\u00edas estudi\u00e1ndolos. A continuaci\u00f3n listamos ejemplos de repositorios en GitHub interesantes, en los que podemos estudiar los procesos de pull requests , issues, tableros, etc. y las din\u00e1micas de comunicaci\u00f3n que utilizan. CartoDB . Software espa\u00f1ol para representaci\u00f3n visual de datos geogr\u00e1ficos. Vapor . Framework web en Swift. Guice . Framework de inyecci\u00f3n de dependencias en Java. swift-nio . Framework as\u00edncrono de entrada-salida en Swift. Spring Boot . Framework web en Java. Git \u00b6 Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento. Resumen de comandos de Git : Resumen de comandos principales para empezar a trabajar con Git. Atlassian Git Tutorials : Tutoriales muy orientados al uso de Git con gran cantidad de ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos Getting Started y los tutoriales Syncing y Using Branches en el apartado Collaborating . Libro de Scott Chacon : Completo manual con todos los detalles de todos los comandos de Git. Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto. Flujo de trabajo \u00b6 Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub ) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian . Para implementar este flujo de trabajo utilizaremos los siguientes instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo: Issues ( incidencias ): GitHub permite abrir issues (incidencias o tareas), asignarlos a personas, realizar comentarios, asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha terminado. Consultar Mastering Issues . Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: bug , technical , enhancement . Los issues que implementan una historia de usuario los etiquetaremos con el c\u00f3digo de la historia de usuario. Puede haber m\u00e1s de un issue asociado con una historia de usuario y de esta forma podemos agruparlos. Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama main haciendo un pull request. Pull Requests : Un pull request permite avisar al equipo de que se va a integrar en la rama principal una rama con un desarrollo nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se pueden realizar comentarios, revisiones de c\u00f3digo o definir pol\u00edticas de aceptaci\u00f3n del PR. Consultar About pull requests . Implementaremos cada issue en una rama separada de git y la integraremos en la rama main haciendo un pull request . Cuando se mezcle el PR en main el issue se cerrar\u00e1. M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido releases para incluir en ella las releases del proyecto. Milestones y Releases : Etiquetaremos cada issue con el milestone en el que queremos que se lance. Para identificar el milestone usaremos el versionado sem\u00e1ntico : MAJOR.MINOR.PATCH. Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues ese milestone). Tablero de proyecto : Un tablero de proyecto en GitHub nos ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada issue: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar, implementar, probar, etc. Vamos a utilizar la funcionalidad propia de GitHub llamada Projects . Consultar Quickstart for Projects Cuando se crea un pull request que resuelve un issue enlazaremos el issue con el pull request. Podremos ver en el tablero que bajo el issue aparece su PR enlazado y podremos desplegarlo en la propia tarjeta (funcionalidad nueva de GitHub). Tambi\u00e9n utilizaremos un panel de Trello para representar las historias de usuario que se van implementando en el proyecto. Cada historia de usuario tendr\u00e1 un c\u00f3digo num\u00e9rico y podr\u00e1 implementarse con uno o m\u00e1s issues. En GitHub crearemos una etiqueta por cada historia de usuario y se la asignaremos a los issues que se usen para implementarla. Importante Puede parecer redundante el uso de dos tableros, uno para las historias de usuario y otro para los issues y PR . La justificaci\u00f3n es que los objetivos de ambos tableros son distintos (y los contenidos tambi\u00e9n). El tablero Trello es un tablero de funcionalidades de usuario , que es gestionado por el product owner , usado por el equipo de desarrollo y puede ser compartido tambi\u00e9n con clientes y gerencia. En la terminolog\u00eda de Scrum ser\u00e1 el product backlog . Mientras que el tablero de GitHub ser\u00e1 un tablero t\u00e9cnico gestionado por el equipo de desarrollo. En terminolog\u00eda de Scrum ser\u00e1 el sprint backlog . La documentaci\u00f3n en Trello y en GitHub (en los issues, en los PRs y en el propio README.md del proyecto) hay que escribirla en Markdown , un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub . Nota Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira , YouTrack o Confluence . Pero la combinaci\u00f3n de GitHub + Trello es suficiente para lo que vamos a realizar en la asignatura y para aprender los objetivos y el funcionamiento de estos tipos de sistemas basados en incidencias. 5. Antes de empezar la pr\u00e1ctica \u00b6 Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente tu repositorio mads-todolist-<usuario> en la organizaci\u00f3n mads-ua . Al igual que el repositorio de la primera parte de la pr\u00e1ctica es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-22-23 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas. Descarga el proyecto y comprueba que se compila y ejecuta correctamente: $ git clone https://github.com/mads-ua/mads-todolist-<usuario>.git $ cd mads-todolist-<usuario> $ ./mvnw spring-boot:run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:8080/login en la m\u00e1quina host. Para la aplicaci\u00f3n haciendo CTR+C en el terminal. Importa el proyecto en IntelliJ para trabajar, ejecutar los tests y lanzar la aplicaci\u00f3n desde este entorno. Es posible examinar el esquema de la base de datos y los datos accediendo a la base de datos H2 en memoria a\u00f1adiendo las siguientes preferencias: spring . h2 . console . enabled = true spring . h2 . console . path =/ h2 - console Una vez lanzada la aplicaci\u00f3n, podemos acceder a http://localhost:8080/h2-console introduciendo como JDBC URL la direcci\u00f3n de la fuente de datos jdbc:h2:mem:dev y como User name la cadena sa Y examinar tablas en concreto: 6. Desarrollo de la pr\u00e1ctica \u00b6 En esta primera pr\u00e1ctica vamos a desarrollar las siguientes historias de usuario o features: P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de usuarios P\u00e1gina descripci\u00f3n de usuario Usuario administrador (opcional) Protecci\u00f3n del listado y descripci\u00f3n de usuarios (opcional) Bloqueo de usuarios por el usuario administrador (opcional) La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : tablero Trello, issues, pull requests (con sus commits en los que se desarrolla paso a paso cada issue) y tablero del proyecto. Haremos paso a paso la historia de usuario 1, creando la primera versi\u00f3n 1.0.1 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0. Versi\u00f3n 1.0.1 \u00b6 La versi\u00f3n 1.0.1 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de . Tablero Trello \u00b6 Crea un en Trello un tablero p\u00fablico llamado ToDoList MADS . Va a servir como backlog de las historias de usuario que debes realizar en la pr\u00e1ctica. A\u00f1ade en \u00e9l 3 columnas, tal y se explica en el apartado anterior de metodolog\u00eda de desarrollo. A\u00f1ade el enlace en la descripci\u00f3n del repositorio GitHub, para que el profesor pueda acceder a consultar el estado del proyecto. Un ejemplo de tablero es el Trello del proyecto mads-todolist-inicial . Utilizaremos el tablero Trello para documentar las caracter\u00edsticas a desarrollar en la aplicaci\u00f3n. Deber\u00e1 haber una tarjeta para cada caracter\u00edstica. Cada caracter\u00edstica deber\u00e1 tener un n\u00famero y un t\u00edtulo. A\u00f1ade la descripci\u00f3n de la caracter\u00edstica P\u00e1gina Acerca de : Cuando empecemos a trabajar en la historia de usuario moveremos la tarjeta a En marcha y cuando la hayamos terminado de testear e integrar en la rama principal la moveremos a Terminadas . Tablero de GitHub \u00b6 GitHub ha cambiado recientemente la forma de gestionar visualmente los issues para hacerla mucho m\u00e1s flexible y potente. En la versi\u00f3n actual, la funcionalidad se denomina Proyectos . Un proyecto est\u00e1 asociado a un usuario de GitHub y puede contener issues de m\u00e1s de un repositorio. Un usuario puede crear los proyectos que considere necesarios. Tambi\u00e9n se pueden crear proyectos asociados a organizaciones. En cuanto a la forma de visualizar los issues, podemos seleccionar dos formas: como un tablero o como una hoja de c\u00e1lculo. La primera forma es m\u00e1s sencilla y la segunda m\u00e1s potente. En la asignatura usaremos la primera. Puedes encontrar m\u00e1s informaci\u00f3n sobre los GitHub Projects en este enlace . En la asignatura vamos a usar los proyectos de GitHub para mostrar, en forma de tablero, los issues del repositorio de la pr\u00e1ctica. Tambi\u00e9n podremos acceder a los pull requests desde cada uno de los issues (enlazaremos los issues a su pull request). Aviso Aunque se han a\u00f1adido en los apuntes las nuevas im\u00e1genes sobre el proceso de creaci\u00f3n de un proyecto, no se han actualizado todas las im\u00e1genes en las que aparece el tablero de proyectos, por lo que puede que alguna imagen no represente fielmente la aparencia real que tiene en la actualidad. Lo primero que debes hacer es crear un proyecto desde el enlace Projects en la organizaci\u00f3n mads-ua-22-23 . Selecciona la opci\u00f3n Board y ponle como nombre tu usuario de GitHub : Define una columna adicional In Pull Request , entre In Progress y Done : En las columnas colocaremos los issues del proyecto (y los PRs estar\u00e1n enlazados en ellos). GitHub permite automatizar el movimiento de las tarjetas de una columna a otra. Activa dos flujos de trabajo. Uno para que cuando un issue nuevo se a\u00f1ada al proyecto se coloque en la columna To Do : Y otro para que cuando se cierre un issue se mueva a la columna de Done : El resto de cambios de los issues los tendr\u00e1s que hacer manualmente. Por ejemplo, cuando crees el pull request asociado a un issue tendr\u00e1s que mover el issue a la columna de In Pull Request . En resumen, las condiciones de las fichas que habr\u00e1 en cada columna son las siguientes: Columna To do : Nuevos issues a\u00f1adidos al proyecto. Cuando a\u00f1adimos el proyecto al issue (en la p\u00e1gina del issue) GitHub lo coloca autom\u00e1ticamente en esta columna. Columna In progress : issues que se han comenzado a implementar (se ha creado una rama su desarrollo). Manual. Columna In pull request : moveremos a esta columna el issue abramos un PR y lo enlacemos con el issue. Manual. GitHub lo coloca autom\u00e1ticamente en esta columna. implementado por el pull request manualmente. Columna Done : pull requests cerrados. GitHub lo detecta autom\u00e1ticamente. Por \u00faltimo, en la opci\u00f3n Settings > Manage access comparte el tablero con mi usuario de GitHub domingogallardo , para que pueda revisarlo: Y cambia el base role a modo No access para solo tengan acceso al tablero las personas colaboradoras. Por \u00faltimo, desde la p\u00e1gina Projects del repositorio, a\u00f1ade el proyecto al repositorio: Issues \u00b6 A\u00f1ade en el proyecto las etiquetas que vamos a usar inicialmente. Crea el primer issue, correspondiente a la feature a desarrollar P\u00e1gina Acerca de . Crea el milestone 1.0.1. Y, desde la p\u00e1gina del issue, a\u00f1ade el milestone y el proyecto. Autom\u00e1ticamente se a\u00f1adir\u00e1 en la columna To Do . En el listado de issues del repositorio debe aparecer este reci\u00e9n creado: Desarrollo \u00b6 Para desarrollar el issue abriremos una rama en Git, realizaremos commits sobre ella hasta estar terminado y despu\u00e9s crearemos un pull request en GitHub para realizar la integraci\u00f3n con la rama main . Mueve en el tablero la tarjeta con el issue a la columna In progress . Empezamos el desarrollo importando el proyecto en IntelliJ y abriendo un terminal para trabajar con Git: En el terminal escribimos los comandos para crear la rama en la que desarrollaremos la feature y subirla: (main) $ git checkout -b acerca-de (acerca-de) $ git push -u origin acerca-de Primer commit \u00b6 Hacemos un primer commit. Cambia en pom.xml el nombre del proyecto ( artifactId ) a mads-todolist-<tu-nombre> y la versi\u00f3n a 1.0.1-SNAPSHOT . El sufijo SNAPSHOT indica en desarrollo . Cuando hagamos el release de la versi\u00f3n 1.0.1 eliminaremos el sufijo. Realiza el commit y s\u00fabelo a GitHub: (acerca-de) $ git status (comprobamos los ficheros que han cambiado) On branch acerca-de Your branch is up to date with 'origin/acerca-de'. Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git checkout -- <file>...\" to discard changes in working directory) modified: README.md modified: pom.xml no changes added to commit (use \"git add\" and/or \"git commit -a\") (acerca-de) $ git add . (acerca-de) $ git status (comprobamos que est\u00e1 listo para a\u00f1adirse en el commit) (acerca-de) $ git commit -m \"Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.1\" On branch acerca-de Your branch is up to date with 'origin/acerca-de'. Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) modified: README.md modified: pom.xml (acerca-de) $ git push Consulta en GitHub que el commit se ha subido en GitHub: De esta forma habr\u00e1s comprobado que tienes permiso de escritura en el repositorio y que ya puedes comenzar a realizar la pr\u00e1ctica. Segundo commit \u00b6 En el segundo commit incluiremos el desarrollo de los elementos necesarios para la p\u00e1gina acerca de : Acci\u00f3n en controller Vista A\u00f1ade los siguientes ficheros: Controller main/java/madstodolist/controller/HomeController.java package madstodolist.controller ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.web.bind.annotation.GetMapping ; @Controller public class HomeController { @GetMapping ( \"/about\" ) public String about ( Model model ) { return \"about\" ; } } Vista main/resources/templates/about.html : <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:replace = \"fragments :: head (titulo='Acerca de')\" ></ head > < body > < div class = \"container-fluid\" > < div class = \"container-fluid\" > < h1 > ToDoList </ h1 > < ul > < li > Desarrollada por TU NOMBRE </ li > < li > Versi\u00f3n 1.0.1 (en desarrollo) </ li > < li > Fecha de release: pendiente de release </ li > </ ul > </ div > </ div > < div th:replace = \"fragments::javascript\" /> </ body > </ html > Prueba la p\u00e1gina accediendo a la url http://localhost:8080/about . A\u00f1ade un test que automatiza la comprobaci\u00f3n de que la URL /about debe devolver el nombre de la aplicaci\u00f3n. Test test/java/madstodolist/AcercaDeWebTest.java : package madstodolist ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.web.servlet.MockMvc ; import static org.hamcrest.Matchers.containsString ; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get ; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content ; @SpringBootTest @AutoConfigureMockMvc public class AcercaDeWebTest { @Autowired private MockMvc mockMvc ; @Test public void getAboutDevuelveNombreAplicacion () throws Exception { this . mockMvc . perform ( get ( \"/about\" )) . andExpect ( content (). string ( containsString ( \"ToDoList\" ))); } } Puedes lanzar el test pulsando en IntelliJ con el bot\u00f3n derecho en el fichero (en el panel del proyecto) y seleccionando la opci\u00f3n Run AcercaDeWebTest . Puedes lanzar tambi\u00e9n todos los tests en el terminal para comprobar que no se ha roto nada. (acerca-de) $ ./mvnw test ... [INFO] [INFO] Tests run: 34, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 21.879 s Por \u00faltimo, confirma el commit en la rama y s\u00fabelo a GitHub. En el panel Git : (acerca-de) $ git add . (acerca-de) $ git status (comprueba que se han a\u00f1adido los ficheros) (acerca-de) $ git commit -m \"A\u00f1adida vista y controller 'about'\" (acerca-de) $ git push Tercer commit \u00b6 En el tercer commit pondremos un enlace a la p\u00e1gina acerca de en la p\u00e1gina de login de la aplicaci\u00f3n. Realiza el siguiente cambio: Fichero formLogin.html : <a class=\"btn btn-link\" href=\"/registro\">Ir a registro</a> + <a class=\"btn btn-link\" href=\"/about\">Acerca de</a> </div> </form> Prueba que funciona correctamente, prueba los tests, haz el commit y s\u00fabelo a GitHub: (acerca-de) $ git status (acerca-de) $ git add . (acerca-de) $ git commit -m \"A\u00f1adido enlace a p\u00e1gina 'about' en p\u00e1gina 'login'\" (acerca-de) $ git push Pull request \u00b6 Una vez terminada la implementaci\u00f3n de la feature en la rama, creamos un pull request en GitHub para indicar que estamos listos para mezclar la rama con la feature con la rama principal de desarrollo ( main ). Creaci\u00f3n del pull request \u00b6 Accede en GitHub a la rama acerca-de y comprueba que se han subido todos los cambios pulsando Compare . Aparecer\u00e1 la siguiente p\u00e1gina, con la informaci\u00f3n de los cambios que introducen todos los commits de la rama: Pulsa despu\u00e9s el bot\u00f3n Create pull request para crear el pull request. Escribe como t\u00edtulo del PR: A\u00f1adida p\u00e1gina 'Acerca de' y en el comentario escribe: Closes #1 Ver\u00e1s que al escribir #1 aparecer\u00e1 el nombre del issue. Si escribes s\u00f3lo # ver\u00e1s una lista de los \u00faltimos issues. De esta forma estamos enlazando el PR con el issue. Cuando se cierre el pull request se cerrar\u00e1 autom\u00e1ticamente el issue. Tambi\u00e9n podremos acceder desde el issue al PR enlazado. Pulsa en el bot\u00f3n para crear el pull request. Debe quedar la siguiente pantalla en la que informa del PR reci\u00e9n creado: En el proyecto mueve la tarjeta con el issue a la columna In Pull Request . Ver\u00e1s que se ha a\u00f1adido en la parte inferior de la tarjeta un desplegable con la informaci\u00f3n sobre el PR enlazado. En este momento los compa\u00f1eros del equipo podr\u00edan revisar el pull request y el c\u00f3digo que se va a introducir. En la propia p\u00e1gina del pull request es posible conversar y realizar comentarios que puede aclarar el autor del PR. Y tambi\u00e9n es posible subir nuevos commits con modificaciones o ampliaciones correspondientes a las sugerencias indicadas. Haremos esto en futuras pr\u00e1cticas. Podemos ver que GitHub informa de que no hay conflictos con la rama main y que es posible hacer el merge en GitHub. Antes de pulsar el bot\u00f3n para realizar el merge, lanzamos los tests (estando en la rama) para comprobar que no se ha roto nada y que los tests que se han a\u00f1adido pasan correctamente (en este caso no hemos a\u00f1adido ninguno). (acerca-de) $ ./mvnw test ... [INFO] [INFO] Tests run: 34, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 21.879 s Veremos en la pr\u00f3xima pr\u00e1ctica c\u00f3mo configurar GitHub para que esta comprobaci\u00f3n se haga de forma autom\u00e1tica en GitHub. Aunque deber\u00edamos tambi\u00e9n comprobar que los tests pasan correctamente despu\u00e9s de mezclar la rama con main , dejamos de hacer esta comprobaci\u00f3n porque a partir de la pr\u00f3xima pr\u00e1ctica lo haremos tambi\u00e9n de forma autom\u00e1tica en GitHub. Pulsa el bot\u00f3n de Merge pull request (con la opci\u00f3n por defecto Create a merge commit ) y conf\u00edrmalo. Borra la rama en GitHub, pulsando el bot\u00f3n correspondiente. Este merge lo has hecho en GitHub. Debes por \u00faltimo integrarlo en tu repositorio local. En el terminal: (acerca-de) $ git checkout main (main) $ git pull (bajamos los cambios) (main) $ git branch -d acerca-de (borramos la rama) (main) $ git remote prune origin (borramos referencias a rama remota) (main) $ git log --oneline --graph --all * 9527ae2 (HEAD -> main, origin/main, origin/HEAD) Merge pull request #2 from mads-ua-18/acerca-de |\\ | * 672c28f A\u00f1adido enlace a p\u00e1gina 'about' en p\u00e1gina 'login' | * 3fdfb83 A\u00f1adida ruta, vista y controller 'about' | * a332017 Cambiado el nombre del proyecto y empezamos versi\u00f3n 1.0.0 |/ * 6767016 Commit inicial Comprobamos tambi\u00e9n la historia de commits en GitHub. Aparecer\u00e1 el commit de merge introducido por el pull request. De esta forma hemos cerrado el PR e integrado su c\u00f3digo en la rama principal de desarrollo. El issue ligado al PR se habr\u00e1 cerrado autom\u00e1ticamente y en el tablero de proyecto debe haber cambiado la tarjeta a la columna Done . Actualizamos tablero Trello \u00b6 Actualizamos el tablero Trello moviendo la historia de usuario a la columna Terminadas . Release 1.0.1 \u00b6 Vamos a ver por \u00faltimo c\u00f3mo crear un release y poner en producci\u00f3n la aplicaci\u00f3n. Lo vamos a hacer ahora como ejemplo, creando el release 1.0.1 y tendr\u00e1s que hacerlo otra vez m\u00e1s al final de la pr\u00e1ctica, creando el release 1.1.0. Para hacer el release haremos un commit directamente sobre la rama main (m\u00e1s adelante explicaremos una forma m\u00e1s elaborada de hacer un release, cuando expliquemos el flujo de trabajo de GitFlow). Crea un commit con la confirmaci\u00f3n del n\u00famero de versi\u00f3n y fecha en los ficheros pom.xml y about.html Fichero pom.xml : <groupId>es.ua.mads</groupId> <artifactId>mads-todolist-dgallardo</artifactId> - <version>1.0.1-SNAPSHOT</version> + <version>1.0.1</version> Fichero about.html : <h1>ToDo List</h1> <ul> <h1>ToDo List</h1> <ul> <li>Desarrollada por Domingo Gallardo</li> - <li>Versi\u00f3n 1.0.1 (en desarrollo)</li> - <li>Fecha de release: pendiente de release</li> + <li>Versi\u00f3n 1.0.1</li> + <li>Fecha de release: 17/9/2018</li> </ul> } A\u00f1adimos el commit y lo subimos a GitHub (main) $ git add . (main) $ git commit -m \"Cambio de versi\u00f3n a 1.0.1\" (main) $ git push Y creamos la versi\u00f3n 1.0.1 en GitHub pulsando en el enlace Create a new release en la p\u00e1gina principal: Un release en GitHub se guarda como una una etiqueta Git, junto con informaci\u00f3n asociada. Se suelen indicar las nuevas features a\u00f1adidas en el release mediante enlaces a los pull requests a\u00f1adidos. El resultado ser\u00e1: Puesta en producci\u00f3n \u00b6 Debes por \u00faltimo poner en producci\u00f3n la nueva versi\u00f3n, igual que hicimos en la pr\u00e1ctica 1, creando una imagen Docker, subi\u00e9ndola a Docker Hub y poni\u00e9ndola en ejecuci\u00f3n en el servidor de la asignatura. Para crear la imagen Docker primero debes crear el fichero JAR con la aplicaci\u00f3n: $ ./mvnw package $ ls -l target/*.jar target/mads-todolist-domingogallardo-1.0.1.jar Y despu\u00e9s construir la imagen docker: $ docker build -t <usuario-docker>/mads-todolist . Sube la m\u00e1quina a Docker Hub (autom\u00e1ticamente se etiquetara como latest ). Y etiqueta la m\u00e1quina docker con la versi\u00f3n 1.0.1 y s\u00fabela tambi\u00e9n. $ docker push <usuario-docker>/mads-todolist Using default tag: latest $ docker tag <usuario-docker>/mads-todolist <usuario-docker>/mads-todolist:1.0.1 $ docker push <usuario-docker>/mads-todolist:1.0.1 Con\u00e9ctate al servidor de la asignatura, descarga en \u00e9l la m\u00e1quina Docker y pon en producci\u00f3n la aplicaci\u00f3n. Comprueba que todo funciona correctamente y despu\u00e9s para y borra el contenedor y la imagen. En clase de pr\u00e1cticas deber\u00e1s hacer lo mismo y el profesor revisar\u00e1 que la aplicaci\u00f3n en producci\u00f3n funciona correctamente. Resto de la pr\u00e1ctica (versi\u00f3n 1.1.0) \u00b6 El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 3 opcionales: (Obligatoria) Barra de men\u00fa (Obligatoria) P\u00e1gina de listado de usuarios (Obligatoria) P\u00e1gina de descripci\u00f3n de un usuario (Opcional) Usuario administrador (Opcional) Protecci\u00f3n listado y descripci\u00f3n de usuario (Opcional) Administrador puede bloquear el acceso a usuarios Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio, as\u00ed como los nuevos controllers y vistas a\u00f1adidos. Barra de men\u00fa \u00b6 La aplicaci\u00f3n deber\u00e1 tener una barra de men\u00fa com\u00fan a todas sus p\u00e1ginas, menos en las p\u00e1ginas de login y registro. La barra de men\u00fa estar\u00e1 situada en la parte superior de la p\u00e1gina y ser\u00e1 un Navbar de Bootstrap. La barra de men\u00fa tendr\u00e1 como m\u00ednimo los siguientes elementos (de izquierda a derecha): ToDoList : enlace a la p\u00e1gina acerca de . Tareas : enlace a la p\u00e1gina de tareas, con la lista de tareas pendientes del usuario. Nombre usuario : A la derecha de la p\u00e1gina. Desplegable con las opciones: Cuenta : Futura p\u00e1gina para gestionar la cuenta Cerrar sesi\u00f3n <nombre usuario> : cierra la sesi\u00f3n y lleva a la p\u00e1gina de login. En la p\u00e1gina acerca de se debe cambiar la barra de men\u00fa dependiendo de si el usuario est\u00e1 o no logeado. Si est\u00e1 logeado ser\u00e1 la barra com\u00fan con el resto de las p\u00e1ginas. Si el usuario no est\u00e1 logeado, aparecer\u00e1n enlaces a las p\u00e1ginas de login y registro. Listado de usuarios \u00b6 Si se introduce la URL /registrados aparecer\u00e1 un listado de los usuarios registrados (identificador y correo electr\u00f3nico). Descripci\u00f3n de usuario \u00b6 En la lista de usuarios habr\u00e1 un enlace para acceder a su descripci\u00f3n. En la descripci\u00f3n de un usuario aparecer\u00e1n todos sus datos, menos la contrase\u00f1a. La ruta para obtener la descripci\u00f3n de un usuario registrado ser\u00e1 /registrados/:id . Usuario administrador (opcional) \u00b6 Al realizar el registro ser\u00e1 posible darse de alta como usuario administrador. Para darse de alta como administrador se deber\u00e1 activar un check box en la p\u00e1gina de registro. S\u00f3lo puede haber un administrador. Si ya existe un administrador, no debe aparecer el check box en la p\u00e1gina de registro. El usuario administrador acceder\u00e1 directamente a la lista de usuarios. Protecci\u00f3n de listado de usuario y descripci\u00f3n de usuario (opcional) \u00b6 Proteger las p\u00e1ginas con el listado de usuarios y la descripci\u00f3n de usuario para que s\u00f3lo las pueda consultar el administrador. En el caso en que un usuario no administrador intente acceder a esas p\u00e1ginas, devolver un c\u00f3digo de error HTTP \"No autorizado\" y un mensaje indicando que no se tiene suficiente permiso (de forma similar a como se gestionan los accesos a las p\u00e1ginas de tareas sin estar logeado). Bloqueo de usuarios por usuario administrador (opcional) \u00b6 A\u00f1adir en el listado de usuarios un bot\u00f3n para que el administrador pueda bloquear o habilitar el acceso a cada uno de los usuarios. Si el usuario tiene bloqueado el acceso cuando intente logearse aparecer\u00e1 un mensaje de error indic\u00e1ndoselo. 7. Documentaci\u00f3n, entrega y evaluaci\u00f3n \u00b6 Deber\u00e1s a\u00f1adir una p\u00e1gina documentaci\u00f3n /doc/practica2.md en la que debes realizar una breve documentaci\u00f3n t\u00e9cnica de entre 500 y 800 palabras. Debes suponer que est\u00e1s trabajando con un equipo de desarrollo y que debes dejar una breve documentaci\u00f3n para que el resto del equipo sepa c\u00f3mo ha evolucionado la implementaci\u00f3n de la aplicaci\u00f3n. No debe ser una manual de usuario, no es una documentaci\u00f3n para el cliente . Por ejemplo, la documentaci\u00f3n podr\u00eda contener: Listado de nuevas clases y m\u00e9todos implementados. Listado de plantillas thyemeleaf a\u00f1adidas. Explicaci\u00f3n de los tests implementados. Explicaci\u00f3n de c\u00f3digo fuente relevante de las nuevas funcionalidades implementadas. Obligatoriamente debes incluir en la documentaci\u00f3n alg\u00fan ejemplo de c\u00f3digo fuente que has a\u00f1adido y que consideres interesante y su explicaci\u00f3n. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 18 de octubre. El profesor comprobar\u00e1 en clase de pr\u00e1cticas el funcionamiento de la pr\u00e1ctica en producci\u00f3n. La parte obligatoria punt\u00faa sobre 6 y la opcional sobre 4 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Correcto funcionamiento. Documentaci\u00f3n.","title":"Pr\u00e1ctica 2"},{"location":"02-todolist/practica2.html#practica-2-aplicacion-todolist","text":"","title":"Pr\u00e1ctica 2: Aplicaci\u00f3n ToDoList"},{"location":"02-todolist/practica2.html#1-objetivos","text":"En pr\u00e1ctica 2 vamos a trabajar sobre la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . Esta parte tendr\u00e1 una duraci\u00f3n de cuatro semanas. Deber\u00e1s realizarla de forma individual, siguiendo las indicaciones que encontrar\u00e1s en este documento. Tendr\u00e1s que desarrollar c\u00f3digo y trabajar en GitHub desarrollando issues , pull requests , releases y actualizando los tableros del proyecto (en Trello y en GitHub). Al igual que en la pr\u00e1ctica 1 usaremos GitHub Classroom para crear un repositorio individual con el que realizar\u00e1s la pr\u00e1ctica. El proyecto base ser\u00e1 la aplicaci\u00f3n inicial domingogallardo/mads-todolist-inicial . En este repositorio se ha seguido una metodolog\u00eda similar a la que vamos a utilizar en este pr\u00e1ctica y puedes examinarlo para ver distintos elementos: Issues cerrados Pull Requests mezclados Tablero de issues Tablero Trello de historias de usuario Debes leer la introducci\u00f3n a Spring Boot para entender los conceptos fundamentales del framework.","title":"1. Objetivos"},{"location":"02-todolist/practica2.html#2-aplicacion-inicial","text":"La aplicaci\u00f3n con la que vamos a trabajar es una t\u00edpica aplicaci\u00f3n ToDo que sirve para gestionar tareas pendientes. Se pueden registrar y logear usuarios y los usuarios registrados pueden a\u00f1adir, modificar y borrar tareas pendientes de hacer. A continuaci\u00f3n puedes ver dos de las pantallas de la aplicaci\u00f3n. Pantalla de login Pantalla con listado de tareas Iremos desarrollando caracter\u00edsticas adicionales de la aplicaci\u00f3n a lo largo de las pr\u00e1cticas. El nombre de la aplicaci\u00f3n es mads-todolist .","title":"2. Aplicaci\u00f3n inicial"},{"location":"02-todolist/practica2.html#3-la-aplicacion-todolist","text":"La aplicaci\u00f3n mads-todolist-inicial es la versi\u00f3n inicial de la aplicaci\u00f3n que se va a desarrollar durante toda la asignatura. Es una aplicaci\u00f3n bastante m\u00e1s compleja que la vista en la pr\u00e1ctica 1. Entre otros, tiene los siguientes elementos: Distintos comandos HTTP: GET, POST, DELETE. Recogida de datos en formularios HTML y validaci\u00f3n de los datos. Base de datos gestionada con JPA ( Java Persisence API ), un ORM ( Object Relational Mapping ) implementado por la librer\u00eda Hibernate. Se utiliza una capa de persistencia basada en clases repository . Capa de servicio que proporciona la l\u00f3gica de negocio a los controllers. Las clases controller s\u00f3lo se encargan de hacer de interfaz de la capa de servicio: Recoger datos de la petici\u00f3n HTTP, tratar y validar estas entradas, llamar a la clase de servicio para que se realice la acci\u00f3n requerida, y convertir la respuesta obtenida de la aplicaci\u00f3n en una vista que se devuelve como respuesta de la petici\u00f3n. En las plantillas se incluye Bootstrap y scripts JavaScript. Las clases de servicio y de repository se obtienen por inyecci\u00f3n de dependencias. Gran n\u00famero de tests que prueban la capa de servicios y la de presentaci\u00f3n. Vamos a ver con un poco m\u00e1s de detalle d\u00f3nde puedes encontrar en el c\u00f3digo todos estos elementos.","title":"3. La aplicaci\u00f3n ToDoList"},{"location":"02-todolist/practica2.html#configuracion-de-la-aplicacion","text":"Los distintos par\u00e1metros de la aplicaci\u00f3n Spring Boot se configuran un fichero de propiedades. El fichero de propiedades por defecto es application.properties . Fichero /src/main/resources/application.properties : spring.application.name = mads-todolist spring.datasource.url = jdbc:h2:mem:dev spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect spring.jpa.hibernate.ddl-auto = update logging.level.org.hibernate.SQL = debug logging.level.madstodolist = debug spring.sql.init.mode = always # cargar los datos despues de que Hibernate inicialice # los esquemas de datos # https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes#sql-script-datasource-initialization spring.jpa.defer-datasource-initialization = true spring.h2.console.enabled = true spring.h2.console.path = /h2-console # Deshabilitamos Open EntityManager in View # https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/html/data.html#data.sql.jpa-and-spring-data.open-entity-manager-in-view # Ver tambien https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/hibernate5/support/OpenSessionInViewInterceptor.html # y https://www.baeldung.com/spring-open-session-in-view spring.jpa.open-in-view = false Entre otras cosas, se define las caracter\u00edsticas de la fuente de datos con la que trabaja la aplicaci\u00f3n (la base de datos en memoria H2): El par\u00e1metro spring.jpa.hibernate.ddl-auto=update hace que Hibernate actualice autom\u00e1ticamente los esquemas de la base de datos, construy\u00e9ndolos a partir de las clases Entity . En un entorno de producci\u00f3n el valor de esta propiedad deber\u00e1 ser validate para no modificar la base de datos de producci\u00f3n. El par\u00e1metro spring.sql.init.mode=always hace que se carguen datos iniciales en la base de datos al arrancar la aplicaci\u00f3n. El par\u00e1metro spring.jpa.defer-datasource-initialization=true hace que los datos se carguen despu\u00e9s de que Hibernate haya actualizado el esquema de datos. Los datos iniciales de la aplicaci\u00f3n se encuentran en el fichero data.sql : Fichero /src/main/resources/data.sql : /* Populate tables */ INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); Base de datos H2 en memoria en desarrollo En esta pr\u00e1ctica vamos a trabajar \u00fanicamente con la base de datos en memoria. Esto significa que los datos que introduzcamos van a estar presentes mientras que la aplicaci\u00f3n est\u00e9 funcionando. Cuando matemos la aplicaci\u00f3n y la volvamos a reiniciar s\u00f3lo estar\u00e1n los datos iniciales, los datos que se cargan del fichero data.sql . En la pr\u00e1ctica 3 utilizaremos una base de datos real, que deberemos gestionar tambi\u00e9n en producci\u00f3n. En concreto, se tratar\u00e1 de una base de datos PostgresSQL. Por \u00faltimo, el par\u00e1metro spring.jpa.open-in-view=false deshabilita una caracter\u00edstica de Spring denominada open in view que mantiene abierta la conexi\u00f3n de la base de datos de forma autom\u00e1tica en cada petici\u00f3n HTTP. Se trata de una caracter\u00edstica que facilita el trabajo con las relaciones lazy entre entidades, pero puede introducir errores no deseados al permitir acceder a la base de datos en la capa controller . Al deshabilitar esta caracter\u00edstica tendremos que gestionar manualmente las relaciones lazy , recuper\u00e1ndolas en la capa de servicio, en donde s\u00ed que mantenemos abierta la conexi\u00f3n con la base de datos. Lo veremos m\u00e1s adelante con m\u00e1s detalle.","title":"Configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"02-todolist/practica2.html#gestion-de-persistencia-con-jpa","text":"Para la gesti\u00f3n de la persistencia de los datos en la aplicaci\u00f3n Spring Boot usaremos Spring Data JPA . Se trata de un API de Spring Boot que se construye sobre JPA ( Java Persistence API ), el ORM ( Object Relational Mapping ) est\u00e1ndar de Java. La implementaci\u00f3n de JPA que utiliza Spring Boot es Hibernate . Spring Data JPA usa todos los conceptos de JPA y a\u00f1ade algunos adicionales que facilitan aun m\u00e1s su utilizaci\u00f3n, como es la definici\u00f3n de interfaces Repository con m\u00e9todos CRUD est\u00e1ndar para las entidades.","title":"Gesti\u00f3n de persistencia con JPA"},{"location":"02-todolist/practica2.html#servicios","text":"La capa de servicios es la capa intermedia entre la capa de controllers y la de repository . Es la capa que implementa toda la l\u00f3gica de negocio de la aplicaci\u00f3n. La responsabilidad principal de la capa de servicios es crear, obtener o modificar los objetos entidad necesarios para cada funcionalidad a partir de los datos que manda la capa controller , trabajar con ellos en memoria y hacer persistentes los cambios utilizando la capa repository . La capa de servicios tambi\u00e9n gestionar\u00e1 errores y lanzar\u00e1 excepciones cuando no se pueda realizar alguna funcionalidad. Los servicios obtienen instancias de Repository usando inyecci\u00f3n de dependencias. Como hemos comentado anteriormente, los m\u00e9todos de la capa de servicios estar\u00e1n anotados con @Transactional actualizar correctamente la base de datos y las conexiones lazy y para garantizar la transaccionalidad. Por ejemplo, la clase UsuarioService se define como se muestra a continuaci\u00f3n. Fichero src/main/java/madstodolist/service/UsuarioService.java : npackage madstodolist . service ; import madstodolist.model.Usuario ; import madstodolist.model.UsuarioRepository ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import org.springframework.transaction.annotation.Transactional ; import java.util.Optional ; @Service public class UsuarioService { public enum LoginStatus { LOGIN_OK , USER_NOT_FOUND , ERROR_PASSWORD } @Autowired private UsuarioRepository usuarioRepository ; @Transactional ( readOnly = true ) public LoginStatus login ( String eMail , String password ) { Optional < Usuario > usuario = usuarioRepository . findByEmail ( eMail ); if ( ! usuario . isPresent ()) { return LoginStatus . USER_NOT_FOUND ; } else if ( ! usuario . get (). getPassword (). equals ( password )) { return LoginStatus . ERROR_PASSWORD ; } else { return LoginStatus . LOGIN_OK ; } } // Se a\u00f1ade un usuario en la aplicaci\u00f3n. // El email y password del usuario deben ser distinto de null // El email no debe estar registrado en la base de datos @Transactional public Usuario registrar ( Usuario usuario ) { Optional < Usuario > usuarioBD = usuarioRepository . findByEmail ( usuario . getEmail ()); if ( usuarioBD . isPresent ()) throw new UsuarioServiceException ( \"El usuario \" + usuario . getEmail () + \" ya est\u00e1 registrado\" ); else if ( usuario . getEmail () == null ) throw new UsuarioServiceException ( \"El usuario no tiene email\" ); else if ( usuario . getPassword () == null ) throw new UsuarioServiceException ( \"El usuario no tiene password\" ); else return usuarioRepository . save ( usuario ); } @Transactional ( readOnly = true ) public Usuario findByEmail ( String email ) { return usuarioRepository . findByEmail ( email ). orElse ( null ); } @Transactional ( readOnly = true ) public Usuario findById ( Long usuarioId ) { return usuarioRepository . findById ( usuarioId ). orElse ( null ); } } Fichero src/main/java/madstodolist/service/UsuarioServiceException.java : package madstodolist.service ; public class UsuarioServiceException extends RuntimeException { public UsuarioServiceException ( String message ) { super ( message ); } } Ventajas de utilizar una capa de servicios Al utilizar clases de servicios podemos aislar la l\u00f3gica de negocio de la aplicaci\u00f3n usando m\u00e9todos y objetos Java, sin preocuparnos de c\u00f3mo obtener los datos de la interfaz de usuario ni de c\u00f3mo mostrar los resultados. De esto ya se ocupar\u00e1n las clases controller . De esta forma, si se necesita modificar la interfaz de usuario de la aplicaci\u00f3n, o convertirla en un servicio REST que devuelva JSON en lugar de HTML s\u00f3lo tendremos que tocar las clases controller , no las de servicio. Adem\u00e1s, al no tener ninguna dependencia con la interfaz de usuario, estas clases de servicios tambi\u00e9n podr\u00e1n ser f\u00e1cilmente testeadas. La mayor\u00eda de los tests autom\u00e1ticos los haremos sobre ellas.","title":"Servicios"},{"location":"02-todolist/practica2.html#controllers","text":"Las clases controllers son las que gestionan la interfaz de usuario de la aplicaci\u00f3n. Se encargan de recibir los datos de las peticiones HTTP, llamar a la clase de servicio necesaria para procesar la l\u00f3gica de negocio y mostrar la vista con la informaci\u00f3n resultante proporcionada por la clase de servicio. En la aplicaci\u00f3n se definen dos clases controller: LoginController : con m\u00e9todos para registrar y logear usuarios. TareasController : con m\u00e9todos para crear, borrar y modificar tareas de un usuario. Los controllers usan clases auxiliares en las que se guardan los datos introducidos en los formularios. Por ejemplo, la clase LoginController usa las clases LoginData y RegistroData . Fichero src/main/java/madstodolist/controller/LoginController.java : package madstodolist.controller ; import madstodolist.authentication.ManagerUserSession ; import madstodolist.model.Usuario ; import madstodolist.service.TareaService ; import madstodolist.service.UsuarioService ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.Model ; import org.springframework.validation.BindingResult ; import org.springframework.web.bind.annotation.GetMapping ; import org.springframework.web.bind.annotation.ModelAttribute ; import org.springframework.web.bind.annotation.PostMapping ; import javax.servlet.http.HttpSession ; import javax.validation.Valid ; @Controller public class LoginController { @Autowired UsuarioService usuarioService ; @Autowired ManagerUserSession managerUserSession ; @GetMapping ( \"/\" ) public String home ( Model model ) { return \"redirect:/login\" ; } @GetMapping ( \"/login\" ) public String loginForm ( Model model ) { model . addAttribute ( \"loginData\" , new LoginData ()); return \"formLogin\" ; } @PostMapping ( \"/login\" ) public String loginSubmit ( @ModelAttribute LoginData loginData , Model model , HttpSession session ) { // Llamada al servicio para comprobar si el login es correcto UsuarioService . LoginStatus loginStatus = usuarioService . login ( loginData . geteMail (), loginData . getPassword ()); if ( loginStatus == UsuarioService . LoginStatus . LOGIN_OK ) { Usuario usuario = usuarioService . findByEmail ( loginData . geteMail ()); managerUserSession . logearUsuario ( usuario . getId ()); return \"redirect:/usuarios/\" + usuario . getId () + \"/tareas\" ; } else if ( loginStatus == UsuarioService . LoginStatus . USER_NOT_FOUND ) { model . addAttribute ( \"error\" , \"No existe usuario\" ); return \"formLogin\" ; } else if ( loginStatus == UsuarioService . LoginStatus . ERROR_PASSWORD ) { model . addAttribute ( \"error\" , \"Contrase\u00f1a incorrecta\" ); return \"formLogin\" ; } return \"formLogin\" ; } @GetMapping ( \"/registro\" ) public String registroForm ( Model model ) { model . addAttribute ( \"registroData\" , new RegistroData ()); return \"formRegistro\" ; } @PostMapping ( \"/registro\" ) public String registroSubmit ( @Valid RegistroData registroData , BindingResult result , Model model ) { if ( result . hasErrors ()) { return \"formRegistro\" ; } if ( usuarioService . findByEmail ( registroData . geteMail ()) != null ) { model . addAttribute ( \"registroData\" , registroData ); model . addAttribute ( \"error\" , \"El usuario \" + registroData . geteMail () + \" ya existe\" ); return \"formRegistro\" ; } Usuario usuario = new Usuario ( registroData . geteMail ()); usuario . setPassword ( registroData . getPassword ()); usuario . setFechaNacimiento ( registroData . getFechaNacimiento ()); usuario . setNombre ( registroData . getNombre ()); usuarioService . registrar ( usuario ); return \"redirect:/login\" ; } @GetMapping ( \"/logout\" ) public String logout ( HttpSession session ) { managerUserSession . logout (); return \"redirect:/login\" ; } } Fichero src/main/java/madstodolist/controller/LoginData.java : package madstodolist.controller ; public class LoginData { private String eMail ; private String password ; public String geteMail () { return eMail ; } public void seteMail ( String eMail ) { this . eMail = eMail ; } public String getPassword () { return password ; } public void setPassword ( String password ) { this . password = password ; } }","title":"Controllers"},{"location":"02-todolist/practica2.html#vistas","text":"Todas las vistas de la aplicaci\u00f3n comparten la misma cabecera y pie de p\u00e1gina. Para centralizar estos elementos se usa la caracter\u00edstica de fragmentos de Thymeleaf. Los fragmentos comunes se definen en el fichero fragments.html . Fichero src/main/resources/templates/fragments.html : <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:fragment = \"head (titulo)\" > < meta charset = \"UTF-8\" /> < title th:text = \"${titulo}\" ></ title > < link rel = \"stylesheet\" th:href = \"@{/css/bootstrap.min.css}\" > </ head > < div th:fragment = \"javascript\" > < script th:src = \"@{/js/jquery.min.js}\" ></ script > < script th:src = \"@{/js/popper.min.js}\" ></ script > < script th:src = \"@{/js/bootstrap.min.js}\" ></ script > </ div > /html> Vemos que las vistas usan el framework CSS Bootstrap (en concreto, la versi\u00f3n Bootstrap 4.6 ) y varias librer\u00edas JavaScript. Ambos se encuentran en el directorio src/main/resources/static/ , el directorio por defecto en el que se guardan los recursos est\u00e1ticos de una aplicaci\u00f3n Spring Boot. La vista principal de la aplicaci\u00f3n es el listado de tareas que vemos a continuaci\u00f3n. Fichero src/main/resources/templates/listaTareas.html : <!DOCTYPE html> < html xmlns:th = \"http://www.thymeleaf.org\" > < head th:replace = \"fragments :: head (titulo='Login')\" ></ head > < body > < div class = \"container-fluid\" > < div class = \"row mt-3\" > < div class = \"col\" > < h2 th:text = \"'Listado de tareas de ' + ${usuario.nombre}\" ></ h2 > </ div > </ div > < div class = \"row mt-3\" > < div class = \"col\" > < table class = \"table table-striped\" > < thead > < tr > < th > Id </ th > < th > Tarea </ th > < th > Acci\u00f3n </ th > </ tr > </ thead > < tbody > < tr th:each = \"tarea: ${tareas}\" > < td th:text = \"${tarea.id}\" ></ td > < td th:text = \"${tarea.titulo}\" ></ td > < td >< a class = \"btn btn-primary btn-xs\" th:href = \"@{/tareas/{id}/editar(id=${tarea.id})}\" /> editar </ a > < a class = \"btn btn-danger btn-xs\" href = \"#\" onmouseover = \"\" style = \"cursor: pointer;\" th:onclick = \"'del(\\'/tareas/' + ${tarea.id} + '\\')'\" > borrar </ a > </ td > </ tr > </ tbody > </ table > < p >< a class = \"btn btn-primary\" th:href = \"@{/usuarios/{id}/tareas/nueva(id=${usuario.id})}\" > Nueva tarea </ a > < a class = \"btn btn-link\" href = \"/logout\" > Salir </ a ></ p > </ div > </ div > < div class = \"row mt-2\" > < div class = \"col\" > < div class = \"alert alert-success alert-dismissible fade show\" role = \"alert\" th:if = \"${!#strings.isEmpty(mensaje)}\" > < span th:text = \"${mensaje}\" ></ span > < button type = \"button\" class = \"close\" data-dismiss = \"alert\" aria-label = \"Close\" > < span aria-hidden = \"true\" > &times; </ span > </ button > </ div > </ div > </ div > </ div > </ div > < div th:replace = \"fragments::javascript\" /> <!-- Ejemplo de uso de Ajax para lanzar una petici\u00f3n DELETE y borrar una tarea --> < script type = \"text/javascript\" > function del ( urlBorrar ) { if ( confirm ( '\u00bfEst\u00e1s seguro/a de que quieres borrar la tarea?' )) { $ . ajax ({ url : urlBorrar , type : 'DELETE' , success : function ( results ) { //refresh the page location . reload (); } }); } } </ script > </ body > </ html > La plantilla recibe una lista de tareas, un usuario y un mensaje (consultar en el controller TareasController c\u00f3mo se obtienen esos datos). Define un script JavaScript en el que se realiza una petici\u00f3n DELETE a la URL que se le pasa como par\u00e1metro (se utilizar\u00e1 para lanzar la acci\u00f3n de borrar una tarea). Utiliza una instrucci\u00f3n de iteraci\u00f3n sobre la lista de tares para construir los elementos de la tabla de tareas. En las acciones de a\u00f1adir y editar tareas se construyen las URLs a las que hacer la petici\u00f3n usando el identificador de la tarea.","title":"Vistas"},{"location":"02-todolist/practica2.html#pruebas-manuales-y-automaticas","text":"Durante el desarrollo de la pr\u00e1ctica ser\u00e1 necesario realizar pruebas manuales de la aplicaci\u00f3n, introducir datos en sus pantallas y comprobar que los cambios que vamos introduciendo funcionan correctamente. Para estas pruebas manuales recomendamos utilizar la configuraci\u00f3n de ejecuci\u00f3n trabajando sobre una base de datos con valores iniciales. Estos valores iniciales se cargan en la aplicaci\u00f3n al comenzar. Fichero src/main/resources/data.sql : /* Populate tables */ INSERT INTO usuarios ( id , email , nombre , password , fecha_nacimiento ) VALUES ( '1' , 'user@ua' , 'Usuario Ejemplo' , '123' , '2001-02-10' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '1' , 'Lavar coche' , '1' ); INSERT INTO tareas ( id , titulo , usuario_id ) VALUES ( '2' , 'Renovar DNI' , '1' ); En los tests autom\u00e1ticos se cargan los datos de prueba al comienzo de cada test y, usando la anotaci\u00f3n @Sql , se limpian las tablas con el script clean-db.sql . @Sql ( scripts = \"/clean-db.sql\" , executionPhase = AFTER_TEST_METHOD ) public class TareaTest { ... Fichero src/test/resources/clean-db.sql : DELETE FROM tareas ; DELETE FROM usuarios ;","title":"Pruebas manuales y autom\u00e1ticas"},{"location":"02-todolist/practica2.html#4-metodologia-de-desarrollo","text":"En cuanto a la metodolog\u00eda de desarrollo, en esta pr\u00e1ctica repasaremos e introduciremos el uso de: Git como sistema de control de versiones que nos permitir\u00e1 registrar paso a paso los cambios realizados en el desarrollo, realizando e integrando ramas de features en las que desarrollaremos peque\u00f1os incrementos que a\u00f1adir\u00e1n poco a poco las funcionalidades necesarias en la aplicaci\u00f3n. GitHub como servicio en el que publicaremos los cambios e integraremos las ramas usando pull requests (PRs). Utilizaremos un gran n\u00famero de caracter\u00edsticas de GitHub para realizar el seguimiento del desarrollo del proyecto: issues, labels, milestones, etc. JUnit y las caracter\u00edsticas de testing de Spring Boot para realizar continuamente pruebas unitarias que validen el desarrollo. El objetivo es desarrollar software de una forma similar a c\u00f3mo se hace en cientos de proyectos punteros de desarrollo open source . Existen muchos proyectos que tienen un desarrollo abierto, transparente, en GitHub. Podemos aprender de sus metodolog\u00edas estudi\u00e1ndolos. A continuaci\u00f3n listamos ejemplos de repositorios en GitHub interesantes, en los que podemos estudiar los procesos de pull requests , issues, tableros, etc. y las din\u00e1micas de comunicaci\u00f3n que utilizan. CartoDB . Software espa\u00f1ol para representaci\u00f3n visual de datos geogr\u00e1ficos. Vapor . Framework web en Swift. Guice . Framework de inyecci\u00f3n de dependencias en Java. swift-nio . Framework as\u00edncrono de entrada-salida en Swift. Spring Boot . Framework web en Java.","title":"4. Metodolog\u00eda de desarrollo"},{"location":"02-todolist/practica2.html#git","text":"Git es el sistema de control de versiones m\u00e1s utilizado en la actualidad. Es muy flexible, distribuido, adaptable a m\u00faltiples flujos de trabajo e ideal para una metodolog\u00eda de desarrollo en equipo. Suponemos que ya tienes cierta experiencia con su uso. Puedes usar los siguientes enlaces para repasar su funcionamiento. Resumen de comandos de Git : Resumen de comandos principales para empezar a trabajar con Git. Atlassian Git Tutorials : Tutoriales muy orientados al uso de Git con gran cantidad de ejemplos. Es recomendable repasar los tutoriales b\u00e1sicos Getting Started y los tutoriales Syncing y Using Branches en el apartado Collaborating . Libro de Scott Chacon : Completo manual con todos los detalles de todos los comandos de Git. Cuando utilicemos git es muy importante realizar unos mensajes de commit claros. Un mensaje de commit es la forma de comunicar a los compa\u00f1eros del equipo qu\u00e9 cambios se han introducido en la aplicaci\u00f3n y ponerlos en contexto (explicar por qu\u00e9 se han hecho, dar alg\u00fan detalle de implementaci\u00f3n, etc.). El post How to Write a Git Commit Message explica muy bien esto.","title":"Git"},{"location":"02-todolist/practica2.html#flujo-de-trabajo","text":"Desarrollaremos la aplicaci\u00f3n de forma iterativa, utilizando inicialmente un flujo de trabajo Git denominado feature branch (consultar la gu\u00eda de GitHub ) en el que cada caracter\u00edstica nueva se implementa en una rama separada que despu\u00e9s se mezcla con la rama principal de desarrollo. M\u00e1s adelante veremos otros flujos de trabajo. Puedes ver una introducci\u00f3n a distintos flujos de trabajo b\u00e1sicos con Git en este documento de Atlassian . Para implementar este flujo de trabajo utilizaremos los siguientes instrumentos de GitHub que facilitan la comunicaci\u00f3n entre los miembros del equipo: Issues ( incidencias ): GitHub permite abrir issues (incidencias o tareas), asignarlos a personas, realizar comentarios, asignar etiquetas y cerrarlos cuando la implementaci\u00f3n ha terminado. Consultar Mastering Issues . Definiremos distintos tipos de issues en funci\u00f3n de su prop\u00f3sito: bug , technical , enhancement . Los issues que implementan una historia de usuario los etiquetaremos con el c\u00f3digo de la historia de usuario. Puede haber m\u00e1s de un issue asociado con una historia de usuario y de esta forma podemos agruparlos. Cada issue se desarrollar\u00e1 en una rama de Git y se integrar\u00e1 en la rama main haciendo un pull request. Pull Requests : Un pull request permite avisar al equipo de que se va a integrar en la rama principal una rama con un desarrollo nuevo. Cuando creamos un PR, GitHub crea una p\u00e1gina en la que se pueden realizar comentarios, revisiones de c\u00f3digo o definir pol\u00edticas de aceptaci\u00f3n del PR. Consultar About pull requests . Implementaremos cada issue en una rama separada de git y la integraremos en la rama main haciendo un pull request . Cuando se mezcle el PR en main el issue se cerrar\u00e1. M\u00e1s adelante a\u00f1adiremos otra rama de largo recorrido releases para incluir en ella las releases del proyecto. Milestones y Releases : Etiquetaremos cada issue con el milestone en el que queremos que se lance. Para identificar el milestone usaremos el versionado sem\u00e1ntico : MAJOR.MINOR.PATCH. Usaremos la funcionalidad de GitHub Releases para etiquetar los commits en los que queramos marcar una versi\u00f3n nueva del proyecto. Podemos a\u00f1adir informaci\u00f3n sobre las novedades de la versi\u00f3n (normalmente ser\u00e1n enlaces a los issues ese milestone). Tablero de proyecto : Un tablero de proyecto en GitHub nos ayudar\u00e1 a hacer un seguimiento de en qu\u00e9 estado se encuentra cada issue: cu\u00e1les han sido implementados, cu\u00e1les faltan por asignar, implementar, probar, etc. Vamos a utilizar la funcionalidad propia de GitHub llamada Projects . Consultar Quickstart for Projects Cuando se crea un pull request que resuelve un issue enlazaremos el issue con el pull request. Podremos ver en el tablero que bajo el issue aparece su PR enlazado y podremos desplegarlo en la propia tarjeta (funcionalidad nueva de GitHub). Tambi\u00e9n utilizaremos un panel de Trello para representar las historias de usuario que se van implementando en el proyecto. Cada historia de usuario tendr\u00e1 un c\u00f3digo num\u00e9rico y podr\u00e1 implementarse con uno o m\u00e1s issues. En GitHub crearemos una etiqueta por cada historia de usuario y se la asignaremos a los issues que se usen para implementarla. Importante Puede parecer redundante el uso de dos tableros, uno para las historias de usuario y otro para los issues y PR . La justificaci\u00f3n es que los objetivos de ambos tableros son distintos (y los contenidos tambi\u00e9n). El tablero Trello es un tablero de funcionalidades de usuario , que es gestionado por el product owner , usado por el equipo de desarrollo y puede ser compartido tambi\u00e9n con clientes y gerencia. En la terminolog\u00eda de Scrum ser\u00e1 el product backlog . Mientras que el tablero de GitHub ser\u00e1 un tablero t\u00e9cnico gestionado por el equipo de desarrollo. En terminolog\u00eda de Scrum ser\u00e1 el sprint backlog . La documentaci\u00f3n en Trello y en GitHub (en los issues, en los PRs y en el propio README.md del proyecto) hay que escribirla en Markdown , un lenguaje de marcado muy popular y sencillo de dominar. Si no has trabajado todav\u00eda con \u00e9l puedes leer estas gu\u00edas de GitHub . Nota Existen herramientas y servicios m\u00e1s avanzados para gestionar todos estos elementos del desarrollo. Por ejemplo Jira , YouTrack o Confluence . Pero la combinaci\u00f3n de GitHub + Trello es suficiente para lo que vamos a realizar en la asignatura y para aprender los objetivos y el funcionamiento de estos tipos de sistemas basados en incidencias.","title":"Flujo de trabajo"},{"location":"02-todolist/practica2.html#5-antes-de-empezar-la-practica","text":"Una vez logeado en GitHub, copia el enlace con una invitaci\u00f3n que compartiremos en el foro de Moodle. Con esa invitaci\u00f3n se crear\u00e1 autom\u00e1ticamente tu repositorio mads-todolist-<usuario> en la organizaci\u00f3n mads-ua . Al igual que el repositorio de la primera parte de la pr\u00e1ctica es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial de un proyecto base (es una copia del repositorio domingogallardo/mads-todolist-inicial ) en la que se han comprimido todos los commits en uno. Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n mads-ua-22-23 . Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas. Descarga el proyecto y comprueba que se compila y ejecuta correctamente: $ git clone https://github.com/mads-ua/mads-todolist-<usuario>.git $ cd mads-todolist-<usuario> $ ./mvnw spring-boot:run Comprueba que la aplicaci\u00f3n est\u00e1 funcionando en http://localhost:8080/login en la m\u00e1quina host. Para la aplicaci\u00f3n haciendo CTR+C en el terminal. Importa el proyecto en IntelliJ para trabajar, ejecutar los tests y lanzar la aplicaci\u00f3n desde este entorno. Es posible examinar el esquema de la base de datos y los datos accediendo a la base de datos H2 en memoria a\u00f1adiendo las siguientes preferencias: spring . h2 . console . enabled = true spring . h2 . console . path =/ h2 - console Una vez lanzada la aplicaci\u00f3n, podemos acceder a http://localhost:8080/h2-console introduciendo como JDBC URL la direcci\u00f3n de la fuente de datos jdbc:h2:mem:dev y como User name la cadena sa Y examinar tablas en concreto:","title":"5. Antes de empezar la pr\u00e1ctica"},{"location":"02-todolist/practica2.html#6-desarrollo-de-la-practica","text":"En esta primera pr\u00e1ctica vamos a desarrollar las siguientes historias de usuario o features: P\u00e1gina Acerca de Barra de men\u00fa P\u00e1gina listado de usuarios P\u00e1gina descripci\u00f3n de usuario Usuario administrador (opcional) Protecci\u00f3n del listado y descripci\u00f3n de usuarios (opcional) Bloqueo de usuarios por el usuario administrador (opcional) La pr\u00e1ctica va a consistir en la realizaci\u00f3n en tu proyecto de todos los elementos necesarios para implementar estas features : tablero Trello, issues, pull requests (con sus commits en los que se desarrolla paso a paso cada issue) y tablero del proyecto. Haremos paso a paso la historia de usuario 1, creando la primera versi\u00f3n 1.0.1 de la aplicaci\u00f3n. Las siguientes caracter\u00edsticas las deber\u00e1s desarrollar tu mismo y entregar la versi\u00f3n 1.1.0.","title":"6. Desarrollo de la pr\u00e1ctica"},{"location":"02-todolist/practica2.html#version-101","text":"La versi\u00f3n 1.0.1 ser\u00e1 la versi\u00f3n inicial de la aplicaci\u00f3n. Desarrollaremos en esta versi\u00f3n la primera caracter\u00edstica: P\u00e1gina Acerca de .","title":"Versi\u00f3n 1.0.1"},{"location":"02-todolist/practica2.html#resto-de-la-practica-version-110","text":"El resto de la pr\u00e1ctica consistir\u00e1 en desarrollar la versi\u00f3n 1.1.0, usando la misma metodolog\u00eda vista anteriormente. Deber\u00e1s desarrollar tres caracter\u00edsticas nuevas obligatorias y 3 opcionales: (Obligatoria) Barra de men\u00fa (Obligatoria) P\u00e1gina de listado de usuarios (Obligatoria) P\u00e1gina de descripci\u00f3n de un usuario (Opcional) Usuario administrador (Opcional) Protecci\u00f3n listado y descripci\u00f3n de usuario (Opcional) Administrador puede bloquear el acceso a usuarios Deber\u00e1s implementar cada caracter\u00edstica siguiendo la metodolog\u00eda que hemos usado anteriormente. En la implementaci\u00f3n, deber\u00e1s a\u00f1adir el c\u00f3digo necesario en cada una de las capas de la aplicaci\u00f3n: Capa de presentaci\u00f3n (vista) Nuevo m\u00e9todo en la capa de controller M\u00e9todos necesarios en la capa de servicio y de repository En cada caracter\u00edstica deber\u00e1s tambi\u00e9n incluir tests que prueben los nuevos m\u00e9todos a\u00f1adidos en la capa de servicio, as\u00ed como los nuevos controllers y vistas a\u00f1adidos.","title":"Resto de la pr\u00e1ctica (versi\u00f3n 1.1.0)"},{"location":"02-todolist/practica2.html#7-documentacion-entrega-y-evaluacion","text":"Deber\u00e1s a\u00f1adir una p\u00e1gina documentaci\u00f3n /doc/practica2.md en la que debes realizar una breve documentaci\u00f3n t\u00e9cnica de entre 500 y 800 palabras. Debes suponer que est\u00e1s trabajando con un equipo de desarrollo y que debes dejar una breve documentaci\u00f3n para que el resto del equipo sepa c\u00f3mo ha evolucionado la implementaci\u00f3n de la aplicaci\u00f3n. No debe ser una manual de usuario, no es una documentaci\u00f3n para el cliente . Por ejemplo, la documentaci\u00f3n podr\u00eda contener: Listado de nuevas clases y m\u00e9todos implementados. Listado de plantillas thyemeleaf a\u00f1adidas. Explicaci\u00f3n de los tests implementados. Explicaci\u00f3n de c\u00f3digo fuente relevante de las nuevas funcionalidades implementadas. Obligatoriamente debes incluir en la documentaci\u00f3n alg\u00fan ejemplo de c\u00f3digo fuente que has a\u00f1adido y que consideres interesante y su explicaci\u00f3n. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes disponible en GitHub una breve pero \u00fatil introducci\u00f3n a Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas y debe estar terminada el martes 18 de octubre. El profesor comprobar\u00e1 en clase de pr\u00e1cticas el funcionamiento de la pr\u00e1ctica en producci\u00f3n. La parte obligatoria punt\u00faa sobre 6 y la opcional sobre 4 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 4 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Correcto funcionamiento. Documentaci\u00f3n.","title":"7. Documentaci\u00f3n, entrega y evaluaci\u00f3n"},{"location":"03-pruebas-tdd/integration-tdd.html","text":"Pr\u00e1ctica 3: Integraci\u00f3n con GitHub Actions y TDD \u00b6 En esta pr\u00e1ctica 3 de la asignatura realizaremos dos tareas principales: Configuraremos un sistema de integraci\u00f3n continua usando las actions del repositorio de GitHub. En este sistema se lanzar\u00e1n los tests autom\u00e1ticamente en cada pull request . Despu\u00e9s definiremos una nueva configuraci\u00f3n del proyecto en la que se lanzar\u00e1n los tests sobre la base de datos PostgreSQL . A\u00f1adiremos nuevas funcionalidades usando la pr\u00e1ctica XP de TDD ( Test Driven Design ). Importante Lee con cuidado todo el enunciado y dedica especial atenci\u00f3n a los apartados con el t\u00edtulo Pasos a seguir . Ah\u00ed est\u00e1n especificadas las acciones que debes realizar en la pr\u00e1ctica. La duraci\u00f3n de la pr\u00e1ctica es de 3 semanas y la fecha l\u00edmite de entrega es el d\u00eda 8 de noviembre. 1. Desarrollo de la release 1.2.0 \u00b6 En esta pr\u00e1ctica vamos a desarrollar la versi\u00f3n 1.2.0 de la aplicaci\u00f3n ToDoList . A todos los issues y pull requests les debes poner este milestone , indicando que el objetivo es resolverlos y entregarlos en esta release . Pasos a seguir \u00b6 Cambia el n\u00famero de versi\u00f3n (en el fichero Acerca De y en el pom.xml ) a 1.2.0-SNAPSHOT para indicar que lo que hay en main es la versi\u00f3n 1.2.0 en progreso . Esta versi\u00f3n la lanzaremos al final del desarrollo de la pr\u00e1ctica, en su entrega. 2. Integraci\u00f3n continua con GitHub Actions \u00b6 GitHub Actions es un servicio de GitHub que permite realizar integraci\u00f3n continua en su propia web, sin necesidad de configurar un servidor propio de integraci\u00f3n continua. Puedes consultar el funcionamiento de GitHub Actions leyendo su documentaci\u00f3n, comenzando por las p\u00e1ginas Quickstart for GitHub Actions , Introduction to GitHub Actions y Building and testing Java with Maven . En la pr\u00e1ctica vamos a comenzar configurando GitHub Actions para que todos los pull requests deban pasar los tests de integraci\u00f3n antes de realizar el merge con main . Tests en los pull requests \u00b6 Usando GitHub Actions es posible configurar el repositorio de GitHub para que todos los pull requests deban pasar los tests de integraci\u00f3n en el servicio. En la siguiente imagen vemos el aspecto en GitHub de un pull request estando activa la integraci\u00f3n con Actions. Una vez abierto el PR, se lanzan los flujos de trabajo ( workflows ) definidos en el directorio .github/workflows . GitHub comprueba si la integraci\u00f3n de main con la rama pasa los tests definidos en el workflow. S\u00f3lo si los tests pasan es posible realizar el merge del PR en main. El fichero de configuraci\u00f3n \u00b6 Para configurar GitHub Actions basta con a\u00f1adir un fichero de flujo de trabajo en el directorio .github/workflows . El fichero con el flujo de trabajo inicial lo llamaremos developer-tests.yml : Fichero .github/workflows/developer-tests.yml name: Tests on: push jobs: # El nombre del job es launch-test launch-tests: runs-on: ubuntu-latest # Todos los pasos se ejecutan en el contenedor openjda:8-jdk-alpine container: openjdk:8-jdk-alpine steps: # Hacemos un checkout del c\u00f3digo del repositorio - uses: actions/checkout@v2 # Y lanzamos los tests - name: Launch tests with Maven run: ./mvnw test Puntos interesantes a destacar: El nombre del flujo de trabajo es Tests . El nombre del job es launch-tests . Con la palabra clave on se define el evento que causa que se lance el flujo de trabajo. Es en cualquier commit subido a GitHub (push). En jobs se definen los trabajos en paralelo a realizar por el flujo de trabajo. En nuestro caso s\u00f3lo habr\u00e1 uno. En runs-on se define la m\u00e1quina base sobre la que se van a ejecutar los siguientes pasos del flujo. En container se especifica el contenedor Docker que se va a usar para ejecutar los pasos del flujo de trabajo. En uses: actions/checkout@v2 se especifica que se obtenga la versi\u00f3n 2 de la acci\u00f3n llamada actions/checkout . Esta acci\u00f3n se descarga el repositorio en la m\u00e1quina especificada anteriormente y lo deja listo para ejecutar los tests o cualquier otra acci\u00f3n. Por \u00faltimo, con el comando run: ./mvnw test se indica que el flujo de trabajo debe lanzar este comando, que es el que lanza los tests. Los nombres Tests y launch-tests son nombres arbitrarios que indicamos y que despu\u00e9s aparecen en la interfaz de Actions y nos sirven para localizar los distintos pasos. Builds en Actions \u00b6 En la pesta\u00f1a Actions de GitHub tenemos toda la informaci\u00f3n de los builds . Es posible visualizarla mientras que se est\u00e1 realizando el build o cuando ya ha terminado. All\u00ed podremos ver el detalle de la ejecuci\u00f3n de los tests y consultar la salida de los mismos para comprobar su resultado. En la siguiente imagen se ha capturado el build en ejecuci\u00f3n. El color naranja significa que el proceso est\u00e1 en ejecuci\u00f3n. Pasos a seguir \u00b6 Crea un issue llamado Integraci\u00f3n continua con GitHub Actions . Abre una rama integracion-continua-actions , s\u00fabela a GitHub y abre un pull request. A\u00f1ade el fichero .github/workflows/developer-tests.yml . Haz un commit y s\u00fabelo a GitHub. Comprueba que se pasan los tests y que se marca como correcto el pull request . Modifica un test para que falle y sube un nuevo commit. Recarga la p\u00e1gina del pull request y comprueba que el commit aparece como err\u00f3neo en GitHub cuando el build falla. Pincha en el enlace details para comprobar la descripci\u00f3n del fallo. Corrige el test que falla, vuelve a subir el commit y comprueba que el nuevo commit y el PR pasan correctamente. Cierra el pull request , mezcl\u00e1ndolo con main . Se volver\u00e1n a lanzar los tests en GitHub y el commit aparecer\u00e1 marcado como correcto. Baja los cambios al repositorio local y borra la rama. $ (integracion-continua-actions) git checkout main $ (main) git pull $ (main) git branch -d integracion-continua-actions $ (main) git remote prune origin 3. Configuraci\u00f3n de la aplicaci\u00f3n para usar una BD PostgreSQL \u00b6 Hasta ahora hemos trabajado con la aplicaci\u00f3n en una configuraci\u00f3n local con nuestro ordenador de desarrollo trabajando sobre una base de datos H2 en memoria. Pero el objetivo final es poner la aplicaci\u00f3n en producci\u00f3n, en un servidor en Internet y usando una base de datos PostgreSQL en producci\u00f3n. Adem\u00e1s, te habr\u00e1s dado cuenta de que es muy engorroso probar la aplicaci\u00f3n con la base de datos de memoria. Tienes que volver a introducir todos los datos de prueba cada vez que paramos y ponemos en marcha la aplicaci\u00f3n. En esta pr\u00e1ctica vamos a ver c\u00f3mo configurar la aplicaci\u00f3n para poder trabajar con una base datos PostgreSQL, tanto en su ejecuci\u00f3n como en los tests. Para configurar la aplicaci\u00f3n vamos a utilizar los denominados perfiles . Definiremos, adem\u00e1s del perfil base, un perfil adicional para lanzar la aplicaci\u00f3n y los tests usando la base de datos PostgreSQL. La configuraci\u00f3n de tests con base de datos PostgreSQL la utilizaremos para ejecutar los tests de integraci\u00f3n sobre la base de datos PostgreSQL en el proceso de integraci\u00f3n continua de GitHub Actions. Para lanzar un servidor de base de datos PostgreSQL usaremos Docker, de forma que no tendremos que realizar ninguna instalaci\u00f3n en nuestro ordenador. Ficheros de configuraci\u00f3n de la aplicaci\u00f3n \u00b6 Ya hemos comentado que la configuraci\u00f3n de la aplicaci\u00f3n se define en el fichero application.properties . Ah\u00ed se definen distintas propiedades de la ejecuci\u00f3n de la aplicaci\u00f3n que se pueden modificar (puerto en el que se lanza la aplicaci\u00f3n, base de datos con la que conectarse, etc.). Tenemos dos ficheros application.properties : uno en el directorio src/main/resources que define la configuraci\u00f3n de ejecuci\u00f3n y otro en el directorio src/test/resources que define la configuraci\u00f3n que se carga cuando se lanzan los tests. Spring Boot permite definir ficheros de configuraci\u00f3n adicionales que pueden sobreescribir y a\u00f1adir propiedades a las definidas en el fichero de configuraci\u00f3n por defecto. El nombre de estos ficheros de configuraci\u00f3n debe ser application-xxx.properties donde xxx define el nombre del perfil. En nuestro caso definiremos los ficheros application-postgres.properties (uno en el directorio main y otro en test ) para definir las configuraciones de ejecuci\u00f3n y de test con PostgreSQL. Estos ficheros de configuraci\u00f3n adicionales se cargan despu\u00e9s de cargar la configuraci\u00f3n por defecto definida en application.properties . Pasos a seguir \u00b6 Crea un nuevo issue llamado A\u00f1adir perfiles y permitir trabajar con PostgreSQL . Crea una rama nueva (ll\u00e1mala perfiles , por ejemplo) y abre un pull request. $ (main) git checkout -b perfiles $ (perfiles) git push -u origin perfiles Copia el siguiente fichero en src/main/resources/application-postgres.properties : spring.datasource.url=jdbc:postgresql://localhost:5432/mads spring.datasource.username=mads spring.datasource.password=mads spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect spring.sql.init.mode=never Este va a ser el perfil que activemos para utilizar la conexi\u00f3n con la BD PostgreSQL. En este fichero de configuraci\u00f3n se define la URL de conexi\u00f3n a la base de datos mads , su usuario ( mads ) y contrase\u00f1a ( mads ) y el dialecto que se va a utilizar para trabajar desde JPA con la base de datos ( org.hibernate.dialect.PostgreSQL9Dialect ). La propiedad spring.sql.init.mode=never indica que no se debe cargar ning\u00fan fichero de datos inicial. Por esto, el fichero data.sql no se va a cargar en la base de datos, deber\u00e1s registrar un usuario inicial para poder probar la aplicaci\u00f3n. La ventaja es que al trabajar con la base de datos real todos los datos van a quedar grabados aunque se pare la aplicaci\u00f3n. Vamos ahora a a\u00f1adir el perfil de test. Copia el siguiente fichero en src/test/resources/application-postgres.properties : spring.datasource.url=jdbc:postgresql://localhost:5432/mads_test spring.datasource.username=mads spring.datasource.password=mads spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect En este perfil la conexi\u00f3n se hace con una base de datos diferente: mads_test , para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. Recuerda que en el perfil por defecto resources/application.properties se define el valor de spring.jpa.hibernate.ddl-auto como create . De esta forma la base de datos se inicializa antes de cargar los datos de los tests y de ejecutarlos. Tambi\u00e9n usamos una base de datos distinta ( mads_test ) para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. A\u00f1ade la siguiente dependencia en el fichero pom.xml para que se descargue el driver postgresql:42.2.22 . Tambi\u00e9n a\u00f1ade las l\u00edneas para poder especificar perfiles desde l\u00ednea de comando. La variable profiles se definir\u00e1 desde l\u00ednea de comando cuando se llame a Maven: Fichero pom.xml : <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.postgresql </groupId> <artifactId> postgresql </artifactId> <version> 42.2.22 </version> </dependency> <dependency> <groupId> org.springframework.boot </groupId> ... <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> <configuration> <profiles> ${profiles} </profiles> </configuration> </plugin> Para lanzar la aplicaci\u00f3n necesitar\u00e1s un servidor PostgreSQL en el puerto 5432 con el usuario mads , la contrase\u00f1a mads y la base de datos mads . Es muy sencillo descargarlo y ejecutarlo si tienes instalado Docker. Ejecuta desde el terminal: docker run -d -p 5432:5432 --name postgres-develop -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 Docker se descarga la imagen postgres:13 y lanza el contenedor (una instancia en marcha de una imagen) conectado al puerto 5432 (no debe estar ocupado) y sobre la base de datos mads . Le da como nombre postgres-develop . Puedes ejecutar los siguientes comandos de Docker: $ docker container ls -a (comprueba todos los contenedores en marcha) $ docker container stop <nombre o id de contenedor> (para un contenedor) $ docker container start <nombre o id de contenedor> (pone en marcha un contenedor) $ docker container logs <mombre o id de contenedor> (muestra logs del contenedor) $ docker container rm nombre o id de contenedor> (elimina un contenedor) Arranca la aplicaci\u00f3n con el siguiente comando: ./mvnw spring-boot:run -D profiles=postgres Se activar\u00e1 el perfil postgres y se cargar\u00e1n las preferencias de src/main/resource/application.properties y src/main/resource/application-postgres.properties . Prueba a introducir datos en la aplicaci\u00f3n y comprueba que se est\u00e1n guardando en la base de datos utilizando por ejemplo el panel Database de IntelliJ . Deber\u00e1s a\u00f1adir una Data Source de tipo PostgreSQL , configurando el usuario y contrase\u00f1a de acceso a mads : A\u00f1ade la conexi\u00f3n con la base de datos mads pulsando en el peque\u00f1o recuadro junto al nombre de la fuente de datos: Y despu\u00e9s ya podr\u00e1s examinar la base de datos mads , pulsando en la tabla que quieras y seleccionando con el bot\u00f3n derecho Edit Data : Cierra la aplicaci\u00f3n y vuelve a abrirla. Comprueba que los datos que se han creado en la ejecuci\u00f3n anterior siguen estando. Podemos tambi\u00e9n parar el contenedor y volverlo a reiniciar y los datos se conservar\u00e1n. Al parar el contenedor no se eliminan los datos, s\u00f3lo al borrarlo. Tambi\u00e9n podemos arrancar la aplicaci\u00f3n con el perfil de postgres lanzando directamente el fichero JAR de la siguiente forma: $ ./mvnw package $ java -Dspring.profiles.active=postgres -jar target/*.jar Para lanzar la aplicaci\u00f3n desde IntelliJ trabajando con el nuevo perfil podemos seleccionar la opci\u00f3n Edit Configurations... del men\u00fa de configuraciones, duplicar la configuraci\u00f3n Application , renombr\u00e1ndola por Application PostgreSQL y a\u00f1adir en el campo Active profiles el nombre del perfil nuevo que acabamos de crear postgres . Es posible que debas recargar el proyecto Maven para actualizar las dependencias. Cierra la aplicaci\u00f3n. Paramos el contenedor con la base de datos de desarrollo haciendo docker container stop postgres-develop : $ docker container ls -a CONTAINER ID IMAGE ... NAME 520fee61d51e posgres:13 ... postgres-develop $ docker container stop postgres-develop Adem\u00e1s de por l\u00ednea de comando, tambi\u00e9n es posible gestionar los contenedores usando la aplicaci\u00f3n Docker Desktop que se encuentra en la propia instalaci\u00f3n de Docker. Vamos ahora a ver c\u00f3mo lanzar los tests sobre una base de datos PostgreSQL. Lanzamos ahora otro contenedor con la base de datos de test ( mads_test ): docker run -d -p 5432:5432 --name postgres-test -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads_test postgres:13 Y lanzamos los tests usando el perfil postgres con la base de datos PostgreSQL con el siguiente comando: ./mvnw -D spring.profiles.active=postgres test Podemos lanzar tambi\u00e9n los tests desde IntelliJ editando la configuraci\u00f3n de lanzamiento de test y a\u00f1adiendo la variable de entorno spring.profiles.active=postgres . Podr\u00edamos, por ejemplo, llamar a esta configuraci\u00f3n Tests con PostgreSQL . Dado que las configuraciones de test y de ejecuci\u00f3n utilizan distintas bases de datos, debemos tener en funcionamiento la base de datos correspondiente a lo que queremos hacer en cada momento. Esto es muy f\u00e1cil usando los contenedores de Docker. Por ejemplo, podemos parar el contenedor PostgreSQL con la base de datos de test y arrancar el contenedor con la base de datos de desarrollo: $ docker container ls -a $ docker container stop postgres-test $ docker container start postgres-develop Realiza un commit con los cambios, s\u00fabelos a la rama y cierra el pull request para integrarlo en main : $ (perfiles) git add . $ (perfiles) git commit -m \"A\u00f1adidos perfiles para trabajar con PostgreSQL\" $ (perfiles) git push // Mezclamos el Pull Request en GitHub $ (perfiles) git checkout main $ (main) git pull $ (main) git branch -d perfiles $ (main) git remote prune origin 4. Tests de integraci\u00f3n en GitHub Actions \u00b6 Vamos a modificar la configuraci\u00f3n de GitHub Actions para conseguir un sistema de integraci\u00f3n continua que ejecute los tests de integraci\u00f3n usando la base de datos real PostgreSQL. La ejecuci\u00f3n de los tests usando la base de datos de memoria H2 ser\u00e1 responsabilidad del desarrollador y se har\u00e1 en el entorno de trabajo local, tal y como se ha hecho desde la primera pr\u00e1ctica. Tests del desarrollador vs. tests de integraci\u00f3n \u00b6 Podemos considerar los tests que usan la base de datos real como tests de integraci\u00f3n y los tests que usan la base de datos en memoria como tests del desarrollador . No usamos el nombre de tests unitarios de forma consciente, para evitar conflictos con la nomenclatura. Cuando hablamos de tests del desarrollador nos referimos a tests que van a ejecutar continuamente los desarrolladores en su equipo local cuando est\u00e1n trabajando con la aplicaci\u00f3n y a\u00f1adiendo funcionalidades. Son tests r\u00e1pidos, que se pueden lanzar desde el propio IDE, y que deben ser ejecutados antes de cada commit. Frente a estos tests, los tests de integraci\u00f3n necesitan una configuraci\u00f3n adicional (poner en marcha la base de datos de test en nuestro caso) y se ejecutan menos frecuentemente. Vamos a actualizar GitHub Actions para que se lancen all\u00ed los tests que usan la base de datos PostgreSQL y nos ahorremos el trabajo de realizarlos en local. Seguiremos lanzando en local los tests que usan la BD de memoria mientras hacemos el desarrollo. Dejaremos tambi\u00e9n en GitHub Actions los tests que usan la BD de memoria. Quiz\u00e1s sean redundantes con los que usan la BD de Postgres, pero su ejecuci\u00f3n no cuesta demasiado y no est\u00e1 de m\u00e1s lanzarlos tambi\u00e9n. Podr\u00edamos prescindir de ellos si en alg\u00fan momento comprobamos que el tiempo de ejecuci\u00f3n de los tests en GitHub se hace muy largo. Acci\u00f3n para lanzar los tests con la BD postgres \u00b6 Para lanzar los tests de integraci\u00f3n en GitHub debemos modificar el fichero de configuraci\u00f3n del flujo de trabajo para que lance un contenedor de PostgreSQL y despu\u00e9s se ejecuten los tests sobre ese contenedor. Para tener m\u00e1s flexibilidad en la configuraci\u00f3n de la conexi\u00f3n con PostgreSQL vamos a modificar el perfil de Spring Boot, a\u00f1adiendo unas variables con unos valores por defecto que se pueden modificar definiendo su valor en variables de entorno con el mismo nombre. En concreto, definimos las variables POSTGRES_HOST , POSTGRES_PORT , DB_USER y DB_PASSWD . Fichero src/test/resources/application-postgres.properties : POSTGRES_HOST=localhost POSTGRES_PORT=5432 DB_USER=mads DB_PASSWD=mads spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads_test spring.datasource.username=${DB_USER} spring.datasource.password=${DB_PASSWD} spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect Ya podemos a\u00f1adir un nuevo fichero de flujo de trabajo. Lo llamamos integration-tests.yml Fichero .github/workflows/integration-tests.yml : name: Integration tests on: push jobs: container-job: runs-on: ubuntu-latest container: openjdk:8-jdk-alpine services: # Etiqueta usada para acceder al contenedor del servicio postgres: # Imagen Docker Hub image: postgres:13 # Variables para arrancar PostgreSQL env: POSTGRES_USER: mads POSTGRES_PASSWORD: mads POSTGRES_DB: mads_test # Definimos chequeos para esperar hasta que postgres ya ha comenzado options: >- --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5 steps: - uses: actions/checkout@v2 - name: Launch tests with Maven run: ./mvnw test -D spring.profiles.active=postgres env: POSTGRES_HOST: postgres Se especifica el servicio postgres que se va a usar en el flujo de trabajo. Para configurar este servicio se define la imagen docker ( postgres:13 ) y las variables de entorno que se van a proporcionar al arrancar, para configurar la base de datos (usuario, contrase\u00f1a y base de datos). Estamos definiendo un contenedor docker similar al que hemos usado con los tests cuando hicimos la prueba en local. El nuevo comando de test activa el perfil postgres . Es el mismo comando que usamos cuando hicimos la prueba en local. En la \u00faltima l\u00ednea se actualiza el par\u00e1metro POSTGRES_HOST para que la conexi\u00f3n se realice con el host postgres que es el que nombre que se ha definido en el servicio. Pasos a seguir \u00b6 Crea un nuevo issue llamado Tests de integraci\u00f3n en GitHub Actions . Crea la rama integracion-gh-actions . $ git checkout -b integracion-gh-actions $ git push -u origin integracion-gh-actions Modifica el fichero del perfil postgres de test tal y como se indica anteriormente, para usar variables de configuraci\u00f3n que puedan ser definidas mediante variables de entorno. Comprueba que siguen funcionando los tests lanzados sobre la base de datos usando los valores por defecto de las variables de entorno. // Nos aseguramos de que la base de datos que est\u00e1 en marcha // es la de test $ docker container ls CONTAINER ID IMAGE PORTS NAMES 411d8f2ea46c postgres:13 0.0.0.0:5432->5432/tcp postgres-test ./mvnw -D spring.profiles.active=postgres test Comprueba que podemos modificar los par\u00e1metros definidos en las variables de entorno. Por ejemplo, si se cambia el nombre del host de la conexi\u00f3n con la base de datos los tests deben de fallar: $ ./mvnw -D spring.profiles.active=postgres -D POSTGRES_HOST=postgres test // Aparecer\u00e1n errores debidos a que no se puede conectar con el // host postgres: org.postgresql.util.PSQLException: El intento de conexi\u00f3n fall\u00f3. ... Caused by: java.net.UnknownHostException: postgres Crea un commit, s\u00fabelo a GitHub y crea el Pull Request $ git add . $ git commit -m \"A\u00f1adidas variables al perfil de test postgres\" $ git push A\u00f1ade el fichero del flujo de trabajo de la acci\u00f3n de GitHub, tal y como se indica anteriormente. Haz un commit, s\u00fabelo a GitHub y comprueba que los tests pasan correctamente y se lanzan all\u00ed usando la base de datos postgres. Una vez comprobado que funcionan los tests de integraci\u00f3n en GitHub, mezclamos el pull request y lo descargamos a local. Comprobamos que tambi\u00e9n se lanzan los tests en el commit de merge en GitHub. Con esto ya tenemos completado un sistema de integraci\u00f3n continua y GitHub se encargar\u00e1 de ejecutar todos los tests en un modo de integraci\u00f3n, usando la base de datos PostgreSQL. 5. TDD \u00b6 En la segunda parte de la pr\u00e1ctica desarrollaremos, usando TDD ( Test Driven Design ), una nueva feature de la aplicaci\u00f3n: la posibilidad de definir definir equipos a los que puedan pertenecer los usuarios. Descomponemos la feature en las siguientes historias de usuario. 008 Listado de equipos 009 Gestionar pertenencia al equipo 010 Gesti\u00f3n de equipos (opcional) 008 Listado de equipos : Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador podr\u00e9 cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Vamos a hacer de forma guiada la primera historia y dejamos las siguientes para que las hagas por tu cuenta. 008 Listado de equipos \u00b6 La descripci\u00f3n de la historia de usuario es la siguiente: Listado de equipos Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. Detalles * En el men\u00fa aparcer\u00e1 una opci\u00f3n `Equipos` que llevar\u00e1 a un listado con los nombres de todos los equipos existentes. * El listado de equipos estar\u00e1 ordenado por orden alfab\u00e9tico. * Pinchando en el enlace del nombre del equipo nos iremos a una p\u00e1gina con un listado de todos los usuarios que lo componen. * Un usuario podr\u00e1 pertenecer a m\u00e1s de un equipo. Vamos a utilizar la t\u00e9cnica de TDD para construir la funcionalidad de dentro a fuera (desde el repository hasta el controller). Comenzaremos con tests que construyan la capa de modelo (clases de entidad y repository) y despu\u00e9s pasaremos a tests que construyan la capa de servicio. Por \u00faltimo, una vez implementados los m\u00e9todos de servicios necesarios, deber\u00e1s implementar (lo haremos sin tests) las vistas y controllers. Las vistas y controllers los probaremos de forma manual, sin tests autom\u00e1ticos. Importante Los controllers no deben implementar ning\u00fan c\u00f3digo adicional, s\u00f3lo llamar al m\u00e9todo de servicio necesario. De esta forma nos aseguramos que todo el c\u00f3digo importante para la funcionalidad est\u00e1 testeado y ha sido creado mediante TDD. Probaremos los tests usando la base de datos de memoria y dejaremos que sea la acci\u00f3n de GitHub la que pruebe los tests con la base de datos Postgres. Recuerda que los pasos seguir la t\u00e9cnica de TDD: Test : Primero debes escribir el test. Code : Despu\u00e9s debes escribir el c\u00f3digo que hace pasar el test ( \u00fanicamente el c\u00f3digo necesario, no puedes escribir c\u00f3digo de m\u00e1s ) Refactor : Y, si es necesario, realizar una refactorizaci\u00f3n del c\u00f3digo (los tests deben seguir pasando despu\u00e9s de la refactorizaci\u00f3n). Deber\u00e1s hacer un commit por cada fase Test-Code . Si haces refactorizaci\u00f3n deber\u00e1s hacerlo en otro commit adicional. Pasos a seguir \u00b6 Crea la historia de usuario 008 Listado de equipos en el tablero Trello. Crea dos issues correspondientes a esta historia: Servicio y modelo listado de equipos. Vista y controller listado de equipos. Crea una rama para desarrollar el primer issue (ll\u00e1mala servicio-equipos , por ejemplo) y p\u00e1salo en el tablero a In progress . $ git checkout -b servicio-equipos $ git push -u origin servicio-equipos Este primer issue lo haremos de forma guiada usando TDD con los tests que enumeraremos a continuaci\u00f3n. El otro issue lo deber\u00e1s implementar por ti mismo. Primer commit - Clase Equipo \u00b6 El primer test es para crear la entidad Equipo . Por ahora s\u00f3lo creamos la clase Java, sin las anotaciones JPA. Un equipo Fichero src/test/java/madstodolist/EquipoTest.java : package madstodolist ; import org.junit.jupiter.api.Test ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.jdbc.Sql ; import static org.assertj.core.api.Assertions.assertThat ; import static org.springframework.test.context.jdbc.Sql.ExecutionPhase.AFTER_TEST_METHOD ; @SpringBootTest @Sql ( scripts = \"/clean-db.sql\" , executionPhase = AFTER_TEST_METHOD ) public class EquipoTest { @Test public void crearEquipo () { Equipo equipo = new Equipo ( \"Proyecto P1\" ); assertThat ( equipo . getNombre ()). isEqualTo ( \"Proyecto P1\" ); } } Escribe el c\u00f3digo necesario para que pase el test. No debes escribir c\u00f3digo de m\u00e1s, s\u00f3lo el c\u00f3digo m\u00ednimo para que el test pase . Haz un commit que contenga el test y el c\u00f3digo y s\u00fabelo a la rama remota. Pon como descripci\u00f3n del commit el mismo t\u00edtulo de esta secci\u00f3n: Primer commit - Clase Equipo . $ git add . $ git commit -m \"Primer commit - Clase Equipo\" Crea el pull request para comprobar que el test pasa correctamente cuando se ejecuta sobre la base de datos Postgres. Liga el pull request con el issue, para que cuando se mezcle el PR se cierre el issue. Importante Debes incluir en el commit tanto el c\u00f3digo del test como el c\u00f3digo que soluciona el test, de forma que el commit aparezca como correcto en GitHub. Segundo test - A\u00f1adir y buscar equipo en la base de datos \u00b6 Con el segundo test queremos conseguir que funcione JPA con la entidad Equipo y que podamos usar una tabla de equipos en la base de datos, en la que podamos guardar entidades equipo . Para comprobar que la entidad se ha guardado correctamente, comprobaremos se ha actualizando su identificador y que podemos recuperarlo de la base de datos. Lo hacemos a\u00f1adiendo el test grabarYBuscarEquipo . Usaremos la anotaci\u00f3n @Transactional siempre que trabajemos con clases repository . De esa forma nos aseguramos que todo el c\u00f3digo del test se ejecuta en la misma transacci\u00f3n. Cuando escribamos el c\u00f3digo del servicio tambi\u00e9n habr\u00e1 que usar esta anotaci\u00f3n en cada m\u00e9todo, tal y como se hace en las clases de servicio de Tarea y Usuario . @Autowired private EquipoRepository equipoRepository ; @Test @Transactional public void grabarYBuscarEquipo () { // GIVEN // Un equipo nuevo Equipo equipo = new Equipo ( \"Proyecto P1\" ); // WHEN // Salvamos el equipo en la base de datos equipoRepository . save ( equipo ); // THEN // Su identificador se ha actualizado y lo podemos // usar para recuperarlo de la base de datos Long equipoId = equipo . getId (); assertThat ( equipoId ). isNotNull (); Equipo equipoDB = equipoRepository . findById ( equipoId ). orElse ( null ); assertThat ( equipoDB ). isNotNull (); assertThat ( equipoDB . getNombre ()). isEqualTo ( \"Proyecto P1\" ); } Actualizamos tambi\u00e9n el fichero clean-db.sql para que se borre la tabla equipos al final de cada test. Fichero src/test/resources/clean-db.sql : DELETE FROM tareas ; DELETE FROM equipos ; DELETE FROM usuarios ; Escribe el c\u00f3digo necesario para pase el test y haz un commit con el nombre del apartado como descripci\u00f3n. S\u00fabelo a GitHub y comprueba en el pull request que el test pasa correctamente en el entorno de integraci\u00f3n. Tercer test - Definici\u00f3n de igualdad entre equipos \u00b6 Ahora que hemos introducido el id del equipo escribimos un test para comprobar que dos equipos son iguales. Debes escribir el c\u00f3digo de los m\u00e9todos equals y hashCode (necesario este \u00faltimo para que funcione correctamente la comprobaci\u00f3n de igualdades en las colecciones). Hacemos los tests para que el equals funcione de la siguiente forma: Si alguno de los dos equipos no tiene id (es null ), entonces se deben comparar sus nombres. Ahora bien, si los dos equipos tienen id , entonces se deben comparar esos id \". Puedes guiarte por la implementaci\u00f3n de equals y hashCode en Usuario . @Test public void comprobarIgualdadEquipos () { // GIVEN // Creamos tres equipos sin id, s\u00f3lo con el nombre Equipo equipo1 = new Equipo ( \"Proyecto P1\" ); Equipo equipo2 = new Equipo ( \"Proyecto P2\" ); Equipo equipo3 = new Equipo ( \"Proyecto P2\" ); // THEN // Comprobamos igualdad basada en el atributo nombre y que el // hashCode es el mismo para dos equipos con igual nombre assertThat ( equipo1 ). isNotEqualTo ( equipo2 ); assertThat ( equipo2 ). isEqualTo ( equipo3 ); assertThat ( equipo2 . hashCode ()). isEqualTo ( equipo3 . hashCode ()); // WHEN // A\u00f1adimos identificadores y comprobamos igualdad por identificadores equipo1 . setId ( 1L ); equipo2 . setId ( 1L ); equipo3 . setId ( 2L ); // THEN // Comprobamos igualdad basada en el atributo nombre assertThat ( equipo1 ). isEqualTo ( equipo2 ); assertThat ( equipo2 ). isNotEqualTo ( equipo3 ); } Escribe el c\u00f3digo necesario para que pase el test y haz un commit. Cuarto test - Relaci\u00f3n muchos-a-muchos entre equipos y usuarios \u00b6 Vamos ahora a dise\u00f1ar un test que introduzca la relaci\u00f3n entre equipos y usuarios. Debe ser una relaci\u00f3n muchos-a-muchos: un equipo contiene muchos usuarios y un usuario puede pertenecer a 0, 1 o muchos equipos. En el test hacemos varias cosas: creamos un equipo y un usuario, a\u00f1adimos el usuario al equipo y comprobamos que las relaciones se han actualizado en la base de datos. De la misma forma que en un test anterior, a\u00f1adimos la anotaci\u00f3n @Transactional para que todas las llamadas a objetos repository se hagan en la misma transacci\u00f3n y con la misma conexi\u00f3n a la base de datos. @Autowired private UsuarioRepository usuarioRepository ; @Test @Transactional public void comprobarRelacionBaseDatos () { // GIVEN // Un equipo y un usuario en la BD Equipo equipo = new Equipo ( \"Proyecto 1\" ); equipoRepository . save ( equipo ); Usuario usuario = new Usuario ( \"user@ua\" ); usuarioRepository . save ( usuario ); // WHEN // A\u00f1adimos el usuario al equipo equipo . addUsuario ( usuario ); // THEN // La relaci\u00f3n entre usuario y equipo pqueda actualizada en BD Equipo equipoBD = equipoRepository . findById ( equipo . getId ()). orElse ( null ); Usuario usuarioBD = usuarioRepository . findById ( usuario . getId ()). orElse ( null ); assertThat ( equipo . getUsuarios ()). hasSize ( 1 ); assertThat ( equipo . getUsuarios ()). contains ( usuario ); assertThat ( usuario . getEquipos ()). hasSize ( 1 ); assertThat ( usuario . getEquipos ()). contains ( equipo ); } Para que este test funcione hay que crear la relaci\u00f3n muchos-a-muchos entre equipos y usuarios. Es necesario definir la anotaci\u00f3n @ManyToMany para indicar a JPA c\u00f3mo construir las tablas en la base de datos. Vamos a crear esta relaci\u00f3n como LAZY , porque si fuera EAGER la recuperaci\u00f3n de equipos de la base de datos ser\u00eda muy costosa, traer\u00eda a memoria todos sus usuarios (con sus tareas incluidas). En Equipo.java definimos la tabla equipo_usuario en la que se va a guardar la relaci\u00f3n, e indicamos el papel de cada una de sus dos columnas. Tambi\u00e9n creamos el getter para obtener los usuarios. Fichero src/main/java/madstodolist/model/Equipo.java : + private String nombre; + // Declaramos el tipo de recuperaci\u00f3n como LAZY. + // No har\u00eda falta porque es el tipo por defecto en una + // relaci\u00f3n a muchos. + // Al recuperar un equipo NO SE RECUPERA AUTOM\u00c1TICAMENTE + // la lista de usuarios. S\u00f3lo se recupera cuando se accede al + // atributo 'usuarios'; entonces se genera una query en la + // BD que devuelve todos los usuarios del equipo y rellena el + // atributo. + + @ManyToMany(fetch = FetchType.LAZY) + @JoinTable(name = \"equipo_usuario\", + joinColumns = { @JoinColumn(name = \"fk_equipo\") }, + inverseJoinColumns = {@JoinColumn(name = \"fk_usuario\")}) + Set<Usuario> usuarios = new HashSet<>(); ... public void setId(Long id) { this.id = id; } + public Set<Usuario> getUsuarios() { + return usuarios; + } En el fichero Usuario.java definimos la parte inversa de la relaci\u00f3n. El mappedBy indica que la especificaci\u00f3n de la tabla join est\u00e1 en el otro lado de la relaci\u00f3n. Esta relaci\u00f3n la definimos como EAGER porque el otro lado de la relaci\u00f3n es LAZY . Al recuperar un usuario solo se van a traer a memoria la informaci\u00f3n de sus equipos. Fichero src/main/java/madstodolist/model/Usuario.java : @OneToMany(mappedBy = \"usuario\", fetch = FetchType.EAGER) Set<Tarea> tareas = new HashSet<>(); + @ManyToMany(mappedBy = \"usuarios\") + Set<Equipo> equipos = new HashSet<>(); ... + public Set<Equipo> getEquipos() { + return equipos; + } Y por \u00faltimo a\u00f1adimos en Equipo.java el m\u00e9todo que actualiza ambos lados de la relaci\u00f3n. A\u00f1ade el usuario a la colecci\u00f3n de usuarios del equipo y a\u00f1ade el equipo a la colecci\u00f3n de equipos del usuario. public void addUsuario ( Usuario usuario ) { this . getUsuarios (). add ( usuario ); usuario . getEquipos (). add ( this ); } Tambi\u00e9n actualizamos el fichero de limpieza de datos al final de cada test, para a\u00f1adir la nueva tabla equipo_usuario . Fichero src/test/resources/clean-db.sql : DELETE FROM equipo_usuario ; DELETE FROM tareas ; DELETE FROM equipos ; DELETE FROM usuarios ; Comprueba el test, haz un commit en la rama y s\u00fabelo a GitHub. Quinto test - Listado de equipos \u00b6 Vamos ahora a definir un test para obtener una lista de equipos en el repository . Queremos que el tipo devuelto por el repository sea List . @Test @Transactional public void comprobarFindAll () { // GIVEN // Dos equipos en la base de datos equipoRepository . save ( new Equipo ( \"Proyecto 2\" )); equipoRepository . save ( new Equipo ( \"Proyecto 3\" )); // WHEN List < Equipo > equipos = equipoRepository . findAll (); // THEN assertThat ( equipos ). hasSize ( 2 ); } La soluci\u00f3n consiste en a\u00f1adir el m\u00e9todo findAll en la interfaz p EquipoRepository , definiendo el tipo devuelto como List . Spring Boot se encarga de construir autom\u00e1ticamente la implementaci\u00f3n de este m\u00e9todo. Fichero EquipoRepository.java : + import java.util.List; public interface EquipoRepository extends CrudRepository<Equipo, Long> { + public List<Equipo> findAll(); } Sexto test - M\u00e9todo de servicio para crear y recuperar equipo \u00b6 \u00a1Y por fin llegamos a la capa de servicio! Creamos el fichero EquipoServiceTest.java con la llamada al m\u00e9todo de servicio para crear un equipo nuevo y a otro m\u00e9todo de servicio para recuperar un equipo por su identificador. Lo hacemos todo en el m\u00e9todo crearRecuperarTest . En el test no hay que a\u00f1adir la anotaci\u00f3n @Transactional porque queremos probar el uso de los m\u00e9todos de servicio en un contexto similar al que usaremos cuando los llamemos desde el controller. Cuando llamemos desde el controller a los m\u00e9todos de servicio no se usar\u00e1 la anotaci\u00f3n @Transactional para evitar en el c\u00f3digo del controller se pueda acceder a los objetos repository y modificar directamente la base de datos. Fichero src/test/java/madstodolist/EquipoServiceTest.java : package madstodolist ; import madstodolist.model.Equipo ; import madstodolist.service.EquipoService ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.test.context.jdbc.Sql ; import static org.assertj.core.api.Assertions.assertThat ; import static org.springframework.test.context.jdbc.Sql.ExecutionPhase.AFTER_TEST_METHOD ; @SpringBootTest @Sql ( scripts = \"/clean-db.sql\" , executionPhase = AFTER_TEST_METHOD ) public class EquipoServiceTest { @Autowired EquipoService equipoService ; @Test public void crearRecuperarEquipo () { Equipo equipo = equipoService . crearEquipo ( \"Proyecto 1\" ); Equipo equipoBd = equipoService . recuperarEquipo ( equipo . getId ()); assertThat ( equipoBd ). isNotNull (); assertThat ( equipoBd . getNombre ()). isEqualTo ( \"Proyecto 1\" ); } } Para que funcione correctamente el test tenemos que crear la clase EquipoService con los m\u00e9todos crearEquipo y recuperarEquipo . Completa el c\u00f3digo en los lugares indicados. Fichero src/test/java/madstodolist/EquipoServiceTest.java : package madstodolist.service ; import madstodolist.model.Equipo ; import madstodolist.model.EquipoRepository ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import org.springframework.transaction.annotation.Transactional ; @Service public class EquipoService { Logger logger = LoggerFactory . getLogger ( EquipoService . class ); @Autowired EquipoRepository equipoRepository ; @Transactional public Equipo crearEquipo ( String nombre ) { // Completar } @Transactional ( readOnly = true ) public Equipo recuperarEquipo ( Long id ) { // Completar } } Tal y como hemos comentado, la anotaci\u00f3n @Transactional se usa en los m\u00e9todos de servicio en los que se trabaja con objetos repository para asegurarnos de que todo el c\u00f3digo del m\u00e9todo se ejecuta en la misma transacci\u00f3n y usando la misma conexi\u00f3n a la base de datos. En aquellos m\u00e9todos en los que no se modifica la base de datos (s\u00f3lo se realiza una consulta) es recomendable utilizar la anotaci\u00f3n con el atributo readOnly = true para hacer m\u00e1s eficiente la conexi\u00f3n con la base de datos. S\u00e9ptimo test - M\u00e9todo de servicio para el listado de equipos \u00b6 A\u00f1adimos el test que obliga a crear el m\u00e9todo de servicio que recupera la lista de equipos existentes, ordenada por orden alfab\u00e9tico del nombre del equipo: Fichero src/test/java/madstodolist/EquipoServiceTest.java : @Test public void listadoEquiposOrdenAlfabetico () { // GIVEN // Dos equipos en la base de datos equipoService . crearEquipo ( \"Proyecto BBB\" ); equipoService . crearEquipo ( \"Proyecto AAA\" ); // WHEN // Recuperamos los equipos List < Equipo > equipos = equipoService . findAllOrderedByName (); // THEN // Los equipos est\u00e1n ordenados por nombre assertThat ( equipos ). hasSize ( 2 ); assertThat ( equipos . get ( 0 ). getNombre ()). isEqualTo ( \"Proyecto AAA\" ); assertThat ( equipos . get ( 1 ). getNombre ()). isEqualTo ( \"Proyecto BBB\" ); } } Escribe en el servicio el c\u00f3digo estr\u00edctamente necesario para que pase el test. Haz un commit en la rama y s\u00fabelo a GitHub. Octavo test - Comprobaci\u00f3n de relaci\u00f3n lazy entre equipo y usuarios \u00b6 Vamos a centrar este test en la forma de traer a memoria los objetos que participan en la relaci\u00f3n USUARIO-EQUIPO . En JPA hay dos formas de definir una relaci\u00f3n a-muchos: EAGER : Si una relaci\u00f3n a-muchos es EAGER , cuando la clase repository devuelve un objeto (ya sea al recuperarlo individualmente, o en una consulta en la que se recupera una colecci\u00f3n), se obtienen tambi\u00e9n de la base de datos todos los objetos con los que est\u00e1 relacionado. Por ejemplo, en la pr\u00e1ctica tenemos definida de esta forma la relaci\u00f3n entre usuarios y tareas. LAZY : Si una relaci\u00f3n a-muchos es LAZY , cuando la clase repository devuelve un objeto, no recupera de la base de datos los objetos relacionados. S\u00f3lo lo hace cuando se accede a la colecci\u00f3n que contiene la relaci\u00f3n. Entonces es cuando se realiza la consulta a la base de datos y se traen estos objetos a memoria. Si estos objetos tienen otras relaciones se traer\u00e1n a memoria o no dependiendo de si son EAGER o LAZY . Para que funcione la recuperaci\u00f3n perezosa debe estar abierta la conexi\u00f3n con la base de datos en el momento en que se accede a la colecci\u00f3n. Para ello es muy importante la etiqueta @Transactional . Cuando ponemos esta etiqueta en los m\u00e9todos de las clases de servicio se garantiza que todo el m\u00e9todo se realiza en una \u00fanica transacci\u00f3n. Por ello, al finalizar el m\u00e9todo se cerrar\u00e1 la conexi\u00f3n con la base de datos y el objeto que se devolver\u00e1 al controller estar\u00e1 desconectado de la base de datos , por lo que la recuperaci\u00f3n perezosa no funcionar\u00e1 en el controller . En el caso de la relaci\u00f3n USUARIO-EQUIPO hemos definido el siguiente dise\u00f1o: La relaci\u00f3n entre un usuario y sus equipos ser\u00e1 EAGER . Cuando recuperamos un usuario, recuperaremos tambi\u00e9n la informaci\u00f3n de todos los equipos en los que participa. Esta parte de la relaci\u00f3n est\u00e1 pendiente de implementar. Lo haremos m\u00e1s adelante. La relaci\u00f3n entre un equipo y sus usuarios es LAZY . Esto es muy importante. Si no lo hici\u00e9ramos as\u00ed \u00a1podr\u00edamos f\u00e1cilmente traernos a memoria toda la base de datos!. Un equipo recuperar\u00eda todos sus usuarios, que tambi\u00e9n pueden estar en otros equipos, que a su vez tambi\u00e9n se traer\u00edan a memoria. Vamos a comprobar que la relaci\u00f3n entre equipos y usuarios es LAZY . Para ello debemos comprobar que se lanza una excepci\u00f3n cuando se intenta acceder a la colecci\u00f3n de usuarios de un equipo recuperado: Fichero src/test/java/madstodolist/EquipoServiceTest.java : @Test public void accesoUsuariosGeneraExcepcion () { // Given // Un equipo en la base de datos Equipo equipo = equipoService . crearEquipo ( \"Proyecto 1\" ); // WHEN // Se recupera el equipo Equipo equipoBd = equipoService . recuperarEquipo ( equipo . getId ()); // THEN // Se produce una excepci\u00f3n al intentar acceder a sus usuarios assertThatThrownBy (() -> { equipoBd . getUsuarios (). size (); }). isInstanceOf ( LazyInitializationException . class ); } Comprueba si hay que modificar el c\u00f3digo, haz un commit y s\u00fabelo a GitHub. Noveno test - M\u00e9todo de servicio para a\u00f1adir un usuario a un equipo \u00b6 Vamos a crear un test que nos obligue a implementar el m\u00e9todo de servicio para a\u00f1adir un usuario a un equipo. Para comprobar su funcionamiento deberemos implementar tambi\u00e9n el m\u00e9todo de servicio para recuperar los usuarios de un equipo. El test es el siguiente. Fichero src/test/java/madstodolist/EquipoServiceTest.java : @Test public void actualizarRecuperarUsuarioEquipo () { // GIVEN // Un equipo creado en la base de datos y un usuario registrado Equipo equipo = equipoService . crearEquipo ( \"Proyecto 1\" ); Usuario usuario = new Usuario ( \"user@ua\" ); usuario . setPassword ( \"123\" ); usuario = usuarioService . registrar ( usuario ); // WHEN // A\u00f1adimos el usuario al equipo y lo recuperamos equipoService . addUsuarioEquipo ( usuario . getId (), equipo . getId ()); List < Usuario > usuarios = equipoService . usuariosEquipo ( equipo . getId ()); // THEN // El usuario se ha recuperado correctamente assertThat ( usuarios ). hasSize ( 1 ); assertThat ( usuarios . get ( 0 ). getEmail ()). isEqualTo ( \"user@ua\" ); } Implementa los m\u00e9todos de servicio necesarios para que el test pase correctamente. Haz un commit y s\u00fabelo a GitHub. D\u00e9cimo test - Recuperaci\u00f3n eager de equipos \u00b6 Y, por \u00faltimo, hacemos un test para que un usuario recupere de forma eager sus equipos. Si recuperamos un usuario con cualquier m\u00e9todo de servicio (por ejemplo, usuarioService.findById ), el usuario debe ser devuelto con la colecci\u00f3n con sus equipos actualizada. Fichero src/test/java/madstodolist/EquipoServiceTest.java : @Test public void comprobarRelacionUsuarioEquipos () { // GIVEN // Un equipo creado en la base de datos y un usuario registrado Equipo equipo = equipoService . crearEquipo ( \"Proyecto 1\" ); Usuario usuario = new Usuario ( \"user@ua\" ); usuario . setPassword ( \"123\" ); usuario = usuarioService . registrar ( usuario ); // WHEN // A\u00f1adimos el usuario al equipo y lo recuperamos equipoService . addUsuarioEquipo ( usuario . getId (), equipo . getId ()); Usuario usuarioBD = usuarioService . findById ( usuario . getId ()); // THEN // Se recuperan tambi\u00e9n los equipos del usuario, // porque la relaci\u00f3n entre usuarios y equipos es EAGER assertThat ( usuarioBD . getEquipos ()). hasSize ( 1 ); } El test fallar\u00e1, porque debes de cambiar algo en la definici\u00f3n de la relaci\u00f3n entre usuarios y equipos. Modifica el c\u00f3digo para que el test pase, haz un commit y s\u00fabelo a GitHub. Cierre del issue \u00b6 Cuando hayas terminado todos los ciclos de TDD anteriores habr\u00e1s terminado el issue y testeado e implementado los m\u00e9todos necesarios para la clase de servicio que gestiona el listado de equipos y usuarios de esos equipos. Comprueba que el pull request est\u00e9 listo para mezclar (GitHub Actions pasa correctamente todos los tests) y realiza la mezcla para int\u00e9gralo en main en GitHub. Comprueba que el issue asociado se ha cerrado y baja los cambios al repositorio local. Vista y controller listado de equipos \u00b6 Abre un nuevo issue para implementar el controller y las vistas que permitan listar los equipos y consultar sus miembros (por ejemplo, pulsando en un enlace en el nombre del equipo o con un bot\u00f3n en el listado). Realiza el desarrollo del issue usando varios commits en los que a\u00f1adas las funcionalidades poco a poco. No hace falta que hagas TDD, pero a\u00f1ade pruebas para cada m\u00e9todo del controller. Resto de historias de usuario \u00b6 Debes implementar la historia de usuario de la misma forma que hemos implementado la anterior. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. Los m\u00e9todos de servicio para crear equipos o para a\u00f1adir un usuario a un equipo ya han sido implementados en la historia anterior, por lo que puedes usar esta historia para mejorarlos. Por ejemplo, lanzar excepciones si la cadena del nombre es vac\u00eda o si no existe el usuario o el equipo. Importante detalle de implementaci\u00f3n En una relaci\u00f3n muchos-a-muchos como la que existe entre Usuario y Equipo cuando se a\u00f1ade un usuario a un equipo hay que actualizar ambos lados de la relaci\u00f3n, porque JPA/Hibernate no lo hace autom\u00e1ticamente. En el c\u00f3digo de la historia anterior al a\u00f1adir el usuario a la colecci\u00f3n de usuarios del equipo y tambi\u00e9n a\u00f1ad\u00edamos el equipo a la colecci\u00f3n de equipos del usuario. Lo mismo habr\u00eda que hacer cuando se elimina un usuario de un equipo. 010 Gesti\u00f3n de equipos (opcional) : Como administrador puedo cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Pasos a seguir \u00b6 Implementa cada historia de usuario usando el mismo proceso que hemos utilizado para la historia 008. Deber\u00e1s pensar qu\u00e9 servicios son necesarios para la historia y c\u00f3mo implementarlos haciendo TDD. Para cada historia haz dos issues : uno con TDD para implementar la capa de servicio y repository y otro sin TDD para la capa de controller y vista. Cuando est\u00e9s haciendo TDD completa el c\u00f3digo para pasar los tests, uno a uno, haciendo un commit despu\u00e9s de cada fase test-code y otro commit en la fase refactor (en el caso en que tengas que hacer refactorizaci\u00f3n). Los incrementos de c\u00f3digo introducidos por los tests deben ser peque\u00f1os. Debe haber entre 15 y 25 l\u00edneas de c\u00f3digo a\u00f1adidas en las fases de codificaci\u00f3n (sin contar el c\u00f3digo de los tests). No tomes este n\u00famero de forma demasiado estricta; si en alg\u00fan ciclo hay que a\u00f1adir 35 l\u00edneas no pasa nada. Tampoco si haces menos de 15. Pero estar\u00eda mal tener que a\u00f1adir 70 l\u00edneas para resolver un test. Cuando termines las historias de usuario (ve movi\u00e9ndolas tambi\u00e9n en el tablero de Trello) haz el release 1.2.0 con la entrega final de la pr\u00e1ctica. 6. Documentaci\u00f3n, entrega y evaluaci\u00f3n \u00b6 Deber\u00e1s a\u00f1adir una p\u00e1gina de documentaci\u00f3n /doc/practica3.md en la que, al igual que en la pr\u00e1ctica anterior, debes realizar una breve documentaci\u00f3n t\u00e9cnica de entre 500 y 800 palabras sobre lo implementado en las historias de usuario 009 y 010. En la documentaci\u00f3n debes incluir tambi\u00e9n una captura de pantalla en la que se muestren las tablas de la base de datos de desarrollo PostgreSQL en la versi\u00f3n final de la aplicaci\u00f3n. Puedes mostrar, por ejempo, una pantalla con el panel Database de IntelliJ o la herramienta que hayas utilizado. Por ejemplo, puedes incluir en la documentaci\u00f3n lo siguiente. Los puntos 2 en adelante son sobre las historias de usuario 009 y 010 . Pantalla de la base de datos PostgreSQL. Rutas (endpoints) definidas para las acciones y, para cada endpoint o grupo de endpoints, explicaci\u00f3n sobre: Clases y m\u00e9todos Plantillas thymeleaf Tests Explicaci\u00f3n de algunos fragmentos de c\u00f3digo fuente que consideres interesante en las nuevas funcionalidades implementadas. Intenta que el documento tenga un formato limpio y se pueda leer f\u00e1cilmente. Para eso utiliza los bloques de c\u00f3digo de Markdown. Puedes mirar como ejemplo el c\u00f3digo Markdown de estas pr\u00e1cticas. Por ejemplo, el c\u00f3digo Markdown de la introducci\u00f3n a Spring Boot se puede ver pulsando el bot\u00f3n Raw . Ver\u00e1s el texto Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y la fecha l\u00edmite de entrega es el martes 8 de noviembre. La parte obligatoria punt\u00faa sobre 8 y la opcional sobre 2 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Debes subir a DockerHub la imagen docker con la versi\u00f3n final 1.2.0. Es la que me descargar\u00e9 y utilizar\u00e9 para comprobar el funcionamiento final de la pr\u00e1ctica. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 3 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Documentaci\u00f3n.","title":"Pr\u00e1ctica 3"},{"location":"03-pruebas-tdd/integration-tdd.html#practica-3-integracion-con-github-actions-y-tdd","text":"En esta pr\u00e1ctica 3 de la asignatura realizaremos dos tareas principales: Configuraremos un sistema de integraci\u00f3n continua usando las actions del repositorio de GitHub. En este sistema se lanzar\u00e1n los tests autom\u00e1ticamente en cada pull request . Despu\u00e9s definiremos una nueva configuraci\u00f3n del proyecto en la que se lanzar\u00e1n los tests sobre la base de datos PostgreSQL . A\u00f1adiremos nuevas funcionalidades usando la pr\u00e1ctica XP de TDD ( Test Driven Design ). Importante Lee con cuidado todo el enunciado y dedica especial atenci\u00f3n a los apartados con el t\u00edtulo Pasos a seguir . Ah\u00ed est\u00e1n especificadas las acciones que debes realizar en la pr\u00e1ctica. La duraci\u00f3n de la pr\u00e1ctica es de 3 semanas y la fecha l\u00edmite de entrega es el d\u00eda 8 de noviembre.","title":"Pr\u00e1ctica 3: Integraci\u00f3n con GitHub Actions y TDD"},{"location":"03-pruebas-tdd/integration-tdd.html#1-desarrollo-de-la-release-120","text":"En esta pr\u00e1ctica vamos a desarrollar la versi\u00f3n 1.2.0 de la aplicaci\u00f3n ToDoList . A todos los issues y pull requests les debes poner este milestone , indicando que el objetivo es resolverlos y entregarlos en esta release .","title":"1. Desarrollo de la release 1.2.0"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir","text":"Cambia el n\u00famero de versi\u00f3n (en el fichero Acerca De y en el pom.xml ) a 1.2.0-SNAPSHOT para indicar que lo que hay en main es la versi\u00f3n 1.2.0 en progreso . Esta versi\u00f3n la lanzaremos al final del desarrollo de la pr\u00e1ctica, en su entrega.","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#2-integracion-continua-con-github-actions","text":"GitHub Actions es un servicio de GitHub que permite realizar integraci\u00f3n continua en su propia web, sin necesidad de configurar un servidor propio de integraci\u00f3n continua. Puedes consultar el funcionamiento de GitHub Actions leyendo su documentaci\u00f3n, comenzando por las p\u00e1ginas Quickstart for GitHub Actions , Introduction to GitHub Actions y Building and testing Java with Maven . En la pr\u00e1ctica vamos a comenzar configurando GitHub Actions para que todos los pull requests deban pasar los tests de integraci\u00f3n antes de realizar el merge con main .","title":"2. Integraci\u00f3n continua con GitHub Actions"},{"location":"03-pruebas-tdd/integration-tdd.html#tests-en-los-pull-requests","text":"Usando GitHub Actions es posible configurar el repositorio de GitHub para que todos los pull requests deban pasar los tests de integraci\u00f3n en el servicio. En la siguiente imagen vemos el aspecto en GitHub de un pull request estando activa la integraci\u00f3n con Actions. Una vez abierto el PR, se lanzan los flujos de trabajo ( workflows ) definidos en el directorio .github/workflows . GitHub comprueba si la integraci\u00f3n de main con la rama pasa los tests definidos en el workflow. S\u00f3lo si los tests pasan es posible realizar el merge del PR en main.","title":"Tests en los pull requests"},{"location":"03-pruebas-tdd/integration-tdd.html#el-fichero-de-configuracion","text":"Para configurar GitHub Actions basta con a\u00f1adir un fichero de flujo de trabajo en el directorio .github/workflows . El fichero con el flujo de trabajo inicial lo llamaremos developer-tests.yml : Fichero .github/workflows/developer-tests.yml name: Tests on: push jobs: # El nombre del job es launch-test launch-tests: runs-on: ubuntu-latest # Todos los pasos se ejecutan en el contenedor openjda:8-jdk-alpine container: openjdk:8-jdk-alpine steps: # Hacemos un checkout del c\u00f3digo del repositorio - uses: actions/checkout@v2 # Y lanzamos los tests - name: Launch tests with Maven run: ./mvnw test Puntos interesantes a destacar: El nombre del flujo de trabajo es Tests . El nombre del job es launch-tests . Con la palabra clave on se define el evento que causa que se lance el flujo de trabajo. Es en cualquier commit subido a GitHub (push). En jobs se definen los trabajos en paralelo a realizar por el flujo de trabajo. En nuestro caso s\u00f3lo habr\u00e1 uno. En runs-on se define la m\u00e1quina base sobre la que se van a ejecutar los siguientes pasos del flujo. En container se especifica el contenedor Docker que se va a usar para ejecutar los pasos del flujo de trabajo. En uses: actions/checkout@v2 se especifica que se obtenga la versi\u00f3n 2 de la acci\u00f3n llamada actions/checkout . Esta acci\u00f3n se descarga el repositorio en la m\u00e1quina especificada anteriormente y lo deja listo para ejecutar los tests o cualquier otra acci\u00f3n. Por \u00faltimo, con el comando run: ./mvnw test se indica que el flujo de trabajo debe lanzar este comando, que es el que lanza los tests. Los nombres Tests y launch-tests son nombres arbitrarios que indicamos y que despu\u00e9s aparecen en la interfaz de Actions y nos sirven para localizar los distintos pasos.","title":"El fichero de configuraci\u00f3n"},{"location":"03-pruebas-tdd/integration-tdd.html#builds-en-actions","text":"En la pesta\u00f1a Actions de GitHub tenemos toda la informaci\u00f3n de los builds . Es posible visualizarla mientras que se est\u00e1 realizando el build o cuando ya ha terminado. All\u00ed podremos ver el detalle de la ejecuci\u00f3n de los tests y consultar la salida de los mismos para comprobar su resultado. En la siguiente imagen se ha capturado el build en ejecuci\u00f3n. El color naranja significa que el proceso est\u00e1 en ejecuci\u00f3n.","title":"Builds en Actions"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_1","text":"Crea un issue llamado Integraci\u00f3n continua con GitHub Actions . Abre una rama integracion-continua-actions , s\u00fabela a GitHub y abre un pull request. A\u00f1ade el fichero .github/workflows/developer-tests.yml . Haz un commit y s\u00fabelo a GitHub. Comprueba que se pasan los tests y que se marca como correcto el pull request . Modifica un test para que falle y sube un nuevo commit. Recarga la p\u00e1gina del pull request y comprueba que el commit aparece como err\u00f3neo en GitHub cuando el build falla. Pincha en el enlace details para comprobar la descripci\u00f3n del fallo. Corrige el test que falla, vuelve a subir el commit y comprueba que el nuevo commit y el PR pasan correctamente. Cierra el pull request , mezcl\u00e1ndolo con main . Se volver\u00e1n a lanzar los tests en GitHub y el commit aparecer\u00e1 marcado como correcto. Baja los cambios al repositorio local y borra la rama. $ (integracion-continua-actions) git checkout main $ (main) git pull $ (main) git branch -d integracion-continua-actions $ (main) git remote prune origin","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#3-configuracion-de-la-aplicacion-para-usar-una-bd-postgresql","text":"Hasta ahora hemos trabajado con la aplicaci\u00f3n en una configuraci\u00f3n local con nuestro ordenador de desarrollo trabajando sobre una base de datos H2 en memoria. Pero el objetivo final es poner la aplicaci\u00f3n en producci\u00f3n, en un servidor en Internet y usando una base de datos PostgreSQL en producci\u00f3n. Adem\u00e1s, te habr\u00e1s dado cuenta de que es muy engorroso probar la aplicaci\u00f3n con la base de datos de memoria. Tienes que volver a introducir todos los datos de prueba cada vez que paramos y ponemos en marcha la aplicaci\u00f3n. En esta pr\u00e1ctica vamos a ver c\u00f3mo configurar la aplicaci\u00f3n para poder trabajar con una base datos PostgreSQL, tanto en su ejecuci\u00f3n como en los tests. Para configurar la aplicaci\u00f3n vamos a utilizar los denominados perfiles . Definiremos, adem\u00e1s del perfil base, un perfil adicional para lanzar la aplicaci\u00f3n y los tests usando la base de datos PostgreSQL. La configuraci\u00f3n de tests con base de datos PostgreSQL la utilizaremos para ejecutar los tests de integraci\u00f3n sobre la base de datos PostgreSQL en el proceso de integraci\u00f3n continua de GitHub Actions. Para lanzar un servidor de base de datos PostgreSQL usaremos Docker, de forma que no tendremos que realizar ninguna instalaci\u00f3n en nuestro ordenador.","title":"3. Configuraci\u00f3n de la aplicaci\u00f3n para usar una BD PostgreSQL"},{"location":"03-pruebas-tdd/integration-tdd.html#ficheros-de-configuracion-de-la-aplicacion","text":"Ya hemos comentado que la configuraci\u00f3n de la aplicaci\u00f3n se define en el fichero application.properties . Ah\u00ed se definen distintas propiedades de la ejecuci\u00f3n de la aplicaci\u00f3n que se pueden modificar (puerto en el que se lanza la aplicaci\u00f3n, base de datos con la que conectarse, etc.). Tenemos dos ficheros application.properties : uno en el directorio src/main/resources que define la configuraci\u00f3n de ejecuci\u00f3n y otro en el directorio src/test/resources que define la configuraci\u00f3n que se carga cuando se lanzan los tests. Spring Boot permite definir ficheros de configuraci\u00f3n adicionales que pueden sobreescribir y a\u00f1adir propiedades a las definidas en el fichero de configuraci\u00f3n por defecto. El nombre de estos ficheros de configuraci\u00f3n debe ser application-xxx.properties donde xxx define el nombre del perfil. En nuestro caso definiremos los ficheros application-postgres.properties (uno en el directorio main y otro en test ) para definir las configuraciones de ejecuci\u00f3n y de test con PostgreSQL. Estos ficheros de configuraci\u00f3n adicionales se cargan despu\u00e9s de cargar la configuraci\u00f3n por defecto definida en application.properties .","title":"Ficheros de configuraci\u00f3n de la aplicaci\u00f3n"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_2","text":"Crea un nuevo issue llamado A\u00f1adir perfiles y permitir trabajar con PostgreSQL . Crea una rama nueva (ll\u00e1mala perfiles , por ejemplo) y abre un pull request. $ (main) git checkout -b perfiles $ (perfiles) git push -u origin perfiles Copia el siguiente fichero en src/main/resources/application-postgres.properties : spring.datasource.url=jdbc:postgresql://localhost:5432/mads spring.datasource.username=mads spring.datasource.password=mads spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect spring.sql.init.mode=never Este va a ser el perfil que activemos para utilizar la conexi\u00f3n con la BD PostgreSQL. En este fichero de configuraci\u00f3n se define la URL de conexi\u00f3n a la base de datos mads , su usuario ( mads ) y contrase\u00f1a ( mads ) y el dialecto que se va a utilizar para trabajar desde JPA con la base de datos ( org.hibernate.dialect.PostgreSQL9Dialect ). La propiedad spring.sql.init.mode=never indica que no se debe cargar ning\u00fan fichero de datos inicial. Por esto, el fichero data.sql no se va a cargar en la base de datos, deber\u00e1s registrar un usuario inicial para poder probar la aplicaci\u00f3n. La ventaja es que al trabajar con la base de datos real todos los datos van a quedar grabados aunque se pare la aplicaci\u00f3n. Vamos ahora a a\u00f1adir el perfil de test. Copia el siguiente fichero en src/test/resources/application-postgres.properties : spring.datasource.url=jdbc:postgresql://localhost:5432/mads_test spring.datasource.username=mads spring.datasource.password=mads spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect En este perfil la conexi\u00f3n se hace con una base de datos diferente: mads_test , para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. Recuerda que en el perfil por defecto resources/application.properties se define el valor de spring.jpa.hibernate.ddl-auto como create . De esta forma la base de datos se inicializa antes de cargar los datos de los tests y de ejecutarlos. Tambi\u00e9n usamos una base de datos distinta ( mads_test ) para no sobreescribir la base de datos definida en el perfil de ejecuci\u00f3n. A\u00f1ade la siguiente dependencia en el fichero pom.xml para que se descargue el driver postgresql:42.2.22 . Tambi\u00e9n a\u00f1ade las l\u00edneas para poder especificar perfiles desde l\u00ednea de comando. La variable profiles se definir\u00e1 desde l\u00ednea de comando cuando se llame a Maven: Fichero pom.xml : <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.postgresql </groupId> <artifactId> postgresql </artifactId> <version> 42.2.22 </version> </dependency> <dependency> <groupId> org.springframework.boot </groupId> ... <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> <configuration> <profiles> ${profiles} </profiles> </configuration> </plugin> Para lanzar la aplicaci\u00f3n necesitar\u00e1s un servidor PostgreSQL en el puerto 5432 con el usuario mads , la contrase\u00f1a mads y la base de datos mads . Es muy sencillo descargarlo y ejecutarlo si tienes instalado Docker. Ejecuta desde el terminal: docker run -d -p 5432:5432 --name postgres-develop -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 Docker se descarga la imagen postgres:13 y lanza el contenedor (una instancia en marcha de una imagen) conectado al puerto 5432 (no debe estar ocupado) y sobre la base de datos mads . Le da como nombre postgres-develop . Puedes ejecutar los siguientes comandos de Docker: $ docker container ls -a (comprueba todos los contenedores en marcha) $ docker container stop <nombre o id de contenedor> (para un contenedor) $ docker container start <nombre o id de contenedor> (pone en marcha un contenedor) $ docker container logs <mombre o id de contenedor> (muestra logs del contenedor) $ docker container rm nombre o id de contenedor> (elimina un contenedor) Arranca la aplicaci\u00f3n con el siguiente comando: ./mvnw spring-boot:run -D profiles=postgres Se activar\u00e1 el perfil postgres y se cargar\u00e1n las preferencias de src/main/resource/application.properties y src/main/resource/application-postgres.properties . Prueba a introducir datos en la aplicaci\u00f3n y comprueba que se est\u00e1n guardando en la base de datos utilizando por ejemplo el panel Database de IntelliJ . Deber\u00e1s a\u00f1adir una Data Source de tipo PostgreSQL , configurando el usuario y contrase\u00f1a de acceso a mads : A\u00f1ade la conexi\u00f3n con la base de datos mads pulsando en el peque\u00f1o recuadro junto al nombre de la fuente de datos: Y despu\u00e9s ya podr\u00e1s examinar la base de datos mads , pulsando en la tabla que quieras y seleccionando con el bot\u00f3n derecho Edit Data : Cierra la aplicaci\u00f3n y vuelve a abrirla. Comprueba que los datos que se han creado en la ejecuci\u00f3n anterior siguen estando. Podemos tambi\u00e9n parar el contenedor y volverlo a reiniciar y los datos se conservar\u00e1n. Al parar el contenedor no se eliminan los datos, s\u00f3lo al borrarlo. Tambi\u00e9n podemos arrancar la aplicaci\u00f3n con el perfil de postgres lanzando directamente el fichero JAR de la siguiente forma: $ ./mvnw package $ java -Dspring.profiles.active=postgres -jar target/*.jar Para lanzar la aplicaci\u00f3n desde IntelliJ trabajando con el nuevo perfil podemos seleccionar la opci\u00f3n Edit Configurations... del men\u00fa de configuraciones, duplicar la configuraci\u00f3n Application , renombr\u00e1ndola por Application PostgreSQL y a\u00f1adir en el campo Active profiles el nombre del perfil nuevo que acabamos de crear postgres . Es posible que debas recargar el proyecto Maven para actualizar las dependencias. Cierra la aplicaci\u00f3n. Paramos el contenedor con la base de datos de desarrollo haciendo docker container stop postgres-develop : $ docker container ls -a CONTAINER ID IMAGE ... NAME 520fee61d51e posgres:13 ... postgres-develop $ docker container stop postgres-develop Adem\u00e1s de por l\u00ednea de comando, tambi\u00e9n es posible gestionar los contenedores usando la aplicaci\u00f3n Docker Desktop que se encuentra en la propia instalaci\u00f3n de Docker. Vamos ahora a ver c\u00f3mo lanzar los tests sobre una base de datos PostgreSQL. Lanzamos ahora otro contenedor con la base de datos de test ( mads_test ): docker run -d -p 5432:5432 --name postgres-test -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads_test postgres:13 Y lanzamos los tests usando el perfil postgres con la base de datos PostgreSQL con el siguiente comando: ./mvnw -D spring.profiles.active=postgres test Podemos lanzar tambi\u00e9n los tests desde IntelliJ editando la configuraci\u00f3n de lanzamiento de test y a\u00f1adiendo la variable de entorno spring.profiles.active=postgres . Podr\u00edamos, por ejemplo, llamar a esta configuraci\u00f3n Tests con PostgreSQL . Dado que las configuraciones de test y de ejecuci\u00f3n utilizan distintas bases de datos, debemos tener en funcionamiento la base de datos correspondiente a lo que queremos hacer en cada momento. Esto es muy f\u00e1cil usando los contenedores de Docker. Por ejemplo, podemos parar el contenedor PostgreSQL con la base de datos de test y arrancar el contenedor con la base de datos de desarrollo: $ docker container ls -a $ docker container stop postgres-test $ docker container start postgres-develop Realiza un commit con los cambios, s\u00fabelos a la rama y cierra el pull request para integrarlo en main : $ (perfiles) git add . $ (perfiles) git commit -m \"A\u00f1adidos perfiles para trabajar con PostgreSQL\" $ (perfiles) git push // Mezclamos el Pull Request en GitHub $ (perfiles) git checkout main $ (main) git pull $ (main) git branch -d perfiles $ (main) git remote prune origin","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#4-tests-de-integracion-en-github-actions","text":"Vamos a modificar la configuraci\u00f3n de GitHub Actions para conseguir un sistema de integraci\u00f3n continua que ejecute los tests de integraci\u00f3n usando la base de datos real PostgreSQL. La ejecuci\u00f3n de los tests usando la base de datos de memoria H2 ser\u00e1 responsabilidad del desarrollador y se har\u00e1 en el entorno de trabajo local, tal y como se ha hecho desde la primera pr\u00e1ctica.","title":"4. Tests de integraci\u00f3n en GitHub Actions"},{"location":"03-pruebas-tdd/integration-tdd.html#tests-del-desarrollador-vs-tests-de-integracion","text":"Podemos considerar los tests que usan la base de datos real como tests de integraci\u00f3n y los tests que usan la base de datos en memoria como tests del desarrollador . No usamos el nombre de tests unitarios de forma consciente, para evitar conflictos con la nomenclatura. Cuando hablamos de tests del desarrollador nos referimos a tests que van a ejecutar continuamente los desarrolladores en su equipo local cuando est\u00e1n trabajando con la aplicaci\u00f3n y a\u00f1adiendo funcionalidades. Son tests r\u00e1pidos, que se pueden lanzar desde el propio IDE, y que deben ser ejecutados antes de cada commit. Frente a estos tests, los tests de integraci\u00f3n necesitan una configuraci\u00f3n adicional (poner en marcha la base de datos de test en nuestro caso) y se ejecutan menos frecuentemente. Vamos a actualizar GitHub Actions para que se lancen all\u00ed los tests que usan la base de datos PostgreSQL y nos ahorremos el trabajo de realizarlos en local. Seguiremos lanzando en local los tests que usan la BD de memoria mientras hacemos el desarrollo. Dejaremos tambi\u00e9n en GitHub Actions los tests que usan la BD de memoria. Quiz\u00e1s sean redundantes con los que usan la BD de Postgres, pero su ejecuci\u00f3n no cuesta demasiado y no est\u00e1 de m\u00e1s lanzarlos tambi\u00e9n. Podr\u00edamos prescindir de ellos si en alg\u00fan momento comprobamos que el tiempo de ejecuci\u00f3n de los tests en GitHub se hace muy largo.","title":"Tests del desarrollador vs. tests de integraci\u00f3n"},{"location":"03-pruebas-tdd/integration-tdd.html#accion-para-lanzar-los-tests-con-la-bd-postgres","text":"Para lanzar los tests de integraci\u00f3n en GitHub debemos modificar el fichero de configuraci\u00f3n del flujo de trabajo para que lance un contenedor de PostgreSQL y despu\u00e9s se ejecuten los tests sobre ese contenedor. Para tener m\u00e1s flexibilidad en la configuraci\u00f3n de la conexi\u00f3n con PostgreSQL vamos a modificar el perfil de Spring Boot, a\u00f1adiendo unas variables con unos valores por defecto que se pueden modificar definiendo su valor en variables de entorno con el mismo nombre. En concreto, definimos las variables POSTGRES_HOST , POSTGRES_PORT , DB_USER y DB_PASSWD . Fichero src/test/resources/application-postgres.properties : POSTGRES_HOST=localhost POSTGRES_PORT=5432 DB_USER=mads DB_PASSWD=mads spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads_test spring.datasource.username=${DB_USER} spring.datasource.password=${DB_PASSWD} spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect Ya podemos a\u00f1adir un nuevo fichero de flujo de trabajo. Lo llamamos integration-tests.yml Fichero .github/workflows/integration-tests.yml : name: Integration tests on: push jobs: container-job: runs-on: ubuntu-latest container: openjdk:8-jdk-alpine services: # Etiqueta usada para acceder al contenedor del servicio postgres: # Imagen Docker Hub image: postgres:13 # Variables para arrancar PostgreSQL env: POSTGRES_USER: mads POSTGRES_PASSWORD: mads POSTGRES_DB: mads_test # Definimos chequeos para esperar hasta que postgres ya ha comenzado options: >- --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5 steps: - uses: actions/checkout@v2 - name: Launch tests with Maven run: ./mvnw test -D spring.profiles.active=postgres env: POSTGRES_HOST: postgres Se especifica el servicio postgres que se va a usar en el flujo de trabajo. Para configurar este servicio se define la imagen docker ( postgres:13 ) y las variables de entorno que se van a proporcionar al arrancar, para configurar la base de datos (usuario, contrase\u00f1a y base de datos). Estamos definiendo un contenedor docker similar al que hemos usado con los tests cuando hicimos la prueba en local. El nuevo comando de test activa el perfil postgres . Es el mismo comando que usamos cuando hicimos la prueba en local. En la \u00faltima l\u00ednea se actualiza el par\u00e1metro POSTGRES_HOST para que la conexi\u00f3n se realice con el host postgres que es el que nombre que se ha definido en el servicio.","title":"Acci\u00f3n para lanzar los tests con la BD postgres"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_3","text":"Crea un nuevo issue llamado Tests de integraci\u00f3n en GitHub Actions . Crea la rama integracion-gh-actions . $ git checkout -b integracion-gh-actions $ git push -u origin integracion-gh-actions Modifica el fichero del perfil postgres de test tal y como se indica anteriormente, para usar variables de configuraci\u00f3n que puedan ser definidas mediante variables de entorno. Comprueba que siguen funcionando los tests lanzados sobre la base de datos usando los valores por defecto de las variables de entorno. // Nos aseguramos de que la base de datos que est\u00e1 en marcha // es la de test $ docker container ls CONTAINER ID IMAGE PORTS NAMES 411d8f2ea46c postgres:13 0.0.0.0:5432->5432/tcp postgres-test ./mvnw -D spring.profiles.active=postgres test Comprueba que podemos modificar los par\u00e1metros definidos en las variables de entorno. Por ejemplo, si se cambia el nombre del host de la conexi\u00f3n con la base de datos los tests deben de fallar: $ ./mvnw -D spring.profiles.active=postgres -D POSTGRES_HOST=postgres test // Aparecer\u00e1n errores debidos a que no se puede conectar con el // host postgres: org.postgresql.util.PSQLException: El intento de conexi\u00f3n fall\u00f3. ... Caused by: java.net.UnknownHostException: postgres Crea un commit, s\u00fabelo a GitHub y crea el Pull Request $ git add . $ git commit -m \"A\u00f1adidas variables al perfil de test postgres\" $ git push A\u00f1ade el fichero del flujo de trabajo de la acci\u00f3n de GitHub, tal y como se indica anteriormente. Haz un commit, s\u00fabelo a GitHub y comprueba que los tests pasan correctamente y se lanzan all\u00ed usando la base de datos postgres. Una vez comprobado que funcionan los tests de integraci\u00f3n en GitHub, mezclamos el pull request y lo descargamos a local. Comprobamos que tambi\u00e9n se lanzan los tests en el commit de merge en GitHub. Con esto ya tenemos completado un sistema de integraci\u00f3n continua y GitHub se encargar\u00e1 de ejecutar todos los tests en un modo de integraci\u00f3n, usando la base de datos PostgreSQL.","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#5-tdd","text":"En la segunda parte de la pr\u00e1ctica desarrollaremos, usando TDD ( Test Driven Design ), una nueva feature de la aplicaci\u00f3n: la posibilidad de definir definir equipos a los que puedan pertenecer los usuarios. Descomponemos la feature en las siguientes historias de usuario. 008 Listado de equipos 009 Gestionar pertenencia al equipo 010 Gesti\u00f3n de equipos (opcional) 008 Listado de equipos : Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. 010 Gesti\u00f3n de equipos (opcional) : Como administrador podr\u00e9 cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa. Vamos a hacer de forma guiada la primera historia y dejamos las siguientes para que las hagas por tu cuenta.","title":"5. TDD"},{"location":"03-pruebas-tdd/integration-tdd.html#008-listado-de-equipos","text":"La descripci\u00f3n de la historia de usuario es la siguiente: Listado de equipos Como usuario podr\u00e9 consultar el listado de los equipos existentes y los participantes en cada uno de ellos para poder consultar la estructura de la empresa y los proyectos en marcha y comprobar si estoy en los equipos correctos. Detalles * En el men\u00fa aparcer\u00e1 una opci\u00f3n `Equipos` que llevar\u00e1 a un listado con los nombres de todos los equipos existentes. * El listado de equipos estar\u00e1 ordenado por orden alfab\u00e9tico. * Pinchando en el enlace del nombre del equipo nos iremos a una p\u00e1gina con un listado de todos los usuarios que lo componen. * Un usuario podr\u00e1 pertenecer a m\u00e1s de un equipo. Vamos a utilizar la t\u00e9cnica de TDD para construir la funcionalidad de dentro a fuera (desde el repository hasta el controller). Comenzaremos con tests que construyan la capa de modelo (clases de entidad y repository) y despu\u00e9s pasaremos a tests que construyan la capa de servicio. Por \u00faltimo, una vez implementados los m\u00e9todos de servicios necesarios, deber\u00e1s implementar (lo haremos sin tests) las vistas y controllers. Las vistas y controllers los probaremos de forma manual, sin tests autom\u00e1ticos. Importante Los controllers no deben implementar ning\u00fan c\u00f3digo adicional, s\u00f3lo llamar al m\u00e9todo de servicio necesario. De esta forma nos aseguramos que todo el c\u00f3digo importante para la funcionalidad est\u00e1 testeado y ha sido creado mediante TDD. Probaremos los tests usando la base de datos de memoria y dejaremos que sea la acci\u00f3n de GitHub la que pruebe los tests con la base de datos Postgres. Recuerda que los pasos seguir la t\u00e9cnica de TDD: Test : Primero debes escribir el test. Code : Despu\u00e9s debes escribir el c\u00f3digo que hace pasar el test ( \u00fanicamente el c\u00f3digo necesario, no puedes escribir c\u00f3digo de m\u00e1s ) Refactor : Y, si es necesario, realizar una refactorizaci\u00f3n del c\u00f3digo (los tests deben seguir pasando despu\u00e9s de la refactorizaci\u00f3n). Deber\u00e1s hacer un commit por cada fase Test-Code . Si haces refactorizaci\u00f3n deber\u00e1s hacerlo en otro commit adicional.","title":"008 Listado de equipos"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_4","text":"Crea la historia de usuario 008 Listado de equipos en el tablero Trello. Crea dos issues correspondientes a esta historia: Servicio y modelo listado de equipos. Vista y controller listado de equipos. Crea una rama para desarrollar el primer issue (ll\u00e1mala servicio-equipos , por ejemplo) y p\u00e1salo en el tablero a In progress . $ git checkout -b servicio-equipos $ git push -u origin servicio-equipos Este primer issue lo haremos de forma guiada usando TDD con los tests que enumeraremos a continuaci\u00f3n. El otro issue lo deber\u00e1s implementar por ti mismo.","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#resto-de-historias-de-usuario","text":"Debes implementar la historia de usuario de la misma forma que hemos implementado la anterior. 009 Gestionar pertenencia al equipo : Como usuario podr\u00e9 crear nuevos equipos y a\u00f1adirme y eliminarme de cualquiera de ellos para poder participar y dejar de participar en ellos. Los m\u00e9todos de servicio para crear equipos o para a\u00f1adir un usuario a un equipo ya han sido implementados en la historia anterior, por lo que puedes usar esta historia para mejorarlos. Por ejemplo, lanzar excepciones si la cadena del nombre es vac\u00eda o si no existe el usuario o el equipo. Importante detalle de implementaci\u00f3n En una relaci\u00f3n muchos-a-muchos como la que existe entre Usuario y Equipo cuando se a\u00f1ade un usuario a un equipo hay que actualizar ambos lados de la relaci\u00f3n, porque JPA/Hibernate no lo hace autom\u00e1ticamente. En el c\u00f3digo de la historia anterior al a\u00f1adir el usuario a la colecci\u00f3n de usuarios del equipo y tambi\u00e9n a\u00f1ad\u00edamos el equipo a la colecci\u00f3n de equipos del usuario. Lo mismo habr\u00eda que hacer cuando se elimina un usuario de un equipo. 010 Gesti\u00f3n de equipos (opcional) : Como administrador puedo cambiar el nombre y eliminar los equipos para adaptarlos a los proyectos y estructura de la empresa.","title":"Resto de historias de usuario"},{"location":"03-pruebas-tdd/integration-tdd.html#pasos-a-seguir_5","text":"Implementa cada historia de usuario usando el mismo proceso que hemos utilizado para la historia 008. Deber\u00e1s pensar qu\u00e9 servicios son necesarios para la historia y c\u00f3mo implementarlos haciendo TDD. Para cada historia haz dos issues : uno con TDD para implementar la capa de servicio y repository y otro sin TDD para la capa de controller y vista. Cuando est\u00e9s haciendo TDD completa el c\u00f3digo para pasar los tests, uno a uno, haciendo un commit despu\u00e9s de cada fase test-code y otro commit en la fase refactor (en el caso en que tengas que hacer refactorizaci\u00f3n). Los incrementos de c\u00f3digo introducidos por los tests deben ser peque\u00f1os. Debe haber entre 15 y 25 l\u00edneas de c\u00f3digo a\u00f1adidas en las fases de codificaci\u00f3n (sin contar el c\u00f3digo de los tests). No tomes este n\u00famero de forma demasiado estricta; si en alg\u00fan ciclo hay que a\u00f1adir 35 l\u00edneas no pasa nada. Tampoco si haces menos de 15. Pero estar\u00eda mal tener que a\u00f1adir 70 l\u00edneas para resolver un test. Cuando termines las historias de usuario (ve movi\u00e9ndolas tambi\u00e9n en el tablero de Trello) haz el release 1.2.0 con la entrega final de la pr\u00e1ctica.","title":"Pasos a seguir"},{"location":"03-pruebas-tdd/integration-tdd.html#6-documentacion-entrega-y-evaluacion","text":"Deber\u00e1s a\u00f1adir una p\u00e1gina de documentaci\u00f3n /doc/practica3.md en la que, al igual que en la pr\u00e1ctica anterior, debes realizar una breve documentaci\u00f3n t\u00e9cnica de entre 500 y 800 palabras sobre lo implementado en las historias de usuario 009 y 010. En la documentaci\u00f3n debes incluir tambi\u00e9n una captura de pantalla en la que se muestren las tablas de la base de datos de desarrollo PostgreSQL en la versi\u00f3n final de la aplicaci\u00f3n. Puedes mostrar, por ejempo, una pantalla con el panel Database de IntelliJ o la herramienta que hayas utilizado. Por ejemplo, puedes incluir en la documentaci\u00f3n lo siguiente. Los puntos 2 en adelante son sobre las historias de usuario 009 y 010 . Pantalla de la base de datos PostgreSQL. Rutas (endpoints) definidas para las acciones y, para cada endpoint o grupo de endpoints, explicaci\u00f3n sobre: Clases y m\u00e9todos Plantillas thymeleaf Tests Explicaci\u00f3n de algunos fragmentos de c\u00f3digo fuente que consideres interesante en las nuevas funcionalidades implementadas. Intenta que el documento tenga un formato limpio y se pueda leer f\u00e1cilmente. Para eso utiliza los bloques de c\u00f3digo de Markdown. Puedes mirar como ejemplo el c\u00f3digo Markdown de estas pr\u00e1cticas. Por ejemplo, el c\u00f3digo Markdown de la introducci\u00f3n a Spring Boot se puede ver pulsando el bot\u00f3n Raw . Ver\u00e1s el texto Markdown . La pr\u00e1ctica tiene una duraci\u00f3n de 3 semanas y la fecha l\u00edmite de entrega es el martes 8 de noviembre. La parte obligatoria punt\u00faa sobre 8 y la opcional sobre 2 puntos. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas. Para realizar la entrega se debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un ./mvnw clean para eliminar el directorio target que contiene los binarios compilados. Debes dejar tambi\u00e9n en Moodle la URL del repositorio en GitHub. Debes subir a DockerHub la imagen docker con la versi\u00f3n final 1.2.0. Es la que me descargar\u00e9 y utilizar\u00e9 para comprobar el funcionamiento final de la pr\u00e1ctica. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las 3 semanas y no dejar todo para la \u00faltima semana). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Documentaci\u00f3n.","title":"6. Documentaci\u00f3n, entrega y evaluaci\u00f3n"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html","text":"Pr\u00e1ctica 4: Trabajo en equipo con GitFlow y despliegue en producci\u00f3n \u00b6 1. Objetivos y resumen de la pr\u00e1ctica \u00b6 En esta pr\u00e1ctica se pretende conseguir: Crear los equipos de trabajo en GitHub. Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo. Desplegar la aplicaci\u00f3n usando una base de datos de producci\u00f3n y mantener esta base de datos. Implementar GitFlow: Desarrollar nuevas features con GitFlow. Lanzamiento de una versi\u00f3n nueva usando GitFlow. 2. Formaci\u00f3n de equipos \u00b6 En esta pr\u00e1ctica comenzamos a trabajar en equipos de 3 personas. Cada equipo trabajar\u00e1 con un repositorio com\u00fan seleccionado de uno de los miembros del equipo. Utilizaremos GitHub Classroom para crear el team y el repositorio. Pasos a seguir \u00b6 Deb\u00e9is formar equipos de 3 personas . Enviad los componentes al foro de Moodle y os asignar\u00e9 un nombre de equipo. Utilizad despu\u00e9s el enlace de GitHub Classroom que enviar\u00e9 al foro de Moodle para crear el equipo y apuntaros a \u00e9l. El primero que use el enlace debe crear el repositorio, escribiendo el nombre del equipo, como se muestra en la siguiente imagen. El equipo trabajar\u00e1 con un repositorio creado por GitHub Classroom con el nombre todolist--NOMBRE-EQUIPO . Al igual que en la pr\u00e1ctica 2, el repositorio se crear\u00e1 en la organizaci\u00f3n mads-ua-22-23 . Una vez que la primera persona ha creado el equipo y el repositorio, las siguientes personas que usan el enlace pueden unirse al equipo creado o crear un nuevo equipo: Una vez creado el repositorio deb\u00e9is crear en \u00e9l un tablero para gestionar las tarjetas con los issues y los pull requests. Creadlos con las mismas columnas que en las pr\u00e1cticas 2 y 3. Escoged el proyecto que vais a usar como punto de partida de estas dos \u00faltimas pr\u00e1cticas de entre los proyectos de los miembros del equipo. Intentad que se un proyecto con c\u00f3digo limpio y f\u00e1cilmente ampliable. Subidlo al nuevo repositorio, cambiando la URL del origin del repositorio local y haciendo un push: $ git remote set-url origin https://github.com/mads-ua-22-23/todolist-NOMBRE-EQUIPO.git $ git push -u origin main Por \u00faltimo, los otros miembros del equipo deber\u00e1n clonar el repositorio para que los tres pod\u00e1is trabajar con \u00e9l en local. Cambiad el nombre del proyecto (en el fichero POM.xml y en el about.html a todolist-equipo-XX . Haced un commit directamente en main con estos cambios. Comprobad que GitHub Actions sigue funcionando correctamente. 3. Nuevo flujo de trabajo para los issues \u00b6 Debemos adaptar el flujo de trabajo en GitHub al trabajo en equipo. En cuanto a la gesti\u00f3n de los issues y tablero del proyecto cambiaremos lo siguiente: Selecci\u00f3n del issue : Al pasar un issue de To do a In progress se debe asignar un responsable del desarrollo del issue . Nueva rama con el issue : El responsable seleccionado ser\u00e1 el que abra una rama nueva para el desarrollo del ticket y la subir\u00e1 a GitHub. Desarrollo : Se trabaja en la rama. Cualquier compa\u00f1ero puede unirse al ticket y trabajar junto con el responsable, trabajando sobre la rama. Pull request : Cuando el ticket se ha terminado, el responsable abre un pull request en GitHub y pone la tarjeta en la columna In pull request . Revisi\u00f3n de c\u00f3digo : Los miembros del equipo revisan el c\u00f3digo en el pull request (consultar documentaci\u00f3n en GitHub: Reviewing proposed changes in a pull request ). Al menos uno de los miembros del equipo deben dar el OK, a\u00f1adiendo una reacci\u00f3n. Deb\u00e9is configurar la opci\u00f3n de GitHub que obliga a que haya un m\u00ednimo de revisores en el pull request. Integraci\u00f3n del pull request : Cuando un miembro da el OK, el responsable de la tarea integra el pull request. Para implementar el trabajo en equipo ser\u00e1 necesario trabajar sobre ramas remotas compartidas. A continuaci\u00f3n explicamos con m\u00e1s detalle algunos aspectos comandos de Git necesarios. Comandos Git \u00b6 Veamos algunos comandos de Git relacionados con el trabajo compartido en repositorios y ramas remotas. Subir una rama al repositorio remoto: $ git checkout -b nueva-rama $ git push -u origin nueva-rama Descargar por primera vez una rama del repositorio remoto y moverse a ella $ git pull (se descarga la rama nueva que hay en el repositorio remoto) $ git checkout nueva-rama Subir cambios de la rama remota: $ git add . $ git commit -m \"Mis cambios\" $ git push Si somos nosotros los que hemos creado la rama, hay que configurarla para que funcione correctamente el git push haciendo: $ git push -u origin nueva-rama Si alg\u00fan compa\u00f1ero ha subido cambios a la rama remota que tenemos pendientes de descargar, al hacer un git push tendremos un error en el que nos indica que debemos hacer antes un git pull : % git push To https://github.com/domingogallardo/prueba-clase.git ! [rejected] prueba2 -> prueba2 (fetch first) error: fall\u00f3 el push de algunas referencias a 'https://github.com/domingogallardo/prueba-clase.git' ayuda: Actualizaciones fueron rechazadas porque el remoto contiene trabajo que ayuda: no existe localmente. Esto es causado usualmente por otro repositorio ayuda: realizando push a la misma ref. Quiz\u00e1s quieras integrar primero los cambios ayuda: remotos (ej. 'git pull ...') antes de volver a hacer push. Puede ser que al hacer git pull nos aparezca el siguiente mensaje de error: % git pull ayuda: Hacer un pull sin especificar c\u00f3mo reconciliar las ramas es poco ayuda: recomendable. Puedes eliminar este mensaje usando uno de los ayuda: siguientes comandos antes de tu siguiente pull: ayuda: ayuda: git config pull.rebase false # hacer merge (estrategia por defecto) ayuda: git config pull.rebase true # aplicar rebase ayuda: git config pull.ff only # aplicar solo fast-forward ayuda: ayuda: Puedes reemplazar \"git config\" con \"git config --global\" para aplicar ayuda: la preferencia en todos los repositorios. Puedes tambi\u00e9n pasar --rebase, ayuda: --no-rebase, o --ff-only en el comando para sobrescribir la configuraci\u00f3n ayuda: por defecto en cada invocaci\u00f3n. fatal: Necesita especificar c\u00f3mo reconciliar las ramas divergentes. Debemos especificar entonces c\u00f3mo se van a mezclar los cambios que se bajan de la rama remota con los cambios locales. Para ello elegimos la primera opci\u00f3n, que no se haga un rebase sino un merge: $ git config pull.rebase false Ahora ya funciona el git pull (har\u00e1 un merge de la rama remota con la rama local): $ git pull (aparecer\u00e1 un editor en el que tenemos que especificar el mensaje del commit de merge, grabar y salir) Y ahora ya podemos hacer push . Se subir\u00e1n nuestros cambios y el commit de merge: $ git push Comprobar el estado de las ramas locales: $ git branch -vv Con la opci\u00f3n -a ( git branch -vva ) se muestra tambi\u00e9n el estado de las ramas remote tracking de solo lectura (en rojo, y precedidas con el nombre remotes/ ): $ git branch -vva main dd867ac [origin/main] Colocados esquemas en su directorio * prueba 8d2d093 [origin/prueba] Correcci\u00f3n remotes/origin/HEAD -> origin/main remotes/origin/main dd867ac Colocados esquemas en su directorio remotes/origin/prueba 8d2d093 Correcci\u00f3n Este comando no accede directamente al servidor, sino que muestra la informaci\u00f3n de la \u00faltima vez que se accedi\u00f3 a \u00e9l. Si queremos la informaci\u00f3n actualizada podemos hacer un git fetch --all antes: $ git fetch --all $ git branch -vva Es importante recordar que git fetch (a diferencia de git pull ) no modifica los repositorios locales, sino que actualiza las ramas remote tracking . Informaci\u00f3n de los repositorios remotos: $ git remote show origin Proporciona informaci\u00f3n del repositorio remoto, todas sus ramas, del local y de la conexi\u00f3n entre ambos. $ git remote -v update Proporciona informaci\u00f3n del estado de las ramas remotas y locales (si est\u00e1n actualizadas o hay cambios en algunas no bajadas o subidas). Borrado de ramas remotas desde el terminal: $ git push origin --delete nueva-rama $ git remote prune origin Si necesitamos en la rama de feature c\u00f3digo que se haya a\u00f1adido en la rama main . Podemos hacer un merge de la rama main en la rama de feature para incorporar los avances de c\u00f3digo que se han hecho en main y que necesitamos en nuestra nueva rama: $ git checkout nueva-rama $ git merge main Soluci\u00f3n de conflictos en un pull request : Recordamos lo que hemos visto en teor\u00eda sobre la soluci\u00f3n de conflictos detectados en un pull request . Supongamos que hay un conflicto entre la nueva rama y main . GitHub detectar\u00e1 el conflicto en la p\u00e1gina de pull request . Para arreglar el conflicto: $ git checkout main $ git pull $ git checkout nueva-rama $ git merge main # arreglar el conflicto $ git push # ya se puede hacer el merge en GitHub Pasos a seguir \u00b6 A\u00f1adid el milestone 1.3.0 y etiquetad todos los pr\u00f3ximos issues con \u00e9l. Vamos a probar el nuevo flujo de trabajo descrito anteriormente creando un nuevo issue denominado Actualizar la p\u00e1gina Acerca de . En la descripci\u00f3n de issue comentad que se debe modificar la p\u00e1gina para que muestren todos los miembros del equipo y el nuevo n\u00famero de versi\u00f3n de la aplicaci\u00f3n ( 1.3.0-SNAPSHOT ). A\u00f1adid la regla de que sea necesario un revisor en los pull requests. Para ello seleccionar Settings > Branches > Add branch protection rule , poned como patr\u00f3n del nombre de rama el nombre completo main y seleccionad Require a pull request before merging y Require approvals . Poned 1 como n\u00famero de revisores requeridos. Escoged una persona del equipo como responsable del issue . El responsable del issue ser\u00e1 el responsable de integrarlo en main y de solucionar los conflictos que puedan surgir. Probad los comandos Git anteriores en una rama en la que se resuelva el issue . Cada miembro del equipo deber\u00e1 descargar esa rama y realizar un commit en el que se a\u00f1ada su nombre a la lista de autores de la aplicaci\u00f3n. Cread el pull request en GitHub, poniendo como responsable del PR al mismo responsable del issue . Provocad un conflicto y arregladlo. Para ello se debe a\u00f1adir un commit en main que entre en conflicto con los cambios realizados en la rama. Despu\u00e9s se arreglar\u00e1 el conflicto y se subir\u00e1 la soluci\u00f3n al pull request. Por \u00faltimo, revisad el c\u00f3digo, aceptadlo e integrad el PR en main . 4. Contenedor con la aplicaci\u00f3n ToDoList \u00b6 Una de las cosas que vamos a hacer en esta pr\u00e1ctica (en el siguiente apartado) es poner en producci\u00f3n en uno de vuestros ordenadores la aplicaci\u00f3n ToDoList conect\u00e1ndola con la base de datos. En las pr\u00e1cticas 1 y 2 ya hemos construido el contenedor Docker de la aplicaci\u00f3n, con el siguiente fichero Dockerfile: FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"java\" , \"-Djava.security.egd=file:/dev/urandom\" , \"-jar\" , \"/app.jar\" ] Este Dockerfile tiene un problema importante. El comando de ejecuci\u00f3n es fijo y no permite definir ning\u00fan par\u00e1metro de ejecuci\u00f3n. No es posible, por ejemplo, definir el perfil de Postgres, ni definir ning\u00fan par\u00e1metro de configuraci\u00f3n. Debemos cambiarlo de la siguiente forma: FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"sh\" , \"-c\" , \"java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}\" ] De esta forma podremos llamar al comando docker a\u00f1adiendo al final par\u00e1metros que se van a pasar al comando java. La forma de a\u00f1adir variables de entorno a ese comando java es precedi\u00e9ndolos con dos guiones -- . Por ejemplo: $ docker run --rm <usuario>/mads-todolist-equipoXX --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba Vamos a probarlo, creando y subiendo la nueva imagen a DockerHub y despleg\u00e1ndola en uno de vuestros ordenadores. Este despliegue es lo que har\u00e9 yo para corregir la pr\u00e1ctica. Pasos a seguir \u00b6 Deb\u00e9is hacer lo siguiente: Creamos un issue llamado Configuraci\u00f3n imagen docker y trabajamos en la rama imagen-docker . Cambiad el fichero Dockerfile de la aplicaci\u00f3n tal y como se indica en el listado anterior: Fichero Dockerfile : FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"sh\" , \"-c\" , \"java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}\" ] Modificad el fichero con el perfil postgres de ejecuci\u00f3n para incluir la opci\u00f3n de usar variables de entorno, al igual que hicimos en el perfil postgres de test. Fichero src/main/resources/application-postgres.properties : POSTGRES_HOST=localhost POSTGRES_PORT=5432 DB_USER=mads DB_PASSWD=mads spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads spring.datasource.username=${DB_USER} spring.datasource.password=${DB_PASSWD} spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect spring.sql.init.mode=never Cread la nueva imagen Docker con el nombre mads-todolist-equipoXX y la etiqueta 1.3.0-snapshot . El usuario puede ser cualquier miembro del equipo, no es necesario que sea el autor del proyecto original. $ ./mvnw package $ docker build -t <usuario-docker>/mads-todolist-equipoXX:1.3.0-snapshot . Probad que funcionan correctamente los par\u00e1metros de configuraci\u00f3n en la imagen Docker. Una forma sencilla de hacerlo es comprobar que se puede definir el perfil de Postgres y modificar alguno de sus par\u00e1metros. Deber\u00e1 aparecer un mensaje de error de que no se puede conectar con la base de datos (lo que est\u00e1 bien, porque significa que s\u00ed que se ha cargado el perfil). $ docker run --rm <usuario>/mads-todolist-equipoXX:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba Subid, por \u00faltimo, la imagen a Docker Hub y cerrad el PR y el issue. $ docker login $ docker push <usuario-docker>/mads-todolist-equipoXX:1.3.0-snapshot 5. Despliegue en producci\u00f3n con BD \u00b6 Vamos a ver c\u00f3mo ejecutar en producci\u00f3n el contenedor con la aplicaci\u00f3n de forma que se conecte con una base de datos postgres. En las pr\u00e1cticas 1 y 2 vimos c\u00f3mo construir una versi\u00f3n en forma de contenedor de nuestra aplicaci\u00f3n Spring Boot y en la pr\u00e1ctica 3 vimos como usar un contenedor de Postgres para definir un servicio de base de datos con el que conectar la aplicaci\u00f3n. En esta pr\u00e1ctica vamos a definir la configuraci\u00f3n en producci\u00f3n definitiva de nuestra aplicaci\u00f3n. Veremos c\u00f3mo poner en marcha dos contenedores y conectarlos entre si. En nuestro caso un contenedor tendr\u00e1 la base de datos postgres y el otro la aplicaci\u00f3n Spring Boot. La imagen anterior muestra los dos contenedores conectados por una red. Desde el contenedor con la aplicaci\u00f3n se acceder\u00e1 a la direcci\u00f3n postgres:5432 para conectarse con la base de datos. Veremos los comandos de docker para definir una red y para lanzar el contenedor de base de datos en esa direcci\u00f3n de la red. El contenedor de base de datos montar\u00e1 el directorio actual del host en el directorio /mi-host del contenedor. De esta forma, cualquier fichero que coloquemos en ese directorio del contenedor ser\u00e1 visible en el directorio actual del host (y viceversa). Usaremos este directorio para guardar datos de la base de datos, como copias de seguridad o ficheros de migraci\u00f3n. El contenedor de base de datos implementar\u00e1 la base de datos en producci\u00f3n. Base de datos de producci\u00f3n La base de datos de producci\u00f3n es la que mantiene los datos introducidos por los usuarios de la misma. Hay que prestar una atenci\u00f3n especial a esta base de datos y definir pol\u00edticas de respaldo y de control de cambios para evitar que se produzca cualquier p\u00e9rdida de informaci\u00f3n. Veremos que una de las cuestiones que hay que asegurar es que la aplicaci\u00f3n no puede modificar el esquema de datos de esta base de datos. Habr\u00e1 que definir tambi\u00e9n un flujo de trabajo para actualizar la base de datos de producci\u00f3n con los cambios del modelo de datos introducidos por la nuevas funcionalidades (nuevas tablas y nuevas relaciones). Pasos a seguir \u00b6 Veamos paso a paso c\u00f3mo crear la configuraci\u00f3n anterior en uno de vuestros ordenadores, que usar\u00e9is como ordenador de despliegue. Creamos en nuestro ordenador de despliegue una red gestionada por Docker: $ docker network create network-equipo Lanzamos el contenedor con la base de datos usando la red creada anteriormente y con el nombre db-equipo . Definimos el nombre del host creado en el contenedor como postgres con el modificador --network-alias . $ docker run -d --network network-equipo --network-alias postgres -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 El modificador -v permite montar el directorio actual en el directorio /mi-host del contenedor. Opci\u00f3n -v de Docker en Windows Si est\u00e1is en Windows deber\u00e9is especificar el directorio actual expl\u00edcitamente, sustituyendo las barras por barras dobles: $ docker run -d --network network-equipo --network-alias postgres -v C:\\\\users\\\\domingo\\\\tmp:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 Vamos a probar que funciona correctamente. Nos conectamos al contenedor lanzando un bash interactivo. Estando en el contenedor creamos un fichero en el directorio /mi-host , salimos del contenedor y comprobamos que est\u00e1 en el directorio actual $ docker exec -it db-equipo bash root@e470db191dc6:/# cd /mi-host root@e470db191dc6:/mi-host# echo \"Hola\" > prueba.txt root@e470db191dc6:/mi-host# exit $ ls prueba.txt $ more prueba.txt Hola Con esto ya tenemos configurado y en marcha el contenedor con la base de datos Postgres. Esta va a ser nuestra base de datos de producci\u00f3n. Vamos ahora a poner en marcha la aplicaci\u00f3n. Descargamos la \u00faltima versi\u00f3n de nuestra aplicaci\u00f3n y lanzamos el contenedor usando la red definida anteriormente. Los modificadores --spring.profiles.active y --POSTGRES_HOST permiten pasar al contenedor esas variables del entorno. $ docker pull <usuario>/mads-todolist-equipoXX:1.3.0-snapshot $ docker run --rm --network network-equipo -p8080:8080 <usuario>/mads-todolist-equipoXX:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=postgres \u00a1\u00a1\u00a1Enhorabuena!!! \u00a1Ya tenemos la aplicaci\u00f3n en producci\u00f3n trabajando con la base de datos! Podremos conectarnos a la aplicaci\u00f3n usando el puerto 8080. Probamos la aplicaci\u00f3n y creamos alg\u00fan usuario de prueba. Por \u00faltimo paramos el contenedor y lo volvemos a arrancar para comprobar que los datos son persistentes. Para comprobar que la base de datos est\u00e1 funcionando correctamente podemos conectarnos al contenedor y examinar la base de datos mads y alguna de sus tablas: $ docker exec -it db-equipo bash # psql -U mads -W mads (nos pedir\u00e1 la contrase\u00f1a: mads) # \\l (lista las bases de datos) # \\dt (lista las tablas) # SELECT * FROM usuarios; La base de datos se mantendr\u00e1 mientras que no borremos el contenedor. Podemos pararlo y volver a ponerlo en marcha y seguiremos conservando los datos: $ docker stop db-equipo $ docker start db-equipo 6. Perfil de producci\u00f3n y mantenimiento de la base de datos de producci\u00f3n \u00b6 Perfil de producci\u00f3n \u00b6 Una vez que vamos a trabajar en producci\u00f3n con una base de datos, esta base de datos ser\u00e1 un elemento clave de la aplicaci\u00f3n. No debemos, bajo ning\u00fan concepto, perder datos que se hayan introducido en ella, ya que son datos de nuestros usuarios y clientes. Es imprescindible para ello cambiar el modo con el que la aplicaci\u00f3n construye las tablas de la base de datos. Sabemos que nuestra aplicaci\u00f3n est\u00e1 trabajando con JPA/Hibernate y que las tablas de la base de datos se construyen de forma autom\u00e1tica. Si hay alg\u00fan cambio en las entidades (se a\u00f1ade alg\u00fan atributo o alguna nueva entidad) Spring Boot actualiza las tablas de la base de datos de forma autom\u00e1tica cuando se lanza la aplicaci\u00f3n. Esto es razonable si estamos trabajando en un entorno de desarrollo, pero est\u00e1 totalmente desaconsejado en un entorno de producci\u00f3n. El par\u00e1metro spring.jpa.hibernate.ddl-auto es el que determina el funcionamiento de la actualizaci\u00f3n de las tablas de la base de datos. Su valor puede ser: CREATE : El esquema de datos se crea de nuevo cada vez que se lanza la aplicaci\u00f3n. Una vez creado, se a\u00f1aden los datos definidos en el fichero data.sql si el spring.sql.init.mode tiene como valor always . UPDATE : El esquema de datos de la base de datos se actualiza autom\u00e1ticamente cuando hay un cambio en las entidades de la aplicaci\u00f3n. As\u00ed es como tenemos configurado el perfil por defecto de nuestra aplicaci\u00f3n. Si estamos trabajando con la base de datos Postgres, se actualizar\u00e1 el esquema de datos. Pero esto no es recomendable para producci\u00f3n, porque no tenemos control de las instrucciones de actualizaci\u00f3n y pueden resultar en alguna p\u00e9rdida de datos. VALIDATE : El esquema de datos de la base de datos se valida con respecto al esquema de datos definido por las entidades JPA. Si hay alguna diferencia, salta una excepci\u00f3n. Este es el valor que hay que usar cuando lanzamos la aplicaci\u00f3n en producci\u00f3n. Vamos a definir en la aplicaci\u00f3n un nuevo perfil de ejecuci\u00f3n, llamado postgres-prod , en el que pondremos el valor del par\u00e1metro spring.jpa.hibernate.ddl-auto a VALIDATE . Y ser\u00e1 este el perfil que usaremos para lanzar la aplicaci\u00f3n en uno de vuestros ordenadores, que har\u00e1 de servidor de producci\u00f3n. Mantenimiento de la base de datos de producci\u00f3n \u00b6 En una aplicaci\u00f3n en producci\u00f3n se deben configurar pol\u00edticas estrictas de realizaci\u00f3n de copias de seguridad y de integridad de los datos. Tambi\u00e9n en la gesti\u00f3n de las versiones y en la actualizaci\u00f3n del esquema de datos. Esto \u00faltimo se denomina una migraci\u00f3n de la base de datos y representa un elemento fundamental del mantenimiento en producci\u00f3n de una aplicaci\u00f3n, sobre todo cuando estamos trabajando de una forma \u00e1gil e incremental. Es un tema avanzado muy importante, pero que no podemos abordar en la asignatura por falta de tiempo. Un par de referencias que os pueden ser de utilidad son el art\u00edculo Evolutionary Database Design y herramientas como Flyway que permiten automatizar las migraciones de la base de datos. En la pr\u00e1ctica vamos a trabajar con la base de datos de producci\u00f3n de dos formas: Realizaremos una copia de seguridad antes de instalar una nueva versi\u00f3n. Actualizaremos el esquema de datos aplicando un fichero de migraci\u00f3n que construiremos manualmente. Copias de seguridad \u00b6 Si eliminamos el contenedor con la base de datos se perder\u00e1n todos los datos. Para evitar perder los datos, con el contenedor en marcha podemos hacer una copia de seguridad de la base de datos mads en el directorio compartido: $ docker exec -it db-equipo bash # pg_dump -U mads --clean mads > /mi-host/backup03092021.sql La copia de seguridad se guarda en el directorio compartido. Podemos poner la fecha en el nombre del fichero. Por ejemplo, la copia anterior ha sido creada el 3 de septiembre del 2021. Para restaurar una copia de seguridad basta con ejecutar el fichero SQL en la base de datos: $ docker exec -it db-equipo bash # psql -U mads mads < /mi-host/backup03092021.sql # exit Migraci\u00f3n de la base de datos \u00b6 Podemos obtener el esquema de datos de la aplicaci\u00f3n (la definici\u00f3n de las tablas, sin los datos) conect\u00e1ndonos al contenedor y ejecutando el siguiente comando para guardar el fichero en el directorio compartido: $ docker exec -it db-equipo bash # pg_dump -U mads -s mads > /mi-host/schema.sql # exit Tendremos el esquema de datos en el directorio actual, que hemos montado en el contenedor con la instrucci\u00f3n -V. Los esquemas son instrucciones SQL en texto plano. Supongamos que tenemos una nueva versi\u00f3n de la aplicaci\u00f3n ( 1.3.0 ) en la que hemos a\u00f1adido el atributo descripcion a la entidad Equipo . Si generamos el esquema de datos de esta nueva versi\u00f3n y lo llamamos schema-1.3.0.sql lo podemos comparar con el esquema anterior usando el comando de linux diff : % diff sql/schema-1.3.0.sql sql/schema-1.2.0.sql 41,42c41 < nombre character varying(255), < descripcion character varying(255) --- > nombre character varying(255) Por ejemplo, en el ejemplo mostrado, el fichero schema-1.3.0.sql tiene un campo adicional que el fichero schema-1.2.0.sql . Se trata del campo descripcion . En la versi\u00f3n anterior ( schema-1.2.0.sql ) la tabla equipo se define como: CREATE TABLE public . equipos ( id bigint NOT NULL , nombre character varying ( 255 ) ); Mientras que en la versi\u00f3n nueva ( schema-1.3.0.sql ) se define como: CREATE TABLE public . equipos ( id bigint NOT NULL , nombre character varying ( 255 ), descripcion character varying ( 255 ) ); Si queremos migrar la base de datos de producci\u00f3n de una versi\u00f3n a otra, debemos crear un script de migraci\u00f3n en el que modifiquemos \u00fanicamente el esquema de datos anterior para adaptarlo al nuevo. En este caso el script lo llamaremos schema-1.2.0-1.3.0.sql y contendr\u00e1 \u00fanicamente la siguiente instrucci\u00f3n: ALTER TABLE public . equipos ADD COLUMN descripcion character varying ( 255 ) Para actualizar la base de datos de producci\u00f3n s\u00f3lo tenemos que ejecutar el script anterior: $ docker exec -it db-equipo bash $ psql -U mads mads < /mi-host/schema-1.2.0-1.3.0.sql ALTER TABLE $ exit De esta forma habremos a\u00f1adido manualmente un campo en la tabla equipos . La aplicaci\u00f3n deber\u00e1 funcionar ahora perfectamente si la lanzamos en modo producci\u00f3n, definiendo la variable que hemos mencionado antes con el modo validate : spring.jpa.hibernate.ddl-auto=validate Pasos a seguir \u00b6 Creamos un issue llamado Esquema de datos y perfil de producci\u00f3n y trabajamos en la rama esquema-datos y en el pull request equivalente. $ git checkout -b esquema-datos $ git push -u origin esquema-datos Lanzamos la aplicaci\u00f3n en local con el modo postgres , trabajando sobre la base de datos. Previamente hemos lanzado el contenedor postgres montando el directorio actual en su directorio /mi-host/ : $ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 $ ./mvnw spring-boot:run -D profiles=postgres Al lanzar la aplicaci\u00f3n se habr\u00e1 creado en la base de datos el esquema de datos. Lo generamos y lo salvamos en el directorio actual: $ docker exec -it db-equipo bash # pg_dump -U mads -s mads > /mi-host/schema-1.2.0.sql # exit Comprobamos que el esquema de datos se ha creado correctamente y lo movemos al directorio sql en el directorio ra\u00edz: $ ls -l Dockerfile README.md mvnw mvnw.cmd pom.xml schema-1.2.0.sql src target $ mkdir sql $ mv schema-1.2.0.sql sql Creamos un commit con el nuevo fichero con el esquema de datos. Creamos un nuevo fichero con el perfil de producci\u00f3n, que contiene exactamente la misma configuraci\u00f3n del perfil postgres, excepto la propiedad spring.jpa.hibernate.ddl-auto que tiene el valor validate . Fichero /src/main/resources/application-postgres-prod.properties : POSTGRES_HOST=localhost POSTGRES_PORT=5432 DB_USER=mads DB_PASSWD=mads spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads spring.datasource.username=${DB_USER} spring.datasource.password=${DB_PASSWD} spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect spring.sql.init.mode=never spring.jpa.hibernate.ddl-auto=validate Probamos en local que el perfil funciona correctamente, lanz\u00e1ndolo: $ ./mvnw spring-boot:run -D profiles=postgres-prod Probamos que realmente valida el esquema de datos, en lugar de actualizarlo. Para ello, paramos y borramos el contenedor postgres y lo lanzamos de nuevo. Esto crear\u00e1 una base de datos vac\u00eda: $ docker container stop db-equipo $ docker container rm db-equipo $ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 Si ahora lanzamos la aplicaci\u00f3n en modo postgres-prod obtendremos un error: $ ./mvnw spring-boot:run -D profiles=postgres-prod org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is javax.persistence.PersistenceException: [PersistenceUnit: default] Unable to build Hibernate SessionFactory; nested exception is org.hibernate.tool.schema.spi.SchemaManagementException: Schema-validation: missing table [equipo_usuario] 8. Actualizamos el contenedor postgres con el esquema de base de datos salvado anteriormente: $ docker exec -it db-equipo bash # psql -U mads mads < /mi-host/sql/schema-1.2.0.sql # exit Y arrancamos la aplicaci\u00f3n y comprobamos que ahora s\u00ed que funciona correctamente (la base de datos ya tiene el esquema de datos correcto). Introducimos en la aplicaci\u00f3n algunos datos de prueba y hacemos una copia de seguridad tal y como se explica anteriormente. Dejamos el fichero en el directorio sql del repositorio, indicando la fecha en el nombre del mismo. Por ejemplo sql/backup15112022.sql . Hacemos un commit, subimos los cambios y cerramos el pull request y el issue. 7. Desarrollo de la nueva versi\u00f3n con GitFlow \u00b6 El flujo de trabajo Git que vamos a seguir es muy similar al flujo de trabajo GitFlow (recordad la clase de teor\u00eda ) Ramas de largo recorrido \u00b6 En GitFlow se publican las distintas versiones del proyecto en la rama long-lived main y se hace el desarrollo en la rama develop . A partir de ahora no desarrollaremos directamente en main sino en develop . En la p\u00e1gina de configuraci\u00f3n del repositorio en GitHub en Settings > Branches > Default branch se puede configurar la rama por defecto contra la que se realizar\u00e1n los commits y la que aparecer\u00e1 en la p\u00e1gina del proyecto. Tendr\u00e9is que definir develop . Ramas de feature \u00b6 Desde el comienzo de trabajo con Git en las pr\u00e1cticas 2 y 3 estamos haciendo un desarrollo basado en ramas de corto recorrido, equivalentes a las ramas de features de GitFlow. Tal y como se comenta en GitFLow estas ramas saldr\u00e1n de develop y se integrar\u00e1n en develop . La diferencia es que en GitFlow estas ramas se integran con la rama de desarrollo manualmente haciendo merge , mientras que nosotros las integramos haciendo un pull request. Pasos a seguir \u00b6 Cread la rama develop y configurarla como rama principal del proyecto en GitHub. A\u00f1adir en los ajustes del repositorio la regla para obligar a revisar todos los PR que se mezclen en esta rama. Todos los otros miembros deber\u00e1n descargarla y moverse a ella en sus repositorios locales. Esta rama pasar\u00e1 a ser la de desarrollo principal. Cread tres issues distintos, simulando tres nuevas funcionalidades. Deben ser issues sencillos, que no cuesten demasiado de implementar (mejorar alg\u00fan defecto de la aplicaci\u00f3n, cambiar alg\u00fan elemento de alguna de las vistas, o algo similar). Uno de los cambios debe afectar a alguna entidad , por ejemplo a\u00f1adir un campo de descripci\u00f3n a los equipos y actualizar las vistas correspondientes para permitir su inicializaci\u00f3n y su actualizaci\u00f3n. Cada uno de los miembros del equipo ser\u00e1 el responsable de uno de los issues. Configurad el repositorio GitHub para obligar a que cualquier pull request tenga que tener la revisi\u00f3n de una persona distinta del responsable del PR. Desarrollad e integrar los issues en develop siguiendo el flujo de trabajo planteado anteriormente. Deb\u00e9is ir actualizando el tablero de GitHub se actualiza correctamente. Rama de release \u00b6 Hasta ahora hemos hecho los releases en la rama main . A partir de ahora seguiremos la estrategia de GitFlow y haremos ramas de release que salen de develop y se integran en main y en develop . Haremos tambi\u00e9n la integraci\u00f3n haciendo pull request. Una cosa importante que tendremos que hacer en el release es crear el guardar el de datos de la nueva versi\u00f3n y crear el script de migraci\u00f3n de la base de datos. Pasos a seguir \u00b6 Vamos a probar el lanzamiento de una release usando el flujo de trabajo GitFlow. Cread un issue con la tarea Lanzar release 1.3.0 . Siguiendo las indicaciones de GitFlow, crear la rama local release-1.3.0 a partir de develop . En esta rama se deben realizar los cambios espec\u00edficos de la versi\u00f3n. En nuestro caso: Cambiar en la p\u00e1gina Acerca de \"Versi\u00f3n 1.3.0-SNAPSHOT\" a \"Versi\u00f3n 1.3.0\" y a\u00f1adir la fecha de publicaci\u00f3n. Cambiar el fichero pom.xml . Generad el esquema de datos de la base de datos postgres y guardarlo en sql/schema-1.3.0.sql . Comparar este esquema con el esquema anterior y crear el script de migraci\u00f3n con las instrucciones ALTER TABLE necesarias para actualizar la base de datos de producci\u00f3n de la versi\u00f3n 1.2.0 a la 1.3.0. Guardar el script en sql/schema-1.2.0-1.3.0.sql . Comprobad que funciona correctamente el script de migraci\u00f3n. Para ello deber\u00e9is simular que pon\u00e9is en marcha la aplicaci\u00f3n en modo producci\u00f3n trabajando con una actualizaci\u00f3n de la base de datos: Poner en marcha una base de datos de producci\u00f3n vac\u00eda. Actualizar la base de datos con la copia de seguridad guardada en el directorio sql . Actualizar la base de datos con el script de migraci\u00f3n sql/schema-1.2.0-1.3.0.sql , tal y como se explica en el apartado anterior. Lanzar el contenedor de la aplicaci\u00f3n con el perfil postgres-prod y comprobar que funciona correctamente la aplicaci\u00f3n en producci\u00f3n y que se mantienen los datos anteriores. A\u00f1adir nuevos datos y hacer una nueva copia de seguridad que se debe guardar tambi\u00e9n en el directorio src , con la fecha actual como nombre como hicimos anteriormente. Por ejemplo, src/backup-20112022.sql . Haced un commit para a\u00f1adir esta nueva copia de seguridad al repositorio. Publicad la rama release-1.3.0 en GitHub y hacer un pull request sobre main . Una vez mezclado el PR a\u00f1adir la etiqueta con la nueva versi\u00f3n 1.3.0 en main creando la p\u00e1gina de release en GitHub. Mezclar tambi\u00e9n la rama de release con develop (se puede hacer tambi\u00e9n con un PR). Subir la nueva versi\u00f3n de la imagen de docker a Docker Hub. Una vez hecho esto ya se puede borrar la rama release-1.3.0 y las ramas main y develop estar\u00e1n actualizadas a la nueva versi\u00f3n. Debemos comprobar que GitHub Actions pasa correctamente todos los tests de las nuevas caracter\u00edsticas que se a\u00f1aden. 9. Documentaci\u00f3n, entrega y evaluaci\u00f3n \u00b6 Deber\u00e9is a\u00f1adir una p\u00e1gina de documentaci\u00f3n /doc/practica4.md en la que deber\u00e9is incluir: Breve documentaci\u00f3n t\u00e9cnica de los cambios introducidos en la aplicaci\u00f3n. Detalles del despliegue de producci\u00f3n. Esquemas de datos de las versiones 1.2.0 y de la versi\u00f3n 1.3.0. Script de migraci\u00f3n de la base de datos. URL de la imagen Docker de la aplicaci\u00f3n. Entrega: La pr\u00e1ctica tiene una duraci\u00f3n de 2 semanas y debe estar terminada el martes 22 de noviembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 15% en la nota final de pr\u00e1cticas. Para realizar la entrega uno de los miembros del equipo debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un mvn clean para eliminar el directorio target que contiene los binarios compilados. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las semanas y no dejar todo para la \u00faltima). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Funcionamiento de la aplicaci\u00f3n con las bases de datos de producci\u00f3n y funcionamiento del script de migraci\u00f3n. Documentaci\u00f3n.","title":"Pr\u00e1ctica 4"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#practica-4-trabajo-en-equipo-con-gitflow-y-despliegue-en-produccion","text":"","title":"Pr\u00e1ctica 4: Trabajo en equipo con GitFlow y despliegue en producci\u00f3n"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#1-objetivos-y-resumen-de-la-practica","text":"En esta pr\u00e1ctica se pretende conseguir: Crear los equipos de trabajo en GitHub. Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo. Desplegar la aplicaci\u00f3n usando una base de datos de producci\u00f3n y mantener esta base de datos. Implementar GitFlow: Desarrollar nuevas features con GitFlow. Lanzamiento de una versi\u00f3n nueva usando GitFlow.","title":"1. Objetivos y resumen de la pr\u00e1ctica"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#2-formacion-de-equipos","text":"En esta pr\u00e1ctica comenzamos a trabajar en equipos de 3 personas. Cada equipo trabajar\u00e1 con un repositorio com\u00fan seleccionado de uno de los miembros del equipo. Utilizaremos GitHub Classroom para crear el team y el repositorio.","title":"2. Formaci\u00f3n de equipos"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir","text":"Deb\u00e9is formar equipos de 3 personas . Enviad los componentes al foro de Moodle y os asignar\u00e9 un nombre de equipo. Utilizad despu\u00e9s el enlace de GitHub Classroom que enviar\u00e9 al foro de Moodle para crear el equipo y apuntaros a \u00e9l. El primero que use el enlace debe crear el repositorio, escribiendo el nombre del equipo, como se muestra en la siguiente imagen. El equipo trabajar\u00e1 con un repositorio creado por GitHub Classroom con el nombre todolist--NOMBRE-EQUIPO . Al igual que en la pr\u00e1ctica 2, el repositorio se crear\u00e1 en la organizaci\u00f3n mads-ua-22-23 . Una vez que la primera persona ha creado el equipo y el repositorio, las siguientes personas que usan el enlace pueden unirse al equipo creado o crear un nuevo equipo: Una vez creado el repositorio deb\u00e9is crear en \u00e9l un tablero para gestionar las tarjetas con los issues y los pull requests. Creadlos con las mismas columnas que en las pr\u00e1cticas 2 y 3. Escoged el proyecto que vais a usar como punto de partida de estas dos \u00faltimas pr\u00e1cticas de entre los proyectos de los miembros del equipo. Intentad que se un proyecto con c\u00f3digo limpio y f\u00e1cilmente ampliable. Subidlo al nuevo repositorio, cambiando la URL del origin del repositorio local y haciendo un push: $ git remote set-url origin https://github.com/mads-ua-22-23/todolist-NOMBRE-EQUIPO.git $ git push -u origin main Por \u00faltimo, los otros miembros del equipo deber\u00e1n clonar el repositorio para que los tres pod\u00e1is trabajar con \u00e9l en local. Cambiad el nombre del proyecto (en el fichero POM.xml y en el about.html a todolist-equipo-XX . Haced un commit directamente en main con estos cambios. Comprobad que GitHub Actions sigue funcionando correctamente.","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#3-nuevo-flujo-de-trabajo-para-los-issues","text":"Debemos adaptar el flujo de trabajo en GitHub al trabajo en equipo. En cuanto a la gesti\u00f3n de los issues y tablero del proyecto cambiaremos lo siguiente: Selecci\u00f3n del issue : Al pasar un issue de To do a In progress se debe asignar un responsable del desarrollo del issue . Nueva rama con el issue : El responsable seleccionado ser\u00e1 el que abra una rama nueva para el desarrollo del ticket y la subir\u00e1 a GitHub. Desarrollo : Se trabaja en la rama. Cualquier compa\u00f1ero puede unirse al ticket y trabajar junto con el responsable, trabajando sobre la rama. Pull request : Cuando el ticket se ha terminado, el responsable abre un pull request en GitHub y pone la tarjeta en la columna In pull request . Revisi\u00f3n de c\u00f3digo : Los miembros del equipo revisan el c\u00f3digo en el pull request (consultar documentaci\u00f3n en GitHub: Reviewing proposed changes in a pull request ). Al menos uno de los miembros del equipo deben dar el OK, a\u00f1adiendo una reacci\u00f3n. Deb\u00e9is configurar la opci\u00f3n de GitHub que obliga a que haya un m\u00ednimo de revisores en el pull request. Integraci\u00f3n del pull request : Cuando un miembro da el OK, el responsable de la tarea integra el pull request. Para implementar el trabajo en equipo ser\u00e1 necesario trabajar sobre ramas remotas compartidas. A continuaci\u00f3n explicamos con m\u00e1s detalle algunos aspectos comandos de Git necesarios.","title":"3. Nuevo flujo de trabajo para los issues"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#comandos-git","text":"Veamos algunos comandos de Git relacionados con el trabajo compartido en repositorios y ramas remotas. Subir una rama al repositorio remoto: $ git checkout -b nueva-rama $ git push -u origin nueva-rama Descargar por primera vez una rama del repositorio remoto y moverse a ella $ git pull (se descarga la rama nueva que hay en el repositorio remoto) $ git checkout nueva-rama Subir cambios de la rama remota: $ git add . $ git commit -m \"Mis cambios\" $ git push Si somos nosotros los que hemos creado la rama, hay que configurarla para que funcione correctamente el git push haciendo: $ git push -u origin nueva-rama Si alg\u00fan compa\u00f1ero ha subido cambios a la rama remota que tenemos pendientes de descargar, al hacer un git push tendremos un error en el que nos indica que debemos hacer antes un git pull : % git push To https://github.com/domingogallardo/prueba-clase.git ! [rejected] prueba2 -> prueba2 (fetch first) error: fall\u00f3 el push de algunas referencias a 'https://github.com/domingogallardo/prueba-clase.git' ayuda: Actualizaciones fueron rechazadas porque el remoto contiene trabajo que ayuda: no existe localmente. Esto es causado usualmente por otro repositorio ayuda: realizando push a la misma ref. Quiz\u00e1s quieras integrar primero los cambios ayuda: remotos (ej. 'git pull ...') antes de volver a hacer push. Puede ser que al hacer git pull nos aparezca el siguiente mensaje de error: % git pull ayuda: Hacer un pull sin especificar c\u00f3mo reconciliar las ramas es poco ayuda: recomendable. Puedes eliminar este mensaje usando uno de los ayuda: siguientes comandos antes de tu siguiente pull: ayuda: ayuda: git config pull.rebase false # hacer merge (estrategia por defecto) ayuda: git config pull.rebase true # aplicar rebase ayuda: git config pull.ff only # aplicar solo fast-forward ayuda: ayuda: Puedes reemplazar \"git config\" con \"git config --global\" para aplicar ayuda: la preferencia en todos los repositorios. Puedes tambi\u00e9n pasar --rebase, ayuda: --no-rebase, o --ff-only en el comando para sobrescribir la configuraci\u00f3n ayuda: por defecto en cada invocaci\u00f3n. fatal: Necesita especificar c\u00f3mo reconciliar las ramas divergentes. Debemos especificar entonces c\u00f3mo se van a mezclar los cambios que se bajan de la rama remota con los cambios locales. Para ello elegimos la primera opci\u00f3n, que no se haga un rebase sino un merge: $ git config pull.rebase false Ahora ya funciona el git pull (har\u00e1 un merge de la rama remota con la rama local): $ git pull (aparecer\u00e1 un editor en el que tenemos que especificar el mensaje del commit de merge, grabar y salir) Y ahora ya podemos hacer push . Se subir\u00e1n nuestros cambios y el commit de merge: $ git push Comprobar el estado de las ramas locales: $ git branch -vv Con la opci\u00f3n -a ( git branch -vva ) se muestra tambi\u00e9n el estado de las ramas remote tracking de solo lectura (en rojo, y precedidas con el nombre remotes/ ): $ git branch -vva main dd867ac [origin/main] Colocados esquemas en su directorio * prueba 8d2d093 [origin/prueba] Correcci\u00f3n remotes/origin/HEAD -> origin/main remotes/origin/main dd867ac Colocados esquemas en su directorio remotes/origin/prueba 8d2d093 Correcci\u00f3n Este comando no accede directamente al servidor, sino que muestra la informaci\u00f3n de la \u00faltima vez que se accedi\u00f3 a \u00e9l. Si queremos la informaci\u00f3n actualizada podemos hacer un git fetch --all antes: $ git fetch --all $ git branch -vva Es importante recordar que git fetch (a diferencia de git pull ) no modifica los repositorios locales, sino que actualiza las ramas remote tracking . Informaci\u00f3n de los repositorios remotos: $ git remote show origin Proporciona informaci\u00f3n del repositorio remoto, todas sus ramas, del local y de la conexi\u00f3n entre ambos. $ git remote -v update Proporciona informaci\u00f3n del estado de las ramas remotas y locales (si est\u00e1n actualizadas o hay cambios en algunas no bajadas o subidas). Borrado de ramas remotas desde el terminal: $ git push origin --delete nueva-rama $ git remote prune origin Si necesitamos en la rama de feature c\u00f3digo que se haya a\u00f1adido en la rama main . Podemos hacer un merge de la rama main en la rama de feature para incorporar los avances de c\u00f3digo que se han hecho en main y que necesitamos en nuestra nueva rama: $ git checkout nueva-rama $ git merge main Soluci\u00f3n de conflictos en un pull request : Recordamos lo que hemos visto en teor\u00eda sobre la soluci\u00f3n de conflictos detectados en un pull request . Supongamos que hay un conflicto entre la nueva rama y main . GitHub detectar\u00e1 el conflicto en la p\u00e1gina de pull request . Para arreglar el conflicto: $ git checkout main $ git pull $ git checkout nueva-rama $ git merge main # arreglar el conflicto $ git push # ya se puede hacer el merge en GitHub","title":"Comandos Git"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_1","text":"A\u00f1adid el milestone 1.3.0 y etiquetad todos los pr\u00f3ximos issues con \u00e9l. Vamos a probar el nuevo flujo de trabajo descrito anteriormente creando un nuevo issue denominado Actualizar la p\u00e1gina Acerca de . En la descripci\u00f3n de issue comentad que se debe modificar la p\u00e1gina para que muestren todos los miembros del equipo y el nuevo n\u00famero de versi\u00f3n de la aplicaci\u00f3n ( 1.3.0-SNAPSHOT ). A\u00f1adid la regla de que sea necesario un revisor en los pull requests. Para ello seleccionar Settings > Branches > Add branch protection rule , poned como patr\u00f3n del nombre de rama el nombre completo main y seleccionad Require a pull request before merging y Require approvals . Poned 1 como n\u00famero de revisores requeridos. Escoged una persona del equipo como responsable del issue . El responsable del issue ser\u00e1 el responsable de integrarlo en main y de solucionar los conflictos que puedan surgir. Probad los comandos Git anteriores en una rama en la que se resuelva el issue . Cada miembro del equipo deber\u00e1 descargar esa rama y realizar un commit en el que se a\u00f1ada su nombre a la lista de autores de la aplicaci\u00f3n. Cread el pull request en GitHub, poniendo como responsable del PR al mismo responsable del issue . Provocad un conflicto y arregladlo. Para ello se debe a\u00f1adir un commit en main que entre en conflicto con los cambios realizados en la rama. Despu\u00e9s se arreglar\u00e1 el conflicto y se subir\u00e1 la soluci\u00f3n al pull request. Por \u00faltimo, revisad el c\u00f3digo, aceptadlo e integrad el PR en main .","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#4-contenedor-con-la-aplicacion-todolist","text":"Una de las cosas que vamos a hacer en esta pr\u00e1ctica (en el siguiente apartado) es poner en producci\u00f3n en uno de vuestros ordenadores la aplicaci\u00f3n ToDoList conect\u00e1ndola con la base de datos. En las pr\u00e1cticas 1 y 2 ya hemos construido el contenedor Docker de la aplicaci\u00f3n, con el siguiente fichero Dockerfile: FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"java\" , \"-Djava.security.egd=file:/dev/urandom\" , \"-jar\" , \"/app.jar\" ] Este Dockerfile tiene un problema importante. El comando de ejecuci\u00f3n es fijo y no permite definir ning\u00fan par\u00e1metro de ejecuci\u00f3n. No es posible, por ejemplo, definir el perfil de Postgres, ni definir ning\u00fan par\u00e1metro de configuraci\u00f3n. Debemos cambiarlo de la siguiente forma: FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"sh\" , \"-c\" , \"java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}\" ] De esta forma podremos llamar al comando docker a\u00f1adiendo al final par\u00e1metros que se van a pasar al comando java. La forma de a\u00f1adir variables de entorno a ese comando java es precedi\u00e9ndolos con dos guiones -- . Por ejemplo: $ docker run --rm <usuario>/mads-todolist-equipoXX --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba Vamos a probarlo, creando y subiendo la nueva imagen a DockerHub y despleg\u00e1ndola en uno de vuestros ordenadores. Este despliegue es lo que har\u00e9 yo para corregir la pr\u00e1ctica.","title":"4. Contenedor con la aplicaci\u00f3n ToDoList"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_2","text":"Deb\u00e9is hacer lo siguiente: Creamos un issue llamado Configuraci\u00f3n imagen docker y trabajamos en la rama imagen-docker . Cambiad el fichero Dockerfile de la aplicaci\u00f3n tal y como se indica en el listado anterior: Fichero Dockerfile : FROM openjdk:8-jdk-alpine COPY target/*.jar app.jar ENTRYPOINT [ \"sh\" , \"-c\" , \"java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}\" ] Modificad el fichero con el perfil postgres de ejecuci\u00f3n para incluir la opci\u00f3n de usar variables de entorno, al igual que hicimos en el perfil postgres de test. Fichero src/main/resources/application-postgres.properties : POSTGRES_HOST=localhost POSTGRES_PORT=5432 DB_USER=mads DB_PASSWD=mads spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads spring.datasource.username=${DB_USER} spring.datasource.password=${DB_PASSWD} spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect spring.sql.init.mode=never Cread la nueva imagen Docker con el nombre mads-todolist-equipoXX y la etiqueta 1.3.0-snapshot . El usuario puede ser cualquier miembro del equipo, no es necesario que sea el autor del proyecto original. $ ./mvnw package $ docker build -t <usuario-docker>/mads-todolist-equipoXX:1.3.0-snapshot . Probad que funcionan correctamente los par\u00e1metros de configuraci\u00f3n en la imagen Docker. Una forma sencilla de hacerlo es comprobar que se puede definir el perfil de Postgres y modificar alguno de sus par\u00e1metros. Deber\u00e1 aparecer un mensaje de error de que no se puede conectar con la base de datos (lo que est\u00e1 bien, porque significa que s\u00ed que se ha cargado el perfil). $ docker run --rm <usuario>/mads-todolist-equipoXX:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba Subid, por \u00faltimo, la imagen a Docker Hub y cerrad el PR y el issue. $ docker login $ docker push <usuario-docker>/mads-todolist-equipoXX:1.3.0-snapshot","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#5-despliegue-en-produccion-con-bd","text":"Vamos a ver c\u00f3mo ejecutar en producci\u00f3n el contenedor con la aplicaci\u00f3n de forma que se conecte con una base de datos postgres. En las pr\u00e1cticas 1 y 2 vimos c\u00f3mo construir una versi\u00f3n en forma de contenedor de nuestra aplicaci\u00f3n Spring Boot y en la pr\u00e1ctica 3 vimos como usar un contenedor de Postgres para definir un servicio de base de datos con el que conectar la aplicaci\u00f3n. En esta pr\u00e1ctica vamos a definir la configuraci\u00f3n en producci\u00f3n definitiva de nuestra aplicaci\u00f3n. Veremos c\u00f3mo poner en marcha dos contenedores y conectarlos entre si. En nuestro caso un contenedor tendr\u00e1 la base de datos postgres y el otro la aplicaci\u00f3n Spring Boot. La imagen anterior muestra los dos contenedores conectados por una red. Desde el contenedor con la aplicaci\u00f3n se acceder\u00e1 a la direcci\u00f3n postgres:5432 para conectarse con la base de datos. Veremos los comandos de docker para definir una red y para lanzar el contenedor de base de datos en esa direcci\u00f3n de la red. El contenedor de base de datos montar\u00e1 el directorio actual del host en el directorio /mi-host del contenedor. De esta forma, cualquier fichero que coloquemos en ese directorio del contenedor ser\u00e1 visible en el directorio actual del host (y viceversa). Usaremos este directorio para guardar datos de la base de datos, como copias de seguridad o ficheros de migraci\u00f3n. El contenedor de base de datos implementar\u00e1 la base de datos en producci\u00f3n. Base de datos de producci\u00f3n La base de datos de producci\u00f3n es la que mantiene los datos introducidos por los usuarios de la misma. Hay que prestar una atenci\u00f3n especial a esta base de datos y definir pol\u00edticas de respaldo y de control de cambios para evitar que se produzca cualquier p\u00e9rdida de informaci\u00f3n. Veremos que una de las cuestiones que hay que asegurar es que la aplicaci\u00f3n no puede modificar el esquema de datos de esta base de datos. Habr\u00e1 que definir tambi\u00e9n un flujo de trabajo para actualizar la base de datos de producci\u00f3n con los cambios del modelo de datos introducidos por la nuevas funcionalidades (nuevas tablas y nuevas relaciones).","title":"5. Despliegue en producci\u00f3n con BD"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_3","text":"Veamos paso a paso c\u00f3mo crear la configuraci\u00f3n anterior en uno de vuestros ordenadores, que usar\u00e9is como ordenador de despliegue. Creamos en nuestro ordenador de despliegue una red gestionada por Docker: $ docker network create network-equipo Lanzamos el contenedor con la base de datos usando la red creada anteriormente y con el nombre db-equipo . Definimos el nombre del host creado en el contenedor como postgres con el modificador --network-alias . $ docker run -d --network network-equipo --network-alias postgres -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 El modificador -v permite montar el directorio actual en el directorio /mi-host del contenedor. Opci\u00f3n -v de Docker en Windows Si est\u00e1is en Windows deber\u00e9is especificar el directorio actual expl\u00edcitamente, sustituyendo las barras por barras dobles: $ docker run -d --network network-equipo --network-alias postgres -v C:\\\\users\\\\domingo\\\\tmp:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 Vamos a probar que funciona correctamente. Nos conectamos al contenedor lanzando un bash interactivo. Estando en el contenedor creamos un fichero en el directorio /mi-host , salimos del contenedor y comprobamos que est\u00e1 en el directorio actual $ docker exec -it db-equipo bash root@e470db191dc6:/# cd /mi-host root@e470db191dc6:/mi-host# echo \"Hola\" > prueba.txt root@e470db191dc6:/mi-host# exit $ ls prueba.txt $ more prueba.txt Hola Con esto ya tenemos configurado y en marcha el contenedor con la base de datos Postgres. Esta va a ser nuestra base de datos de producci\u00f3n. Vamos ahora a poner en marcha la aplicaci\u00f3n. Descargamos la \u00faltima versi\u00f3n de nuestra aplicaci\u00f3n y lanzamos el contenedor usando la red definida anteriormente. Los modificadores --spring.profiles.active y --POSTGRES_HOST permiten pasar al contenedor esas variables del entorno. $ docker pull <usuario>/mads-todolist-equipoXX:1.3.0-snapshot $ docker run --rm --network network-equipo -p8080:8080 <usuario>/mads-todolist-equipoXX:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=postgres \u00a1\u00a1\u00a1Enhorabuena!!! \u00a1Ya tenemos la aplicaci\u00f3n en producci\u00f3n trabajando con la base de datos! Podremos conectarnos a la aplicaci\u00f3n usando el puerto 8080. Probamos la aplicaci\u00f3n y creamos alg\u00fan usuario de prueba. Por \u00faltimo paramos el contenedor y lo volvemos a arrancar para comprobar que los datos son persistentes. Para comprobar que la base de datos est\u00e1 funcionando correctamente podemos conectarnos al contenedor y examinar la base de datos mads y alguna de sus tablas: $ docker exec -it db-equipo bash # psql -U mads -W mads (nos pedir\u00e1 la contrase\u00f1a: mads) # \\l (lista las bases de datos) # \\dt (lista las tablas) # SELECT * FROM usuarios; La base de datos se mantendr\u00e1 mientras que no borremos el contenedor. Podemos pararlo y volver a ponerlo en marcha y seguiremos conservando los datos: $ docker stop db-equipo $ docker start db-equipo","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#6-perfil-de-produccion-y-mantenimiento-de-la-base-de-datos-de-produccion","text":"","title":"6. Perfil de producci\u00f3n y mantenimiento de la base de datos de producci\u00f3n"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#perfil-de-produccion","text":"Una vez que vamos a trabajar en producci\u00f3n con una base de datos, esta base de datos ser\u00e1 un elemento clave de la aplicaci\u00f3n. No debemos, bajo ning\u00fan concepto, perder datos que se hayan introducido en ella, ya que son datos de nuestros usuarios y clientes. Es imprescindible para ello cambiar el modo con el que la aplicaci\u00f3n construye las tablas de la base de datos. Sabemos que nuestra aplicaci\u00f3n est\u00e1 trabajando con JPA/Hibernate y que las tablas de la base de datos se construyen de forma autom\u00e1tica. Si hay alg\u00fan cambio en las entidades (se a\u00f1ade alg\u00fan atributo o alguna nueva entidad) Spring Boot actualiza las tablas de la base de datos de forma autom\u00e1tica cuando se lanza la aplicaci\u00f3n. Esto es razonable si estamos trabajando en un entorno de desarrollo, pero est\u00e1 totalmente desaconsejado en un entorno de producci\u00f3n. El par\u00e1metro spring.jpa.hibernate.ddl-auto es el que determina el funcionamiento de la actualizaci\u00f3n de las tablas de la base de datos. Su valor puede ser: CREATE : El esquema de datos se crea de nuevo cada vez que se lanza la aplicaci\u00f3n. Una vez creado, se a\u00f1aden los datos definidos en el fichero data.sql si el spring.sql.init.mode tiene como valor always . UPDATE : El esquema de datos de la base de datos se actualiza autom\u00e1ticamente cuando hay un cambio en las entidades de la aplicaci\u00f3n. As\u00ed es como tenemos configurado el perfil por defecto de nuestra aplicaci\u00f3n. Si estamos trabajando con la base de datos Postgres, se actualizar\u00e1 el esquema de datos. Pero esto no es recomendable para producci\u00f3n, porque no tenemos control de las instrucciones de actualizaci\u00f3n y pueden resultar en alguna p\u00e9rdida de datos. VALIDATE : El esquema de datos de la base de datos se valida con respecto al esquema de datos definido por las entidades JPA. Si hay alguna diferencia, salta una excepci\u00f3n. Este es el valor que hay que usar cuando lanzamos la aplicaci\u00f3n en producci\u00f3n. Vamos a definir en la aplicaci\u00f3n un nuevo perfil de ejecuci\u00f3n, llamado postgres-prod , en el que pondremos el valor del par\u00e1metro spring.jpa.hibernate.ddl-auto a VALIDATE . Y ser\u00e1 este el perfil que usaremos para lanzar la aplicaci\u00f3n en uno de vuestros ordenadores, que har\u00e1 de servidor de producci\u00f3n.","title":"Perfil de producci\u00f3n"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#mantenimiento-de-la-base-de-datos-de-produccion","text":"En una aplicaci\u00f3n en producci\u00f3n se deben configurar pol\u00edticas estrictas de realizaci\u00f3n de copias de seguridad y de integridad de los datos. Tambi\u00e9n en la gesti\u00f3n de las versiones y en la actualizaci\u00f3n del esquema de datos. Esto \u00faltimo se denomina una migraci\u00f3n de la base de datos y representa un elemento fundamental del mantenimiento en producci\u00f3n de una aplicaci\u00f3n, sobre todo cuando estamos trabajando de una forma \u00e1gil e incremental. Es un tema avanzado muy importante, pero que no podemos abordar en la asignatura por falta de tiempo. Un par de referencias que os pueden ser de utilidad son el art\u00edculo Evolutionary Database Design y herramientas como Flyway que permiten automatizar las migraciones de la base de datos. En la pr\u00e1ctica vamos a trabajar con la base de datos de producci\u00f3n de dos formas: Realizaremos una copia de seguridad antes de instalar una nueva versi\u00f3n. Actualizaremos el esquema de datos aplicando un fichero de migraci\u00f3n que construiremos manualmente.","title":"Mantenimiento de la base de datos de producci\u00f3n"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_4","text":"Creamos un issue llamado Esquema de datos y perfil de producci\u00f3n y trabajamos en la rama esquema-datos y en el pull request equivalente. $ git checkout -b esquema-datos $ git push -u origin esquema-datos Lanzamos la aplicaci\u00f3n en local con el modo postgres , trabajando sobre la base de datos. Previamente hemos lanzado el contenedor postgres montando el directorio actual en su directorio /mi-host/ : $ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 $ ./mvnw spring-boot:run -D profiles=postgres Al lanzar la aplicaci\u00f3n se habr\u00e1 creado en la base de datos el esquema de datos. Lo generamos y lo salvamos en el directorio actual: $ docker exec -it db-equipo bash # pg_dump -U mads -s mads > /mi-host/schema-1.2.0.sql # exit Comprobamos que el esquema de datos se ha creado correctamente y lo movemos al directorio sql en el directorio ra\u00edz: $ ls -l Dockerfile README.md mvnw mvnw.cmd pom.xml schema-1.2.0.sql src target $ mkdir sql $ mv schema-1.2.0.sql sql Creamos un commit con el nuevo fichero con el esquema de datos. Creamos un nuevo fichero con el perfil de producci\u00f3n, que contiene exactamente la misma configuraci\u00f3n del perfil postgres, excepto la propiedad spring.jpa.hibernate.ddl-auto que tiene el valor validate . Fichero /src/main/resources/application-postgres-prod.properties : POSTGRES_HOST=localhost POSTGRES_PORT=5432 DB_USER=mads DB_PASSWD=mads spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads spring.datasource.username=${DB_USER} spring.datasource.password=${DB_PASSWD} spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect spring.sql.init.mode=never spring.jpa.hibernate.ddl-auto=validate Probamos en local que el perfil funciona correctamente, lanz\u00e1ndolo: $ ./mvnw spring-boot:run -D profiles=postgres-prod Probamos que realmente valida el esquema de datos, en lugar de actualizarlo. Para ello, paramos y borramos el contenedor postgres y lo lanzamos de nuevo. Esto crear\u00e1 una base de datos vac\u00eda: $ docker container stop db-equipo $ docker container rm db-equipo $ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13 Si ahora lanzamos la aplicaci\u00f3n en modo postgres-prod obtendremos un error: $ ./mvnw spring-boot:run -D profiles=postgres-prod org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is javax.persistence.PersistenceException: [PersistenceUnit: default] Unable to build Hibernate SessionFactory; nested exception is org.hibernate.tool.schema.spi.SchemaManagementException: Schema-validation: missing table [equipo_usuario] 8. Actualizamos el contenedor postgres con el esquema de base de datos salvado anteriormente: $ docker exec -it db-equipo bash # psql -U mads mads < /mi-host/sql/schema-1.2.0.sql # exit Y arrancamos la aplicaci\u00f3n y comprobamos que ahora s\u00ed que funciona correctamente (la base de datos ya tiene el esquema de datos correcto). Introducimos en la aplicaci\u00f3n algunos datos de prueba y hacemos una copia de seguridad tal y como se explica anteriormente. Dejamos el fichero en el directorio sql del repositorio, indicando la fecha en el nombre del mismo. Por ejemplo sql/backup15112022.sql . Hacemos un commit, subimos los cambios y cerramos el pull request y el issue.","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#7-desarrollo-de-la-nueva-version-con-gitflow","text":"El flujo de trabajo Git que vamos a seguir es muy similar al flujo de trabajo GitFlow (recordad la clase de teor\u00eda )","title":"7. Desarrollo de la nueva versi\u00f3n con GitFlow"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#ramas-de-largo-recorrido","text":"En GitFlow se publican las distintas versiones del proyecto en la rama long-lived main y se hace el desarrollo en la rama develop . A partir de ahora no desarrollaremos directamente en main sino en develop . En la p\u00e1gina de configuraci\u00f3n del repositorio en GitHub en Settings > Branches > Default branch se puede configurar la rama por defecto contra la que se realizar\u00e1n los commits y la que aparecer\u00e1 en la p\u00e1gina del proyecto. Tendr\u00e9is que definir develop .","title":"Ramas de largo recorrido"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#ramas-de-feature","text":"Desde el comienzo de trabajo con Git en las pr\u00e1cticas 2 y 3 estamos haciendo un desarrollo basado en ramas de corto recorrido, equivalentes a las ramas de features de GitFlow. Tal y como se comenta en GitFLow estas ramas saldr\u00e1n de develop y se integrar\u00e1n en develop . La diferencia es que en GitFlow estas ramas se integran con la rama de desarrollo manualmente haciendo merge , mientras que nosotros las integramos haciendo un pull request.","title":"Ramas de feature"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_5","text":"Cread la rama develop y configurarla como rama principal del proyecto en GitHub. A\u00f1adir en los ajustes del repositorio la regla para obligar a revisar todos los PR que se mezclen en esta rama. Todos los otros miembros deber\u00e1n descargarla y moverse a ella en sus repositorios locales. Esta rama pasar\u00e1 a ser la de desarrollo principal. Cread tres issues distintos, simulando tres nuevas funcionalidades. Deben ser issues sencillos, que no cuesten demasiado de implementar (mejorar alg\u00fan defecto de la aplicaci\u00f3n, cambiar alg\u00fan elemento de alguna de las vistas, o algo similar). Uno de los cambios debe afectar a alguna entidad , por ejemplo a\u00f1adir un campo de descripci\u00f3n a los equipos y actualizar las vistas correspondientes para permitir su inicializaci\u00f3n y su actualizaci\u00f3n. Cada uno de los miembros del equipo ser\u00e1 el responsable de uno de los issues. Configurad el repositorio GitHub para obligar a que cualquier pull request tenga que tener la revisi\u00f3n de una persona distinta del responsable del PR. Desarrollad e integrar los issues en develop siguiendo el flujo de trabajo planteado anteriormente. Deb\u00e9is ir actualizando el tablero de GitHub se actualiza correctamente.","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#rama-de-release","text":"Hasta ahora hemos hecho los releases en la rama main . A partir de ahora seguiremos la estrategia de GitFlow y haremos ramas de release que salen de develop y se integran en main y en develop . Haremos tambi\u00e9n la integraci\u00f3n haciendo pull request. Una cosa importante que tendremos que hacer en el release es crear el guardar el de datos de la nueva versi\u00f3n y crear el script de migraci\u00f3n de la base de datos.","title":"Rama de release"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#pasos-a-seguir_6","text":"Vamos a probar el lanzamiento de una release usando el flujo de trabajo GitFlow. Cread un issue con la tarea Lanzar release 1.3.0 . Siguiendo las indicaciones de GitFlow, crear la rama local release-1.3.0 a partir de develop . En esta rama se deben realizar los cambios espec\u00edficos de la versi\u00f3n. En nuestro caso: Cambiar en la p\u00e1gina Acerca de \"Versi\u00f3n 1.3.0-SNAPSHOT\" a \"Versi\u00f3n 1.3.0\" y a\u00f1adir la fecha de publicaci\u00f3n. Cambiar el fichero pom.xml . Generad el esquema de datos de la base de datos postgres y guardarlo en sql/schema-1.3.0.sql . Comparar este esquema con el esquema anterior y crear el script de migraci\u00f3n con las instrucciones ALTER TABLE necesarias para actualizar la base de datos de producci\u00f3n de la versi\u00f3n 1.2.0 a la 1.3.0. Guardar el script en sql/schema-1.2.0-1.3.0.sql . Comprobad que funciona correctamente el script de migraci\u00f3n. Para ello deber\u00e9is simular que pon\u00e9is en marcha la aplicaci\u00f3n en modo producci\u00f3n trabajando con una actualizaci\u00f3n de la base de datos: Poner en marcha una base de datos de producci\u00f3n vac\u00eda. Actualizar la base de datos con la copia de seguridad guardada en el directorio sql . Actualizar la base de datos con el script de migraci\u00f3n sql/schema-1.2.0-1.3.0.sql , tal y como se explica en el apartado anterior. Lanzar el contenedor de la aplicaci\u00f3n con el perfil postgres-prod y comprobar que funciona correctamente la aplicaci\u00f3n en producci\u00f3n y que se mantienen los datos anteriores. A\u00f1adir nuevos datos y hacer una nueva copia de seguridad que se debe guardar tambi\u00e9n en el directorio src , con la fecha actual como nombre como hicimos anteriormente. Por ejemplo, src/backup-20112022.sql . Haced un commit para a\u00f1adir esta nueva copia de seguridad al repositorio. Publicad la rama release-1.3.0 en GitHub y hacer un pull request sobre main . Una vez mezclado el PR a\u00f1adir la etiqueta con la nueva versi\u00f3n 1.3.0 en main creando la p\u00e1gina de release en GitHub. Mezclar tambi\u00e9n la rama de release con develop (se puede hacer tambi\u00e9n con un PR). Subir la nueva versi\u00f3n de la imagen de docker a Docker Hub. Una vez hecho esto ya se puede borrar la rama release-1.3.0 y las ramas main y develop estar\u00e1n actualizadas a la nueva versi\u00f3n. Debemos comprobar que GitHub Actions pasa correctamente todos los tests de las nuevas caracter\u00edsticas que se a\u00f1aden.","title":"Pasos a seguir"},{"location":"04-gitflow-despliegue/gitflow-despliegue.html#9-documentacion-entrega-y-evaluacion","text":"Deber\u00e9is a\u00f1adir una p\u00e1gina de documentaci\u00f3n /doc/practica4.md en la que deber\u00e9is incluir: Breve documentaci\u00f3n t\u00e9cnica de los cambios introducidos en la aplicaci\u00f3n. Detalles del despliegue de producci\u00f3n. Esquemas de datos de las versiones 1.2.0 y de la versi\u00f3n 1.3.0. Script de migraci\u00f3n de la base de datos. URL de la imagen Docker de la aplicaci\u00f3n. Entrega: La pr\u00e1ctica tiene una duraci\u00f3n de 2 semanas y debe estar terminada el martes 22 de noviembre. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 15% en la nota final de pr\u00e1cticas. Para realizar la entrega uno de los miembros del equipo debe subir a Moodle un ZIP que contenga todo el proyecto, incluyendo el directorio .git que contiene la historia Git. Para ello comprime tu directorio local del proyecto despu\u00e9s de haber hecho un mvn clean para eliminar el directorio target que contiene los binarios compilados. Para la evaluaci\u00f3n se tendr\u00e1 en cuenta: Desarrollo continuo (los commits deben realizarse a lo largo de las semanas y no dejar todo para la \u00faltima). Correcto desarrollo de la metodolog\u00eda. Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las caracter\u00edsticas desarrolladas. Funcionamiento de la aplicaci\u00f3n con las bases de datos de producci\u00f3n y funcionamiento del script de migraci\u00f3n. Documentaci\u00f3n.","title":"9. Documentaci\u00f3n, entrega y evaluaci\u00f3n"},{"location":"05-iteracion-scrum/iteracion-scrum.html","text":"Pr\u00e1ctica 5: Sprint final \u00b6 Objetivos y resumen de la pr\u00e1ctica \u00b6 En esta pr\u00e1ctica seguiremos trabajando con los mismos equipos y proyecto que en la pr\u00e1ctica 4. Durante las 4 semanas de la pr\u00e1ctica el equipo realizar\u00e1 una iteraci\u00f3n para desarrollar un sprint completo de Scrum con el que obtener un incremento de la aplicaci\u00f3n TodoList . Usaremos el mismo flujo de trabajo de la pr\u00e1ctica 4 para desarrollar sobre la rama develop : Una tarjeta en el tablero de Trello para cada historia de usuario. Cada historia de usuario continuar\u00e1 la numeraci\u00f3n que comenzamos en la pr\u00e1ctica 3. La historia de usuario se puede descomponer en mas de un issue en GitHub o hacerla en un \u00fanico issue si es corta. En cualquier caso, se deber\u00e1n etiquetar los issues con la etiqueta asociada a la historia de usuario. Cada issue se resuelve en una rama y se integra en develop con un pull request. En el tablero en GitHub se representan el estado de los issues. El repositorio est\u00e1 conectado a GitHub Actions para hacer la integraci\u00f3n continua. Se comprueban de forma autom\u00e1tica los tests en las integraciones de los pull requests en develop . Al final de la pr\u00e1ctica se lanzar\u00e1 una nueva versi\u00f3n ( 1.4.0 ), usando el mismo flujo de trabajo que en la pr\u00e1ctica anterior, y se presentar\u00e1 la aplicaci\u00f3n resultante en una demostraci\u00f3n en clase. Nuevas funcionalidades para la aplicaci\u00f3n \u00b6 Tenemos que dise\u00f1ar, como responsables del producto ( Product Owners ), las pr\u00f3ximas funcionalidades a implementar en la aplicaci\u00f3n. Las desarrollaremos en las 4 semanas que durar\u00e1 esta pr\u00e1ctica 5. Deber\u00e9is reuniros y pensar en c\u00f3mo hacer el producto m\u00e1s interesante para los usuarios. Pensad que quer\u00e9is poner la aplicaci\u00f3n en producci\u00f3n y que est\u00e1is buscando funcionalidades que la hagan interesante para que los usuarios se suscriban a ella. Pod\u00e9is coger ideas del tablero Trello resultante de ideas de cursos pasados y tambi\u00e9n de una aplicaci\u00f3n web muy completa que hace algo similar a lo que estamos construyendo nosotros: todoist (mirad, por ejemplo, el v\u00eddeo explicando sus funcionalidades m\u00e1s importantes). Ten\u00e9is que poneros en el lugar de los usuarios y pensar en funcionalidades que les puedan ser \u00fatiles, resolver alg\u00fan problema. No es cuesti\u00f3n de a\u00f1adir funcionalidades porque s\u00ed, sino que ten\u00e9is que intentar hacer en 4 semanas un producto lo m\u00e1s coherente y \u00fatil posible. El resultado ser\u00e1 un tablero Trello con columnas denominadas Backlog (1) y Backlog (2) : en la que se encuentren las descripciones de las funcionalidades candidatas a implementarse en la siguiente pr\u00e1ctica, ordenadas de m\u00e1s interesante a menos (de arriba a abajo y de izquierda a derecha) y etiquetadas con su tama\u00f1o. La imagen de abajo es un ejemplo, con los t\u00edtulos de la mayor\u00eda de las funcionalidades borradas para no dar demasiadas ideas. El profesor podr\u00e1 pediros alguna aclaraci\u00f3n sobre las funcionalidades propuestas y la estimaci\u00f3n de tama\u00f1o de las funcionalidades. Tambi\u00e9n se valorar\u00e1 el alcance de las funcionalidades escogidas en la presentaci\u00f3n final de la pr\u00e1ctica, en donde se dar\u00e1 una puntuaci\u00f3n extra a los proyectos en base a las funcionalidades implementadas, su coherencia y usabilidad. Pasos a seguir \u00b6 Haced una reuni\u00f3n en la que revis\u00e9is el tablero Trelllo con ejemplos de funcionalidades de cursos pasados y la aplicaci\u00f3n web todoist . Deb\u00e9is seleccionar las que vais a incorporar a vuestra aplicaci\u00f3n y estimar su dificultad. S\u00f3lo podr\u00e9is definir funcionalidades de tama\u00f1o de 1 y 2 puntos. Si alguna funcionalidad es mayor, deber\u00e9is descomponerla en otras m\u00e1s peque\u00f1as. Los puntos indican un tama\u00f1o relativo. Si estim\u00e1is una historia de usuario en 2 puntos es porque pens\u00e1is que tardar\u00e9is el doble en terminarla que otra de 1 punto. Para estimar la dificultad pod\u00e9is usar planning pocker : se explica la funcionalidad y cada miembro del equipo elige un n\u00famero: 1, 2, m\u00e1s de 2. Se ense\u00f1an simult\u00e1neamente y se explican las diferencias. El hecho de que haya diferencias normalmente se debe a que existe disparidad en los detalles de la implementaci\u00f3n o del alcance de la funcionalidad. Se ponen en com\u00fan las diferencias, se llegan a acuerdos y se vuelve a hacer otra ronda de planning pocker . Se siguen haciendo rondas hasta que hay un consenso. Deb\u00e9is seleccionar historias que sumen entre 12 y 15 puntos para implementar en la pr\u00e1ctica. Para los equipos de 2 personas seleccionar entre 8 y 10 puntos. La pr\u00e1ctica tendr\u00e1 una duraci\u00f3n de 4 semanas, por lo que cada miembro del equipo deber\u00e1 implementar alrededor de 1 punto por semana. Seleccionad las historias que pens\u00e9is que hacen un producto atractivo, coherente y \u00fatil para el usuario. Ordenad las historias seg\u00fan su valor. Para estimar el valor pod\u00e9is hacer algo similar al planning pocker pero usando los n\u00fameros 1, 2 y 3 como forma de identificar la utilidad o valor de cada historia. Cread un tablero Trello y poned un enlace a \u00e9l en el README del repositorio. Cread las etiquetas 1 y 2 con distintos colores que indican el tama\u00f1o de cada funcionalidad. A\u00f1adid historias de usuario, ordenadas de mayor a menor importancia (arriba a la izquierda la m\u00e1s importante y abajo a la derecha la menos). Cada tarjeta de Trello debe contener: T\u00edtulo . Aparece en la tarjeta. Descripci\u00f3n . Muy breve, al estilo de las historias de XP. Pod\u00e9is usar el est\u00e1ndar \"Como XXX quiero XXX para XXX\", o cualquier otro estilo. Pero siempre debe quedar claro que la caracter\u00edstica debe ser una nueva funcionalidad que pueda usar o que note un usuario de la aplicaci\u00f3n. Detalles . Detalles que consider\u00e9is importantes anotar y que explican m\u00e1s el alcance de la historia. Condiciones de satisfacci\u00f3n . Condiciones que deben cumplirse para considerar que la historia est\u00e1 terminada. Son fundamentales a la hora de definir pruebas autom\u00e1ticas y manuales. Las pruebas se definen a partir de estas condiciones de satisfacci\u00f3n. El profesor podr\u00e1 pediros alguna aclaraci\u00f3n sobre las propuestas y la estimaci\u00f3n de tama\u00f1o de las funcionalidades. Artefactos del sprint \u00b6 El equipo utilizar\u00e1 un tablero Trello para documentar el backlog del producto y el tablero de GitHub para el backlog del sprint. Tablero Trello \u00b6 El tablero Trello contendr\u00e1 el backlog del producto y servir\u00e1 para trabajar con estas historias de usuario en formato de tarjeta, escribirlas r\u00e1pidamente, estimarlas y ordenarlas. Cada tarjeta Trello contendr\u00e1 lo que ya hab\u00e9is hecho anteriormente: T\u00edtulo de la historia de usuario Descripci\u00f3n Detalles Estimaci\u00f3n del tama\u00f1o de la historia (definido con una etiqueta) Utilizaremos un tablero en formato Kanban, definiendo cinco columnas que representar\u00e1n las fases por las que pasar\u00e1 cada historia de usuario: Backlog , Seleccionadas , En marcha , En prueba y Terminadas . Tipo de columna Caracter\u00edsticas de las historias Backlog Estimado el tama\u00f1o de la historia y pendiente de elaborar detalles. Seleccionadas Se est\u00e1n elaborando todos los detalles de la historia (p\u00e1gina Google Docs). En marcha Se ha abierto el primer issue en GitHub y el equipo ha comenzado a desarrollar la historia. En prueba La historia completa est\u00e1 integrada en develop . En la tarjeta se debe a\u00f1adir un enlace al commit. Terminadas Se han comprobado las condiciones de satisfacci\u00f3n de la historia. Pasos a seguir \u00b6 Durante el desarrollo del sprint, se deber\u00e1 a\u00f1adir en el tablero Trello: Responsable de la historia de usuario: miembro del equipo que liderar\u00e1 el desarrollo de la historia. Puede que m\u00e1s de una persona intervenga en el desarrollo de la historia, pero una persona ser\u00e1 la responsable. Se debe a\u00f1adir en la ficha de la historia de usuario, en forma de etiqueta. Todos los miembros del equipo deber\u00e1n realizar un trabajo equitativo, y se repartir\u00e1n las historias de forma que queden tambi\u00e9n equilibrados los tama\u00f1os totales de las historias asignadas a cada uno. Antes de comenzar el desarrollo de una historia su responsable crear\u00e1a una p\u00e1gina Google Docs de acceso p\u00fablico en la copiar\u00e1, y ampliar\u00e1 y/o modificar\u00e1 sus detalles. La descripci\u00f3n en Trello hay que dejarla tal cual, sin modificar. En la p\u00e1gina de Google Docs, el responsable de la historia de usuario deber\u00e1 incluir, cuando la seleccione , los siguientes \u00edtems: T\u00edtulo de historia de usuario Descripci\u00f3n y detalles Borrador del aspecto de la interfaz de usuario resultante. No es necesario que sea muy detallado ni que se use ninguna herramienta de mockups, se puede hacer escaneando un dibujo hecho a mano. Condiciones de satisfacci\u00f3n (COS). Estas condiciones de satisfacci\u00f3n son esenciales a la hora de determinar el alcance de la historia y de darla por acabada. Deben estar lo suficientemente claras como para poder elaborar a partir de ellas las pruebas manuales de la historia de usuario. Importante Los detalles de la historia de usuario en Google Docs se escribir\u00e1n s\u00f3lo cuando la historia haya sido seleccionada y est\u00e9 en la columna Seleccionadas . Es recomendable que el paso de una historia a seleccionada se haga cuando se haya terminado la historia anterior con la que se estaba trabajando. De esta forma, cuando escribamos los detalles de la siguiente historia seleccionada ya tendremos el proyecto m\u00e1s avanzado y podremos elaborar mejor los detalles de la nueva historia. Es posible cambiar cosas en la p\u00e1gina de Google Docs con respecto a la descripci\u00f3n de la tarjeta en Trello. Dejad la descripci\u00f3n sin modificar, para tener una referencia de la evoluci\u00f3n del dise\u00f1o del proyecto. Una vez creado el documento Google de la historia de usuario ya se puede comenzar a realizar la implementaci\u00f3n de la misma abriendo el o los issues en GitHub y a\u00f1adiendo al mismo el responsable de su desarrollo. Importante Aunque parezca evidente, lo resalto: hay que pasar las fases de forma ordenada. No podemos empezar a desarrollar una historia de usuario antes de haber terminado todos sus detalles en la p\u00e1gina de Google Docs. Se debe documentar la evoluci\u00f3n del tablero realizando 4 capturas de pantalla y registrando la fecha de cada una. Tablero GitHub \u00b6 El tablero GitHub contendr\u00e1 el backlog del sprint en el que se visualizar\u00e1n los issues con los trabajos que est\u00e1 realizando el equipo de desarrollo. En los issues podremos tener: Desarrollo de historias de usuario (en parte o completas) Bugs y refactorizaciones Desarrollos t\u00e9cnicos necesarios no relacionados con una historia de usuario en concreto Usaremos las etiquetas para definir el tipo de issue: C\u00f3digo de historia de usuario Bug Refactorizaci\u00f3n Mejora t\u00e9cnica Los primeros tipos de issue ser\u00e1n obligatorios y los tres siguientes ser\u00e1n opcionales, dependiendo de si el proyecto lo requiere. En cuanto a las columnas, definiremos el tablero como un tablero Kanban. Usaremos las mismas columnas que hasta ahora, con los issues_ movi\u00e9ndose por ellas seg\u00fan se vayan desarrollando. Tipo de columna Caracter\u00edsticas de los issues Sprint backlog Issues esperando a ser desarrollados. In progress El issue tiene asignado un responsable y se ha abierto una rama para su desarrollo. In pull request El issue tiene un pull request abierto. Done El pull request que se ha resuelto y el issue est\u00e1 integrado en develop . Al igual que el tablero de Trello, se debe documentar la evoluci\u00f3n del tablero de issues realizando 4 capturas de pantalla y registrando la fecha de cada una. Desarrollo del sprint \u00b6 Se deber\u00e1n realizar los siguientes eventos, tomando nota y redactando un informe con la fecha de la reuni\u00f3n, su duraci\u00f3n y su desarrollo: 2 sesiones de pair programming con turnos de 20 minutos (en cada sesi\u00f3n se deben hacer 4 turnos). Se podr\u00e1n hacer estas sesiones en clase de pr\u00e1cticas. Retrospectiva del sprint: an\u00e1lisis de qu\u00e9 cosas han funcionado regular y hay que mejorar y qu\u00e9 cosas han funcionado bien durante el sprint. Desarrollo de issues e historias \u00b6 Cada miembro del equipo selecciona el issue a desarrollar. Lo normal es que cada miembro desarrolle un \u00fanico issue de forma concurrente, aunque podr\u00eda darse el caso de ser m\u00e1s (por ejemplo, si alg\u00fan issue no puede terminarse por estar bloqueado por otro). Se deben crear ramas para los issues y pull requests con revisi\u00f3n de c\u00f3digo para integrar los pull requests en develop . Es suficiente con que haya una \u00fanica aprobaci\u00f3n para integrar el pull request. Seguimos usando GitHub Actions para la integraci\u00f3n continua. Como hemos hecho hasta ahora, cada issue debe contener tests autom\u00e1ticos que prueben los cambios. Una vez terminados todos los issues de una historia de usuario, el responsable de la historia mover\u00e1 su tarjeta en el tablero Trello a En prueba , se a\u00f1adir\u00e1 en la tarjeta el enlace al commit de develop en el que se ha realizado la integraci\u00f3n y otro miembro del equipo realizar\u00e1 las pruebas manuales especificadas en sus COS utilizando la base de datos Postgres . Cuando se hayan superado todas las pruebas se pasar\u00e1 la historia a Terminada . Si se detectara alg\u00fan fallo, se volver\u00e1 la historia a En marcha y se abrir\u00e1 un issue de tipo bug para resolver el problema. Publicaci\u00f3n de nueva versi\u00f3n y migraci\u00f3n de la base de datos \u00b6 Al final del desarrollo se deber\u00e1 lanzar una nueva release (1.4.0) en la rama main usando los mismos pasos que en la pr\u00e1ctica anterior. Se debe obtener el esquema de datos de la nueva versi\u00f3n y crear el script de migraci\u00f3n de la base de datos de producci\u00f3n. Como se hizo en la pr\u00e1ctica anterior, se debe hacer una copia de seguridad de algunos datos en producci\u00f3n antes de actualizar la base de datos, aplicar el script de migraci\u00f3n a la base de datos de producci\u00f3n, comprobar que la aplicaci\u00f3n funciona correctamente con las nuevas funcionalidades a\u00f1adiendo algunos nuevos datos y hacer otra copia de seguridad de los datos despu\u00e9s de probar la aplicaci\u00f3n y a\u00f1adir los nuevos datos. Como en la pr\u00e1ctica anterior, ambas copias de seguridad se deben incluir en el directorio sql del repositorio. Documentaci\u00f3n del desarrollo \u00b6 Documentar las sesiones de pair programming . Documentar la evoluci\u00f3n de los tableros Trello y GitHub capturando 4 instant\u00e1neas y registrando su fecha. Entrega y evaluaci\u00f3n \u00b6 La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas. Se realizar\u00e1 una revisi\u00f3n del sprint de 15 minutos en las clases de pr\u00e1cticas y teor\u00eda del 21 de diciembre . La revisi\u00f3n constar\u00e1 de: Presentaci\u00f3n con diapositivas en la que se explicar\u00e1 la metodolog\u00eda seguida en el sprint, las nuevas funcionalidades introducidas y la puesta en producci\u00f3n de la nueva versi\u00f3n. Demostraci\u00f3n de las nuevas funcionalidades utilizando la \u00faltima versi\u00f3n puesta en producci\u00f3n. El proyecto debe estar terminado el 21 de diciembre En la fecha de la presentaci\u00f3n debe estar completo el nuevo release 1.4.0 del proyecto y debe estar puesto en producci\u00f3n. Despu\u00e9s de la presentaci\u00f3n no podr\u00e9is a\u00f1adir m\u00e1s c\u00f3digo al proyecto. El tiempo restante hasta el 11 de enero es para que termin\u00e9is la documentaci\u00f3n. En la fecha l\u00edmite del 11 de enero deber\u00e1 entregar la pr\u00e1ctica y tener disponible: Directorio doc en el repositorio del proyecto en el que se incluir\u00e1 un documento PDF con la memoria de la pr\u00e1ctica y un PDF con las diapositivas presentadas en la demo. En la memoria de la pr\u00e1ctica se incluir\u00e1: Sprint Backlog : historias de usuario escogidas para el sprint (copiar la descripci\u00f3n, las condiciones de satisfacci\u00f3n y el borrador de interfaz de usuario tal y como aparecen en los documentos subidos a GoogleDocs). Funcionalidades implementadas : breve descripci\u00f3n para el usuario y breve descripci\u00f3n t\u00e9cnica. Puesta en producci\u00f3n : script de migraci\u00f3n de la base de datos y breve informe de la puesta en producci\u00f3n. Informe sobre la evoluci\u00f3n del desarrollo : instant\u00e1neas de los tableros y alguna m\u00e9trica o gr\u00e1fica sobre el desarrollo (n\u00famero de pull requests cada semana, por ejemplo). Informe sobre las sesiones de pair programming Resultado de la retrospectiva : qu\u00e9 ha ido bien en el sprint y qu\u00e9 se podr\u00eda mejorar en el siguiente sprint. El repositorio GitHub deber\u00e1 incluir el tablero con el backlog del sprint con los issues completados. El tablero de Trello deber\u00e1 incluir el backlog del producto con las historias de usuario que se deb\u00edan implementar en el sprint y los enlaces a los documentos Google Docs con sus detalles. Entrega en Moodle la \u00faltima versi\u00f3n del proyecto subida a GitHub. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas (1 punto en la nota final). La evaluaci\u00f3n se basar\u00e1 en: Desarrollo continuo de los issues Complejidad de las funcionalidades a\u00f1adidas Correcci\u00f3n del c\u00f3digo Correcto funcionamiento Informe de la pr\u00e1ctica Si el trabajo de alg\u00fan miembro del equipo es significativamente de menor calidad y/o cantidad que el del resto, se penalizar\u00e1 su calificaci\u00f3n A la nota anterior se le sumar\u00e1 una puntaci\u00f3n extra de hasta 0,5 puntos en la nota final que se basar\u00e1 en la demostraci\u00f3n realizada, las funcionalidades implementadas, su coherencia y usabilidad. Al final de la sesi\u00f3n de presentaciones se publicar\u00e1 esta puntuaci\u00f3n extra, que se sumar\u00e1 directamente a la nota final de la asignatura de todos los miembros de los equipos.","title":"Pr\u00e1ctica 5"},{"location":"05-iteracion-scrum/iteracion-scrum.html#practica-5-sprint-final","text":"","title":"Pr\u00e1ctica 5: Sprint final"},{"location":"05-iteracion-scrum/iteracion-scrum.html#objetivos-y-resumen-de-la-practica","text":"En esta pr\u00e1ctica seguiremos trabajando con los mismos equipos y proyecto que en la pr\u00e1ctica 4. Durante las 4 semanas de la pr\u00e1ctica el equipo realizar\u00e1 una iteraci\u00f3n para desarrollar un sprint completo de Scrum con el que obtener un incremento de la aplicaci\u00f3n TodoList . Usaremos el mismo flujo de trabajo de la pr\u00e1ctica 4 para desarrollar sobre la rama develop : Una tarjeta en el tablero de Trello para cada historia de usuario. Cada historia de usuario continuar\u00e1 la numeraci\u00f3n que comenzamos en la pr\u00e1ctica 3. La historia de usuario se puede descomponer en mas de un issue en GitHub o hacerla en un \u00fanico issue si es corta. En cualquier caso, se deber\u00e1n etiquetar los issues con la etiqueta asociada a la historia de usuario. Cada issue se resuelve en una rama y se integra en develop con un pull request. En el tablero en GitHub se representan el estado de los issues. El repositorio est\u00e1 conectado a GitHub Actions para hacer la integraci\u00f3n continua. Se comprueban de forma autom\u00e1tica los tests en las integraciones de los pull requests en develop . Al final de la pr\u00e1ctica se lanzar\u00e1 una nueva versi\u00f3n ( 1.4.0 ), usando el mismo flujo de trabajo que en la pr\u00e1ctica anterior, y se presentar\u00e1 la aplicaci\u00f3n resultante en una demostraci\u00f3n en clase.","title":"Objetivos y resumen de la pr\u00e1ctica"},{"location":"05-iteracion-scrum/iteracion-scrum.html#nuevas-funcionalidades-para-la-aplicacion","text":"Tenemos que dise\u00f1ar, como responsables del producto ( Product Owners ), las pr\u00f3ximas funcionalidades a implementar en la aplicaci\u00f3n. Las desarrollaremos en las 4 semanas que durar\u00e1 esta pr\u00e1ctica 5. Deber\u00e9is reuniros y pensar en c\u00f3mo hacer el producto m\u00e1s interesante para los usuarios. Pensad que quer\u00e9is poner la aplicaci\u00f3n en producci\u00f3n y que est\u00e1is buscando funcionalidades que la hagan interesante para que los usuarios se suscriban a ella. Pod\u00e9is coger ideas del tablero Trello resultante de ideas de cursos pasados y tambi\u00e9n de una aplicaci\u00f3n web muy completa que hace algo similar a lo que estamos construyendo nosotros: todoist (mirad, por ejemplo, el v\u00eddeo explicando sus funcionalidades m\u00e1s importantes). Ten\u00e9is que poneros en el lugar de los usuarios y pensar en funcionalidades que les puedan ser \u00fatiles, resolver alg\u00fan problema. No es cuesti\u00f3n de a\u00f1adir funcionalidades porque s\u00ed, sino que ten\u00e9is que intentar hacer en 4 semanas un producto lo m\u00e1s coherente y \u00fatil posible. El resultado ser\u00e1 un tablero Trello con columnas denominadas Backlog (1) y Backlog (2) : en la que se encuentren las descripciones de las funcionalidades candidatas a implementarse en la siguiente pr\u00e1ctica, ordenadas de m\u00e1s interesante a menos (de arriba a abajo y de izquierda a derecha) y etiquetadas con su tama\u00f1o. La imagen de abajo es un ejemplo, con los t\u00edtulos de la mayor\u00eda de las funcionalidades borradas para no dar demasiadas ideas. El profesor podr\u00e1 pediros alguna aclaraci\u00f3n sobre las funcionalidades propuestas y la estimaci\u00f3n de tama\u00f1o de las funcionalidades. Tambi\u00e9n se valorar\u00e1 el alcance de las funcionalidades escogidas en la presentaci\u00f3n final de la pr\u00e1ctica, en donde se dar\u00e1 una puntuaci\u00f3n extra a los proyectos en base a las funcionalidades implementadas, su coherencia y usabilidad.","title":"Nuevas funcionalidades para la aplicaci\u00f3n"},{"location":"05-iteracion-scrum/iteracion-scrum.html#pasos-a-seguir","text":"Haced una reuni\u00f3n en la que revis\u00e9is el tablero Trelllo con ejemplos de funcionalidades de cursos pasados y la aplicaci\u00f3n web todoist . Deb\u00e9is seleccionar las que vais a incorporar a vuestra aplicaci\u00f3n y estimar su dificultad. S\u00f3lo podr\u00e9is definir funcionalidades de tama\u00f1o de 1 y 2 puntos. Si alguna funcionalidad es mayor, deber\u00e9is descomponerla en otras m\u00e1s peque\u00f1as. Los puntos indican un tama\u00f1o relativo. Si estim\u00e1is una historia de usuario en 2 puntos es porque pens\u00e1is que tardar\u00e9is el doble en terminarla que otra de 1 punto. Para estimar la dificultad pod\u00e9is usar planning pocker : se explica la funcionalidad y cada miembro del equipo elige un n\u00famero: 1, 2, m\u00e1s de 2. Se ense\u00f1an simult\u00e1neamente y se explican las diferencias. El hecho de que haya diferencias normalmente se debe a que existe disparidad en los detalles de la implementaci\u00f3n o del alcance de la funcionalidad. Se ponen en com\u00fan las diferencias, se llegan a acuerdos y se vuelve a hacer otra ronda de planning pocker . Se siguen haciendo rondas hasta que hay un consenso. Deb\u00e9is seleccionar historias que sumen entre 12 y 15 puntos para implementar en la pr\u00e1ctica. Para los equipos de 2 personas seleccionar entre 8 y 10 puntos. La pr\u00e1ctica tendr\u00e1 una duraci\u00f3n de 4 semanas, por lo que cada miembro del equipo deber\u00e1 implementar alrededor de 1 punto por semana. Seleccionad las historias que pens\u00e9is que hacen un producto atractivo, coherente y \u00fatil para el usuario. Ordenad las historias seg\u00fan su valor. Para estimar el valor pod\u00e9is hacer algo similar al planning pocker pero usando los n\u00fameros 1, 2 y 3 como forma de identificar la utilidad o valor de cada historia. Cread un tablero Trello y poned un enlace a \u00e9l en el README del repositorio. Cread las etiquetas 1 y 2 con distintos colores que indican el tama\u00f1o de cada funcionalidad. A\u00f1adid historias de usuario, ordenadas de mayor a menor importancia (arriba a la izquierda la m\u00e1s importante y abajo a la derecha la menos). Cada tarjeta de Trello debe contener: T\u00edtulo . Aparece en la tarjeta. Descripci\u00f3n . Muy breve, al estilo de las historias de XP. Pod\u00e9is usar el est\u00e1ndar \"Como XXX quiero XXX para XXX\", o cualquier otro estilo. Pero siempre debe quedar claro que la caracter\u00edstica debe ser una nueva funcionalidad que pueda usar o que note un usuario de la aplicaci\u00f3n. Detalles . Detalles que consider\u00e9is importantes anotar y que explican m\u00e1s el alcance de la historia. Condiciones de satisfacci\u00f3n . Condiciones que deben cumplirse para considerar que la historia est\u00e1 terminada. Son fundamentales a la hora de definir pruebas autom\u00e1ticas y manuales. Las pruebas se definen a partir de estas condiciones de satisfacci\u00f3n. El profesor podr\u00e1 pediros alguna aclaraci\u00f3n sobre las propuestas y la estimaci\u00f3n de tama\u00f1o de las funcionalidades.","title":"Pasos a seguir"},{"location":"05-iteracion-scrum/iteracion-scrum.html#artefactos-del-sprint","text":"El equipo utilizar\u00e1 un tablero Trello para documentar el backlog del producto y el tablero de GitHub para el backlog del sprint.","title":"Artefactos del sprint"},{"location":"05-iteracion-scrum/iteracion-scrum.html#tablero-trello","text":"El tablero Trello contendr\u00e1 el backlog del producto y servir\u00e1 para trabajar con estas historias de usuario en formato de tarjeta, escribirlas r\u00e1pidamente, estimarlas y ordenarlas. Cada tarjeta Trello contendr\u00e1 lo que ya hab\u00e9is hecho anteriormente: T\u00edtulo de la historia de usuario Descripci\u00f3n Detalles Estimaci\u00f3n del tama\u00f1o de la historia (definido con una etiqueta) Utilizaremos un tablero en formato Kanban, definiendo cinco columnas que representar\u00e1n las fases por las que pasar\u00e1 cada historia de usuario: Backlog , Seleccionadas , En marcha , En prueba y Terminadas . Tipo de columna Caracter\u00edsticas de las historias Backlog Estimado el tama\u00f1o de la historia y pendiente de elaborar detalles. Seleccionadas Se est\u00e1n elaborando todos los detalles de la historia (p\u00e1gina Google Docs). En marcha Se ha abierto el primer issue en GitHub y el equipo ha comenzado a desarrollar la historia. En prueba La historia completa est\u00e1 integrada en develop . En la tarjeta se debe a\u00f1adir un enlace al commit. Terminadas Se han comprobado las condiciones de satisfacci\u00f3n de la historia.","title":"Tablero Trello"},{"location":"05-iteracion-scrum/iteracion-scrum.html#pasos-a-seguir_1","text":"Durante el desarrollo del sprint, se deber\u00e1 a\u00f1adir en el tablero Trello: Responsable de la historia de usuario: miembro del equipo que liderar\u00e1 el desarrollo de la historia. Puede que m\u00e1s de una persona intervenga en el desarrollo de la historia, pero una persona ser\u00e1 la responsable. Se debe a\u00f1adir en la ficha de la historia de usuario, en forma de etiqueta. Todos los miembros del equipo deber\u00e1n realizar un trabajo equitativo, y se repartir\u00e1n las historias de forma que queden tambi\u00e9n equilibrados los tama\u00f1os totales de las historias asignadas a cada uno. Antes de comenzar el desarrollo de una historia su responsable crear\u00e1a una p\u00e1gina Google Docs de acceso p\u00fablico en la copiar\u00e1, y ampliar\u00e1 y/o modificar\u00e1 sus detalles. La descripci\u00f3n en Trello hay que dejarla tal cual, sin modificar. En la p\u00e1gina de Google Docs, el responsable de la historia de usuario deber\u00e1 incluir, cuando la seleccione , los siguientes \u00edtems: T\u00edtulo de historia de usuario Descripci\u00f3n y detalles Borrador del aspecto de la interfaz de usuario resultante. No es necesario que sea muy detallado ni que se use ninguna herramienta de mockups, se puede hacer escaneando un dibujo hecho a mano. Condiciones de satisfacci\u00f3n (COS). Estas condiciones de satisfacci\u00f3n son esenciales a la hora de determinar el alcance de la historia y de darla por acabada. Deben estar lo suficientemente claras como para poder elaborar a partir de ellas las pruebas manuales de la historia de usuario. Importante Los detalles de la historia de usuario en Google Docs se escribir\u00e1n s\u00f3lo cuando la historia haya sido seleccionada y est\u00e9 en la columna Seleccionadas . Es recomendable que el paso de una historia a seleccionada se haga cuando se haya terminado la historia anterior con la que se estaba trabajando. De esta forma, cuando escribamos los detalles de la siguiente historia seleccionada ya tendremos el proyecto m\u00e1s avanzado y podremos elaborar mejor los detalles de la nueva historia. Es posible cambiar cosas en la p\u00e1gina de Google Docs con respecto a la descripci\u00f3n de la tarjeta en Trello. Dejad la descripci\u00f3n sin modificar, para tener una referencia de la evoluci\u00f3n del dise\u00f1o del proyecto. Una vez creado el documento Google de la historia de usuario ya se puede comenzar a realizar la implementaci\u00f3n de la misma abriendo el o los issues en GitHub y a\u00f1adiendo al mismo el responsable de su desarrollo. Importante Aunque parezca evidente, lo resalto: hay que pasar las fases de forma ordenada. No podemos empezar a desarrollar una historia de usuario antes de haber terminado todos sus detalles en la p\u00e1gina de Google Docs. Se debe documentar la evoluci\u00f3n del tablero realizando 4 capturas de pantalla y registrando la fecha de cada una.","title":"Pasos a seguir"},{"location":"05-iteracion-scrum/iteracion-scrum.html#tablero-github","text":"El tablero GitHub contendr\u00e1 el backlog del sprint en el que se visualizar\u00e1n los issues con los trabajos que est\u00e1 realizando el equipo de desarrollo. En los issues podremos tener: Desarrollo de historias de usuario (en parte o completas) Bugs y refactorizaciones Desarrollos t\u00e9cnicos necesarios no relacionados con una historia de usuario en concreto Usaremos las etiquetas para definir el tipo de issue: C\u00f3digo de historia de usuario Bug Refactorizaci\u00f3n Mejora t\u00e9cnica Los primeros tipos de issue ser\u00e1n obligatorios y los tres siguientes ser\u00e1n opcionales, dependiendo de si el proyecto lo requiere. En cuanto a las columnas, definiremos el tablero como un tablero Kanban. Usaremos las mismas columnas que hasta ahora, con los issues_ movi\u00e9ndose por ellas seg\u00fan se vayan desarrollando. Tipo de columna Caracter\u00edsticas de los issues Sprint backlog Issues esperando a ser desarrollados. In progress El issue tiene asignado un responsable y se ha abierto una rama para su desarrollo. In pull request El issue tiene un pull request abierto. Done El pull request que se ha resuelto y el issue est\u00e1 integrado en develop . Al igual que el tablero de Trello, se debe documentar la evoluci\u00f3n del tablero de issues realizando 4 capturas de pantalla y registrando la fecha de cada una.","title":"Tablero GitHub"},{"location":"05-iteracion-scrum/iteracion-scrum.html#desarrollo-del-sprint","text":"Se deber\u00e1n realizar los siguientes eventos, tomando nota y redactando un informe con la fecha de la reuni\u00f3n, su duraci\u00f3n y su desarrollo: 2 sesiones de pair programming con turnos de 20 minutos (en cada sesi\u00f3n se deben hacer 4 turnos). Se podr\u00e1n hacer estas sesiones en clase de pr\u00e1cticas. Retrospectiva del sprint: an\u00e1lisis de qu\u00e9 cosas han funcionado regular y hay que mejorar y qu\u00e9 cosas han funcionado bien durante el sprint.","title":"Desarrollo del sprint"},{"location":"05-iteracion-scrum/iteracion-scrum.html#desarrollo-de-issues-e-historias","text":"Cada miembro del equipo selecciona el issue a desarrollar. Lo normal es que cada miembro desarrolle un \u00fanico issue de forma concurrente, aunque podr\u00eda darse el caso de ser m\u00e1s (por ejemplo, si alg\u00fan issue no puede terminarse por estar bloqueado por otro). Se deben crear ramas para los issues y pull requests con revisi\u00f3n de c\u00f3digo para integrar los pull requests en develop . Es suficiente con que haya una \u00fanica aprobaci\u00f3n para integrar el pull request. Seguimos usando GitHub Actions para la integraci\u00f3n continua. Como hemos hecho hasta ahora, cada issue debe contener tests autom\u00e1ticos que prueben los cambios. Una vez terminados todos los issues de una historia de usuario, el responsable de la historia mover\u00e1 su tarjeta en el tablero Trello a En prueba , se a\u00f1adir\u00e1 en la tarjeta el enlace al commit de develop en el que se ha realizado la integraci\u00f3n y otro miembro del equipo realizar\u00e1 las pruebas manuales especificadas en sus COS utilizando la base de datos Postgres . Cuando se hayan superado todas las pruebas se pasar\u00e1 la historia a Terminada . Si se detectara alg\u00fan fallo, se volver\u00e1 la historia a En marcha y se abrir\u00e1 un issue de tipo bug para resolver el problema.","title":"Desarrollo de issues e historias"},{"location":"05-iteracion-scrum/iteracion-scrum.html#publicacion-de-nueva-version-y-migracion-de-la-base-de-datos","text":"Al final del desarrollo se deber\u00e1 lanzar una nueva release (1.4.0) en la rama main usando los mismos pasos que en la pr\u00e1ctica anterior. Se debe obtener el esquema de datos de la nueva versi\u00f3n y crear el script de migraci\u00f3n de la base de datos de producci\u00f3n. Como se hizo en la pr\u00e1ctica anterior, se debe hacer una copia de seguridad de algunos datos en producci\u00f3n antes de actualizar la base de datos, aplicar el script de migraci\u00f3n a la base de datos de producci\u00f3n, comprobar que la aplicaci\u00f3n funciona correctamente con las nuevas funcionalidades a\u00f1adiendo algunos nuevos datos y hacer otra copia de seguridad de los datos despu\u00e9s de probar la aplicaci\u00f3n y a\u00f1adir los nuevos datos. Como en la pr\u00e1ctica anterior, ambas copias de seguridad se deben incluir en el directorio sql del repositorio.","title":"Publicaci\u00f3n de nueva versi\u00f3n y migraci\u00f3n de la base de datos"},{"location":"05-iteracion-scrum/iteracion-scrum.html#documentacion-del-desarrollo","text":"Documentar las sesiones de pair programming . Documentar la evoluci\u00f3n de los tableros Trello y GitHub capturando 4 instant\u00e1neas y registrando su fecha.","title":"Documentaci\u00f3n del desarrollo"},{"location":"05-iteracion-scrum/iteracion-scrum.html#entrega-y-evaluacion","text":"La pr\u00e1ctica tiene una duraci\u00f3n de 4 semanas. Se realizar\u00e1 una revisi\u00f3n del sprint de 15 minutos en las clases de pr\u00e1cticas y teor\u00eda del 21 de diciembre . La revisi\u00f3n constar\u00e1 de: Presentaci\u00f3n con diapositivas en la que se explicar\u00e1 la metodolog\u00eda seguida en el sprint, las nuevas funcionalidades introducidas y la puesta en producci\u00f3n de la nueva versi\u00f3n. Demostraci\u00f3n de las nuevas funcionalidades utilizando la \u00faltima versi\u00f3n puesta en producci\u00f3n. El proyecto debe estar terminado el 21 de diciembre En la fecha de la presentaci\u00f3n debe estar completo el nuevo release 1.4.0 del proyecto y debe estar puesto en producci\u00f3n. Despu\u00e9s de la presentaci\u00f3n no podr\u00e9is a\u00f1adir m\u00e1s c\u00f3digo al proyecto. El tiempo restante hasta el 11 de enero es para que termin\u00e9is la documentaci\u00f3n. En la fecha l\u00edmite del 11 de enero deber\u00e1 entregar la pr\u00e1ctica y tener disponible: Directorio doc en el repositorio del proyecto en el que se incluir\u00e1 un documento PDF con la memoria de la pr\u00e1ctica y un PDF con las diapositivas presentadas en la demo. En la memoria de la pr\u00e1ctica se incluir\u00e1: Sprint Backlog : historias de usuario escogidas para el sprint (copiar la descripci\u00f3n, las condiciones de satisfacci\u00f3n y el borrador de interfaz de usuario tal y como aparecen en los documentos subidos a GoogleDocs). Funcionalidades implementadas : breve descripci\u00f3n para el usuario y breve descripci\u00f3n t\u00e9cnica. Puesta en producci\u00f3n : script de migraci\u00f3n de la base de datos y breve informe de la puesta en producci\u00f3n. Informe sobre la evoluci\u00f3n del desarrollo : instant\u00e1neas de los tableros y alguna m\u00e9trica o gr\u00e1fica sobre el desarrollo (n\u00famero de pull requests cada semana, por ejemplo). Informe sobre las sesiones de pair programming Resultado de la retrospectiva : qu\u00e9 ha ido bien en el sprint y qu\u00e9 se podr\u00eda mejorar en el siguiente sprint. El repositorio GitHub deber\u00e1 incluir el tablero con el backlog del sprint con los issues completados. El tablero de Trello deber\u00e1 incluir el backlog del producto con las historias de usuario que se deb\u00edan implementar en el sprint y los enlaces a los documentos Google Docs con sus detalles. Entrega en Moodle la \u00faltima versi\u00f3n del proyecto subida a GitHub. La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 25% en la nota final de pr\u00e1cticas (1 punto en la nota final). La evaluaci\u00f3n se basar\u00e1 en: Desarrollo continuo de los issues Complejidad de las funcionalidades a\u00f1adidas Correcci\u00f3n del c\u00f3digo Correcto funcionamiento Informe de la pr\u00e1ctica Si el trabajo de alg\u00fan miembro del equipo es significativamente de menor calidad y/o cantidad que el del resto, se penalizar\u00e1 su calificaci\u00f3n A la nota anterior se le sumar\u00e1 una puntaci\u00f3n extra de hasta 0,5 puntos en la nota final que se basar\u00e1 en la demostraci\u00f3n realizada, las funcionalidades implementadas, su coherencia y usabilidad. Al final de la sesi\u00f3n de presentaciones se publicar\u00e1 esta puntuaci\u00f3n extra, que se sumar\u00e1 directamente a la nota final de la asignatura de todos los miembros de los equipos.","title":"Entrega y evaluaci\u00f3n"},{"location":"06-practica-c4/practica-c4.html","text":"Pr\u00e1ctica extraordinaria para la convocatoria C4 \u00b6 Aplicaci\u00f3n a desarrollar \u00b6 Debes desarrollar una aplicaci\u00f3n similar a ToDoList. Por ejemplo, una gesti\u00f3n de recetas, una gesti\u00f3n de los libros de tu biblioteca, etc. La aplicaci\u00f3n debe tener como m\u00ednimo: Login y registro de usuarios Acceso autorizado a p\u00e1ginas de consultas y actualizaci\u00f3n Un m\u00ednimo de tres entidades, con al menos una relaci\u00f3n uno-a-muchos y una relaci\u00f3n muchos-a-muchos. Para el desarrollo de la aplicaci\u00f3n deber\u00e1s usar las mismas tecnolog\u00edas que en la pr\u00e1ctica ToDoList: SpringBoot, Thymeleaf, Hibernate. El total de puntos de historias de usuario deber\u00e1 ser similar a los realizados la pr\u00e1ctica de la convocatoria ordinaria, alrededor de 20 puntos. Historias relacionadas con la gesti\u00f3n b\u00e1sica de recetas, libros, etc. (alrededor de 8 puntos). Historias relacionadas con la gesti\u00f3n de usuarios (alrededor de 4 puntos). Historias adicionales que incluyan la relaci\u00f3n muchos-a-muchos (alrededor de 8 puntos). Repositorio en GitHub \u00b6 A diferencia de la pr\u00e1ctica 1 en la que us\u00e1bamos Github Classroom, deber\u00e1s crear tu mismo el repositorio con una aplicaci\u00f3n b\u00e1sica de Spring Boot. Puedes empezar haciendo un fork del repositorio domingogallardo/spring-boot-demoapp y a\u00f1adir las dependencias necesarias para trabajar con Hibernate y con la base de datos H2 (consultar el repositorio inicial de la pr\u00e1ctica domingogallardo/mads-todolist-inicial ). Metodolog\u00eda de desarrollo \u00b6 Deber\u00e1s usar la misma metodolog\u00eda que la usada en las pr\u00e1cticas de la convocatoria ordinaria. Consulta los apuntes de las pr\u00e1cticas. En concreto, deber\u00e1s las siguientes metodolog\u00edas desde el principio del desarrollo de la pr\u00e1ctica: Flujo de trabajo GitFlow con Pull Requests (como en la pr\u00e1ctica 3). GitHub actions y al menos 2 historias de usuario realizadas con TDD (similar a la pr\u00e1ctica 2). Historias de usuario en Trello, descripci\u00f3n extendida de cada historia de usuario en Google Docs, tablero de issues en GitHub y dividir cada historia de usuario en uno o m\u00e1s issues. El repositorio GitHub se debe compartir con el profesor de la asignatura (usuario: domingogallardo, e-mail: domingo.gallardo@ua.es). El tablero Trello debe ser p\u00fablico y debes incluir su enlace en el README del repositorio. Entrega \u00b6 La fecha de entrega es la fecha del examen oficial de la convocatoria C4 (10/07/2023) Se habilitar\u00e1 una entrega en Moodle, en la que se debe subir un documento PDF con: Explicaci\u00f3n t\u00e9cnica de la aplicaci\u00f3n (debe incluir al menos una descripci\u00f3n de las entidades y de los m\u00e9todos de servicio definidos). Explicaci\u00f3n de las funcionalidades introducidas (pueden ser las descripciones extendidas de cada historia de usuario). Enlace al tablero Trello Enlace al repositorio GitHub","title":"Pr\u00e1ctica C4"},{"location":"06-practica-c4/practica-c4.html#practica-extraordinaria-para-la-convocatoria-c4","text":"","title":"Pr\u00e1ctica extraordinaria para la convocatoria C4"},{"location":"06-practica-c4/practica-c4.html#aplicacion-a-desarrollar","text":"Debes desarrollar una aplicaci\u00f3n similar a ToDoList. Por ejemplo, una gesti\u00f3n de recetas, una gesti\u00f3n de los libros de tu biblioteca, etc. La aplicaci\u00f3n debe tener como m\u00ednimo: Login y registro de usuarios Acceso autorizado a p\u00e1ginas de consultas y actualizaci\u00f3n Un m\u00ednimo de tres entidades, con al menos una relaci\u00f3n uno-a-muchos y una relaci\u00f3n muchos-a-muchos. Para el desarrollo de la aplicaci\u00f3n deber\u00e1s usar las mismas tecnolog\u00edas que en la pr\u00e1ctica ToDoList: SpringBoot, Thymeleaf, Hibernate. El total de puntos de historias de usuario deber\u00e1 ser similar a los realizados la pr\u00e1ctica de la convocatoria ordinaria, alrededor de 20 puntos. Historias relacionadas con la gesti\u00f3n b\u00e1sica de recetas, libros, etc. (alrededor de 8 puntos). Historias relacionadas con la gesti\u00f3n de usuarios (alrededor de 4 puntos). Historias adicionales que incluyan la relaci\u00f3n muchos-a-muchos (alrededor de 8 puntos).","title":"Aplicaci\u00f3n a desarrollar"},{"location":"06-practica-c4/practica-c4.html#repositorio-en-github","text":"A diferencia de la pr\u00e1ctica 1 en la que us\u00e1bamos Github Classroom, deber\u00e1s crear tu mismo el repositorio con una aplicaci\u00f3n b\u00e1sica de Spring Boot. Puedes empezar haciendo un fork del repositorio domingogallardo/spring-boot-demoapp y a\u00f1adir las dependencias necesarias para trabajar con Hibernate y con la base de datos H2 (consultar el repositorio inicial de la pr\u00e1ctica domingogallardo/mads-todolist-inicial ).","title":"Repositorio en GitHub"},{"location":"06-practica-c4/practica-c4.html#metodologia-de-desarrollo","text":"Deber\u00e1s usar la misma metodolog\u00eda que la usada en las pr\u00e1cticas de la convocatoria ordinaria. Consulta los apuntes de las pr\u00e1cticas. En concreto, deber\u00e1s las siguientes metodolog\u00edas desde el principio del desarrollo de la pr\u00e1ctica: Flujo de trabajo GitFlow con Pull Requests (como en la pr\u00e1ctica 3). GitHub actions y al menos 2 historias de usuario realizadas con TDD (similar a la pr\u00e1ctica 2). Historias de usuario en Trello, descripci\u00f3n extendida de cada historia de usuario en Google Docs, tablero de issues en GitHub y dividir cada historia de usuario en uno o m\u00e1s issues. El repositorio GitHub se debe compartir con el profesor de la asignatura (usuario: domingogallardo, e-mail: domingo.gallardo@ua.es). El tablero Trello debe ser p\u00fablico y debes incluir su enlace en el README del repositorio.","title":"Metodolog\u00eda de desarrollo"},{"location":"06-practica-c4/practica-c4.html#entrega","text":"La fecha de entrega es la fecha del examen oficial de la convocatoria C4 (10/07/2023) Se habilitar\u00e1 una entrega en Moodle, en la que se debe subir un documento PDF con: Explicaci\u00f3n t\u00e9cnica de la aplicaci\u00f3n (debe incluir al menos una descripci\u00f3n de las entidades y de los m\u00e9todos de servicio definidos). Explicaci\u00f3n de las funcionalidades introducidas (pueden ser las descripciones extendidas de cada historia de usuario). Enlace al tablero Trello Enlace al repositorio GitHub","title":"Entrega"}]}