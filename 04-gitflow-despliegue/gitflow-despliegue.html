
<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../03-pruebas-tdd/integration-tdd.html">
      
      
        <link rel="next" href="../05-iteracion-scrum/iteracion-scrum.html">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.1.7">
    
    
      
        <title>Práctica 4 - Prácticas MADS</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.ded33207.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#practica-4-trabajo-en-equipo-con-gitflow-y-despliegue-en-produccion" class="md-skip">
          Saltar a contenido
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Cabecera">
    <a href=".." title="Prácticas MADS" class="md-header__button md-logo" aria-label="Prácticas MADS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 89 89">
  <path d="M3.136,17.387l0,42.932l42.932,21.467l-42.932,-64.399Z" />
  <path d="M21.91,8l42.933,64.398l-18.775,9.388l-42.932,-64.399l18.774,-9.387Z" style="fill-opacity: 0.5" />
  <path d="M67.535,17.387l-27.262,18.156l21.878,32.818l5.384,2.691l0,-53.665Z" />
  <path d="M67.535,17.387l0,53.666l18.774,-9.388l0,-53.665l-18.774,9.387Z" style="fill-opacity: 0.25" />
</svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Prácticas MADS
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Práctica 4
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
          
          
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Búsqueda" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Buscar">
        
        <button type="reset" class="md-search__icon md-icon" title="Limpiar" aria-label="Limpiar" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Inicializando búsqueda
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navegación" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Prácticas MADS" class="md-nav__button md-logo" aria-label="Prácticas MADS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 89 89">
  <path d="M3.136,17.387l0,42.932l42.932,21.467l-42.932,-64.399Z" />
  <path d="M21.91,8l42.933,64.398l-18.775,9.388l-42.932,-64.399l18.774,-9.387Z" style="fill-opacity: 0.5" />
  <path d="M67.535,17.387l-27.262,18.156l21.878,32.818l5.384,2.691l0,-53.665Z" />
  <path d="M67.535,17.387l0,53.666l18.774,-9.388l0,-53.665l-18.774,9.387Z" style="fill-opacity: 0.25" />
</svg>

    </a>
    Prácticas MADS
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" >
      
      
      
        <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
          Práctica 1
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          Práctica 1
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../01-intro-spring-boot/practica1.html" class="md-nav__link">
        Enunciado de la práctica
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../01-intro-spring-boot/intro-spring-boot.html" class="md-nav__link">
        Introducción a Spring Boot
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../01-intro-spring-boot/comandos-git.html" class="md-nav__link">
        Resumen de comandos Git
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../02-todolist/practica2.html" class="md-nav__link">
        Práctica 2
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../03-pruebas-tdd/integration-tdd.html" class="md-nav__link">
        Práctica 3
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Práctica 4
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="gitflow-despliegue.html" class="md-nav__link md-nav__link--active">
        Práctica 4
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-objetivos-y-resumen-de-la-practica" class="md-nav__link">
    1. Objetivos y resumen de la práctica
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-formacion-de-equipos" class="md-nav__link">
    2. Formación de equipos
  </a>
  
    <nav class="md-nav" aria-label="2. Formación de equipos">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-nuevo-flujo-de-trabajo-para-los-issues" class="md-nav__link">
    3. Nuevo flujo de trabajo para los issues
  </a>
  
    <nav class="md-nav" aria-label="3. Nuevo flujo de trabajo para los issues">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#comandos-git" class="md-nav__link">
    Comandos Git
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_1" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-contenedor-con-la-aplicacion-todolist" class="md-nav__link">
    4. Contenedor con la aplicación ToDoList
  </a>
  
    <nav class="md-nav" aria-label="4. Contenedor con la aplicación ToDoList">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_2" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-despliegue-en-produccion-con-bd" class="md-nav__link">
    5. Despliegue en producción con BD
  </a>
  
    <nav class="md-nav" aria-label="5. Despliegue en producción con BD">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_3" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-perfil-de-produccion-y-mantenimiento-de-la-base-de-datos-de-produccion" class="md-nav__link">
    6. Perfil de producción y mantenimiento de la base de datos de producción
  </a>
  
    <nav class="md-nav" aria-label="6. Perfil de producción y mantenimiento de la base de datos de producción">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#perfil-de-produccion" class="md-nav__link">
    Perfil de producción
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mantenimiento-de-la-base-de-datos-de-produccion" class="md-nav__link">
    Mantenimiento de la base de datos de producción
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_4" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-desarrollo-de-la-nueva-version-con-gitflow" class="md-nav__link">
    7. Desarrollo de la nueva versión con GitFlow
  </a>
  
    <nav class="md-nav" aria-label="7. Desarrollo de la nueva versión con GitFlow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ramas-de-largo-recorrido" class="md-nav__link">
    Ramas de largo recorrido
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ramas-de-feature" class="md-nav__link">
    Ramas de feature
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_5" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rama-de-release" class="md-nav__link">
    Rama de release
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_6" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9-documentacion-entrega-y-evaluacion" class="md-nav__link">
    9. Documentación, entrega y evaluación
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../05-iteracion-scrum/iteracion-scrum.html" class="md-nav__link">
        Práctica 5
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../06-practica-c4/practica-c4.html" class="md-nav__link">
        Práctica C4
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-objetivos-y-resumen-de-la-practica" class="md-nav__link">
    1. Objetivos y resumen de la práctica
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-formacion-de-equipos" class="md-nav__link">
    2. Formación de equipos
  </a>
  
    <nav class="md-nav" aria-label="2. Formación de equipos">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-nuevo-flujo-de-trabajo-para-los-issues" class="md-nav__link">
    3. Nuevo flujo de trabajo para los issues
  </a>
  
    <nav class="md-nav" aria-label="3. Nuevo flujo de trabajo para los issues">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#comandos-git" class="md-nav__link">
    Comandos Git
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_1" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-contenedor-con-la-aplicacion-todolist" class="md-nav__link">
    4. Contenedor con la aplicación ToDoList
  </a>
  
    <nav class="md-nav" aria-label="4. Contenedor con la aplicación ToDoList">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_2" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-despliegue-en-produccion-con-bd" class="md-nav__link">
    5. Despliegue en producción con BD
  </a>
  
    <nav class="md-nav" aria-label="5. Despliegue en producción con BD">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_3" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-perfil-de-produccion-y-mantenimiento-de-la-base-de-datos-de-produccion" class="md-nav__link">
    6. Perfil de producción y mantenimiento de la base de datos de producción
  </a>
  
    <nav class="md-nav" aria-label="6. Perfil de producción y mantenimiento de la base de datos de producción">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#perfil-de-produccion" class="md-nav__link">
    Perfil de producción
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mantenimiento-de-la-base-de-datos-de-produccion" class="md-nav__link">
    Mantenimiento de la base de datos de producción
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_4" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-desarrollo-de-la-nueva-version-con-gitflow" class="md-nav__link">
    7. Desarrollo de la nueva versión con GitFlow
  </a>
  
    <nav class="md-nav" aria-label="7. Desarrollo de la nueva versión con GitFlow">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ramas-de-largo-recorrido" class="md-nav__link">
    Ramas de largo recorrido
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ramas-de-feature" class="md-nav__link">
    Ramas de feature
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_5" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rama-de-release" class="md-nav__link">
    Rama de release
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pasos-a-seguir_6" class="md-nav__link">
    Pasos a seguir
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9-documentacion-entrega-y-evaluacion" class="md-nav__link">
    9. Documentación, entrega y evaluación
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="practica-4-trabajo-en-equipo-con-gitflow-y-despliegue-en-produccion">Práctica 4: Trabajo en equipo con GitFlow y despliegue en producción<a class="headerlink" href="#practica-4-trabajo-en-equipo-con-gitflow-y-despliegue-en-produccion" title="Permanent link">&para;</a></h1>
<h2 id="1-objetivos-y-resumen-de-la-practica">1. Objetivos y resumen de la práctica<a class="headerlink" href="#1-objetivos-y-resumen-de-la-practica" title="Permanent link">&para;</a></h2>
<p>En esta práctica se pretende conseguir:</p>
<ol>
<li>Crear los equipos de trabajo en GitHub.</li>
<li>Adaptar el flujo de trabajo en Git y GitHub al trabajo en equipo.</li>
<li>Desplegar la aplicación usando una base de datos de producción y
   mantener esta base de datos.</li>
<li>Implementar GitFlow:<ul>
<li>Desarrollar nuevas features con GitFlow.</li>
<li>Lanzamiento de una versión nueva usando GitFlow.</li>
</ul>
</li>
</ol>
<h2 id="2-formacion-de-equipos">2. Formación de equipos<a class="headerlink" href="#2-formacion-de-equipos" title="Permanent link">&para;</a></h2>
<p>En esta práctica comenzamos a trabajar en equipos de 3 personas.</p>
<p>Cada equipo trabajará con un repositorio común seleccionado de uno de
los miembros del equipo. Utilizaremos <em>GitHub Classroom</em> para crear el
<em>team</em> y el repositorio.</p>
<h3 id="pasos-a-seguir">Pasos a seguir<a class="headerlink" href="#pasos-a-seguir" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>Debéis formar equipos de <strong>3 personas</strong>. </p>
<p>De forma excepcional, será posible crear equipos de 2 ó 4 personas. En esta
práctica y en la siguiente se deberá adaptar la cantidad de trabajo y
funcionalidades implementadas en función del número de personas del equipo.</p>
<p>Enviad los componentes al foro de Moodle y os asignaré un nombre de
equipo. Utilizad después el enlace de GitHub Classroom que enviaré al foro
de Moodle para crear el equipo y apuntaros a él.</p>
<p>El primero que use el enlace debe crear el repositorio,
escribiendo el nombre del equipo, como se muestra en la siguiente
imagen.</p>
<p><img src="imagenes/nombre-repo-github-classroom.png" width="600px"/></p>
<p>El equipo trabajará con un repositorio creado por GitHub Classroom
con el nombre <code>todolist--NOMBRE-EQUIPO</code>. Al igual que en
la práctica 2, el repositorio se creará en la organización <code>mads-ua-22-23</code>.</p>
<p><img src="imagenes/repo-creado-github-classroom.png" width="700px"/></p>
<p>Una vez que la primera persona ha creado el equipo y el
repositorio, las siguientes personas que usan el enlace pueden
unirse al equipo creado o crear un nuevo equipo:</p>
<p><img src="imagenes/unirse-repo-github-classroom.png" width="700px"/></p>
</li>
<li>
<p>Una vez creado el repositorio debéis crear en él un tablero para
  gestionar las tarjetas con los <em>issues</em> y los pull
  requests. Creadlos con las mismas columnas que en las prácticas 2 y 3.</p>
</li>
<li>
<p>Escoged el proyecto que vais a usar como punto de partida de estas
  dos últimas prácticas de entre los proyectos de los miembros del
  equipo. Intentad que se un proyecto con código limpio y fácilmente
  ampliable.</p>
<p>Subidlo al nuevo repositorio, cambiando la URL del <code>origin</code> del
repositorio local y haciendo un push:</p>
<p><div class="highlight"><pre><span></span><code>$ git remote set-url origin https://github.com/mads-ua-22-23/todolist-NOMBRE-EQUIPO.git
$ git push -u origin main
</code></pre></div>
Por último, los otros miembros del equipo deberán clonar el
repositorio para que los tres podáis trabajar con él en local.</p>
</li>
<li>
<p>Cambiad el nombre del proyecto (en el fichero <code>POM.xml</code> y en el
  <code>about.html</code> a <code>todolist-equipo-XX</code>.</p>
<p>Haced un commit directamente en <code>main</code> con estos
cambios. Comprobad que GitHub Actions sigue funcionando
correctamente. </p>
</li>
</ul>
<h2 id="3-nuevo-flujo-de-trabajo-para-los-issues">3. Nuevo flujo de trabajo para los <em>issues</em><a class="headerlink" href="#3-nuevo-flujo-de-trabajo-para-los-issues" title="Permanent link">&para;</a></h2>
<p>Debemos adaptar el flujo de trabajo en GitHub al trabajo en equipo. En
cuanto a la gestión de los <em>issues</em> y tablero del proyecto cambiaremos
lo siguiente:</p>
<ul>
<li><strong>Selección del <em>issue</em></strong>: Al pasar un <em>issue</em> de <code>To do</code>a <code>In
  progress</code> se debe <strong>asignar un responsable</strong> del desarrollo del <em>issue</em>.</li>
<li><strong>Nueva rama con el <em>issue</em></strong>: El responsable seleccionado será el que abra una
  rama nueva para el desarrollo del ticket y la subirá a
  GitHub.</li>
<li><strong>Desarrollo</strong>: Se trabaja en la rama. Cualquier compañero puede
  unirse al ticket y trabajar junto con el responsable, trabajando
  sobre la rama.</li>
<li><strong>Pull request</strong>: Cuando el ticket se ha terminado, el responsable
  abre un pull request en GitHub y pone la tarjeta en la columna
  <code>In pull request</code>.</li>
<li>
<p><strong>Revisión de código</strong>: Debéis configurar la opción de GitHub que obliga a que
  haya un <a href="https://docs.github.com/en/free-pro-team@latest/github/administering-a-repository/enabling-required-reviews-for-pull-requests">mínimo de 1 revisor</a> en el pull request.</p>
<p>Los miembros del equipo revisan el código en el pull request (consultar documentación en GitHub: <a href="https://help.github.com/articles/reviewing-proposed-changes-in-a-pull-request/">Reviewing
  proposed changes in a pull  request</a>). Al
  menos uno de los miembros del equipo debe <strong>dar el visto bueno al PR</strong>, añadiendo una reacción. </p>
</li>
<li>
<p><strong>Integración del pull request</strong>: Cuando un miembro da el OK, el
  responsable de la tarea integra el pull request.</p>
</li>
</ul>
<p>Para implementar el trabajo en equipo será necesario trabajar sobre
ramas remotas compartidas. A continuación explicamos con más detalle
algunos aspectos comandos de Git necesarios.</p>
<h3 id="comandos-git">Comandos Git<a class="headerlink" href="#comandos-git" title="Permanent link">&para;</a></h3>
<p>Veamos algunos comandos de Git relacionados con el trabajo compartido
en repositorios y ramas remotas.</p>
<ul>
<li>
<p>Subir una rama al repositorio remoto (el responsable del issue):</p>
<div class="highlight"><pre><span></span><code>$ git checkout -b nueva-rama
$ git push -u origin nueva-rama
</code></pre></div>
</li>
<li>
<p>Descargar por primera vez una rama del repositorio remoto y moverse
  a ella (el resto de miembros del equipo):</p>
<div class="highlight"><pre><span></span><code>$ (main) git pull
   * [nueva rama] nueva-rama -&gt; origin/nueva-rama
$ (main) git branch -r (comprobamos las ramas remotas asegurarnos)
$ (main) git checkout nueva-rama 
  rama &#39;nueva-rama&#39; configurada para rastrear &#39;origin/nueva-rama&#39;.
  Cambiado a nueva rama &#39;nueva-rama&#39;
$ (nueva-rama)
</code></pre></div>
</li>
<li>
<p>Subir cambios de la rama remota:</p>
<div class="highlight"><pre><span></span><code>$ (nueva-rama) git add .
$ (nueva-rama) git commit -m &quot;Mis cambios&quot;
$ (nueva-rama) git push
</code></pre></div>
<p>Si algún compañero ha subido cambios a la rama remota que tenemos
pendientes de descargar, al hacer un <code>git push</code> tendremos un
error en el que nos indica que debemos hacer antes un <code>git pull</code>:</p>
<div class="highlight"><pre><span></span><code>% (nueva-rama) git push
To https://github.com/domingogallardo/prueba-clase.git
! [rejected]        nueva-rama -&gt; nueva-rama (fetch first)
error: falló el push de algunas referencias a &#39;https://github.com/domingogallardo/prueba-clase.git&#39;
ayuda: Actualizaciones fueron rechazadas porque el remoto contiene trabajo que
ayuda: no existe localmente. Esto es causado usualmente por otro repositorio
ayuda: realizando push a la misma ref. Quizás quieras integrar primero los cambios
ayuda: remotos (ej. &#39;git pull ...&#39;) antes de volver a hacer push.
</code></pre></div>
<p>Puede ser que al hacer <code>git pull</code> nos aparezca el siguiente mensaje de error:</p>
<div class="highlight"><pre><span></span><code>% (nueva-rama) git pull
ayuda: Hacer un pull sin especificar cómo reconciliar las ramas es poco
ayuda: recomendable. Puedes eliminar este mensaje usando uno de los
ayuda: siguientes comandos antes de tu siguiente pull:
ayuda: 
ayuda:   git config pull.rebase false  # hacer merge (estrategia por defecto)
ayuda:   git config pull.rebase true   # aplicar rebase
ayuda:   git config pull.ff only       # aplicar solo fast-forward
ayuda: 
ayuda: Puedes reemplazar &quot;git config&quot; con &quot;git config --global&quot; para aplicar
ayuda: la preferencia en todos los repositorios. Puedes también pasar --rebase,
ayuda: --no-rebase, o --ff-only en el comando para sobrescribir la configuración
ayuda: por defecto en cada invocación.
fatal: Necesita especificar cómo reconciliar las ramas divergentes.
</code></pre></div>
<p>Debemos especificar entonces cómo se van a mezclar los cambios que se bajan
de la rama remota con los cambios locales. Para ello elegimos la
primera opción, que no se haga un rebase sino un merge:</p>
<div class="highlight"><pre><span></span><code>$ (nueva-rama) git config pull.rebase false
</code></pre></div>
<p>Ahora ya funciona el <code>git pull</code> (hará un merge de la rama remota
con la rama local):</p>
<div class="highlight"><pre><span></span><code>$ (nueva-rama) git pull
(aparecerá un editor en el que tenemos que especificar el mensaje
del commit de merge, grabar y salir)
</code></pre></div>
<p>Y ahora ya podemos hacer <code>push</code>. Se subirán nuestros cambios y el
commit de merge:</p>
<div class="highlight"><pre><span></span><code>$ (nueva-rama) git push
</code></pre></div>
</li>
<li>
<p>Comprobar el estado de las ramas locales:</p>
<div class="highlight"><pre><span></span><code>$ git branch -vv
</code></pre></div>
<p>Con la opción <code>-a</code> (<code>git branch -vva</code>) se muestra también el
estado de las ramas <em>remote tracking</em> de solo lectura (en rojo, y
precedidas con el nombre <code>remotes/</code>):</p>
<div class="highlight"><pre><span></span><code>$  git branch -vva
  main                  dd867ac [origin/main] Colocados esquemas en su directorio
* prueba                8d2d093 [origin/prueba] Corrección
  remotes/origin/HEAD   -&gt; origin/main
  remotes/origin/main   dd867ac Colocados esquemas en su directorio
  remotes/origin/prueba 8d2d093 Corrección
</code></pre></div>
<p>Este comando no accede directamente al servidor, sino que muestra
la información de la última vez que se accedió a él. Si queremos
la información actualizada podemos hacer un <code>git fetch --all</code>
antes:</p>
<div class="highlight"><pre><span></span><code>$ git fetch --all
$ git branch -vva
</code></pre></div>
<p>Es importante recordar que <code>git fetch</code> (a diferencia de <code>git
pull</code>) no modifica los repositorios locales, sino que actualiza
las ramas <em>remote tracking</em>.</p>
</li>
<li>
<p>Comprobar cambios remotos: podemos comprobar si algún compañero ha subido
  algún commit a alguna rama, y comprobar esos cambios antes de hacer un <code>merge</code>:</p>
<div class="highlight"><pre><span></span><code>$ (main) git fetch --all
   * Los cambios se descargan a las ramas locales origin/nueva-rama
$ (main) git diff nueva-rama origin/nueva-rama
$ (main) git checkout nueva-rama
$ (nueva-rama) git merge origin/nueva-rama
</code></pre></div>
</li>
<li>
<p>Solución de conflictos en un <em>merge</em>:</p>
<p>Supongamos que hay un conflicto al mezclar los cambios remotos del compañero
en la nueva rama (haciendo <code>git pull</code> o <code>git merge</code>). Git detectará el
conflicto, modificará los ficheros en conflicto y deberemos editarlos para
quedarnos con los cambios deseados:</p>
<div class="highlight"><pre><span></span><code>$ (nueva-rama) git pull (o git merge origin/nueva-rama)
  CONFLICTO (contenido): Conflicto de fusión en README.md
  Fusión automática falló; arregle los conflictos y luego realice un commit con el resultado.
$ git status
  Tienes rutas no fusionadas.
  (arregla los conflictos y ejecuta &quot;git commit&quot;
  (usa &quot;git merge --abort&quot; para abortar la fusion)

  Rutas no fusionadas:
     (usa &quot;git add &lt;archivo&gt;...&quot; para marcar una resolución)
     modificados por ambos:  README.md
# Editamos los ficheros en conflicto y nos quedamos con los cambios deseados
$ git add .
$ git commit -m &quot;Arreglado conflicto&quot;
$ git push
</code></pre></div>
<p>Y el resto de compañeros deberán hacer un <code>git pull</code> para actualizar sus
ramas locales.</p>
</li>
<li>
<p>Información de los repositorios remotos:</p>
<div class="highlight"><pre><span></span><code>$ git remote show origin
</code></pre></div>
<p>Proporciona información del repositorio remoto, todas sus ramas,
del local y de la conexión entre ambos.</p>
<div class="highlight"><pre><span></span><code>$ git remote -v update
</code></pre></div>
<p>Proporciona información del estado de las ramas remotas y locales
(si están actualizadas o hay cambios en algunas no bajadas o
subidas).</p>
</li>
<li>
<p>Borrado de ramas remotas desde el terminal:</p>
<div class="highlight"><pre><span></span><code>$ git push origin --delete nueva-rama
$ git remote prune origin
</code></pre></div>
</li>
<li>
<p>Si necesitamos en la rama de <em>feature</em> código que se haya añadido en
  la rama <code>main</code>.</p>
<p>Podemos hacer un <em>merge</em> de la rama <code>main</code> en la rama de
<em>feature</em> para incorporar los avances de código que se han hecho
en <code>main</code> y que necesitamos en nuestra nueva rama:</p>
<div class="highlight"><pre><span></span><code>$ git checkout nueva-rama
$ git merge main
</code></pre></div>
</li>
<li>
<p>Solución de conflictos en un <em>pull request</em>:</p>
<p>Supongamos que en un <em>pull request</em> GitHub detecta un conflicto entre la
nueva rama y la rama <code>main</code>. En lugar de resolver el conflicto en GitHub es
recomendable hacerlo en el repositorio local:</p>
<div class="highlight"><pre><span></span><code>$ git checkout main
$ git pull
$ git checkout nueva-rama
$ git merge main
# arreglar el conflicto
$ git push
# ya se puede hacer el merge en GitHub
</code></pre></div>
</li>
</ul>
<h3 id="pasos-a-seguir_1">Pasos a seguir<a class="headerlink" href="#pasos-a-seguir_1" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>Añadid el milestone 1.3.0 y etiquetad todos los próximos issues con
  él. Vamos a probar el nuevo flujo de trabajo descrito anteriormente creando
  un nuevo <em>issue</em> denominado <code>Actualizar la página Acerca de</code>. En la
  descripción de <em>issue</em> comentad que se debe modificar la página para
  que muestren todos los miembros del equipo y el nuevo número de
  versión de la aplicación (<code>1.3.0-SNAPSHOT</code>).</p>
</li>
<li>
<p>Añadid la regla de que sea necesario un revisor en los pull
   requests. Para ello seleccionar <em>Settings &gt; Branches &gt; Add branch
   protection rule</em>, poned como patrón del nombre de rama el nombre
   completo <code>main</code> y seleccionad <em>Require a pull request before
   merging</em> y <em>Require approvals</em>. Poned 1 como número de revisores
   requeridos.</p>
</li>
<li>
<p>Escoged una persona del equipo como responsable del <em>issue</em>. El
  responsable del <em>issue</em> será el responsable de integrarlo en
  <code>main</code> y de solucionar los conflictos que puedan surgir.</p>
</li>
<li>
<p>Probad los comandos Git anteriores en una rama en la que se
  resuelva el <em>issue</em>. Cada miembro del equipo deberá descargar esa
  rama y realizar un commit en el que se añada su nombre a la lista de
  autores de la aplicación.</p>
</li>
<li>
<p>Cread un conflicto entre commits de dos miembros del equipo. Cambiar los dos
   la misma línea del fichero, haced commit (llamadlo "Provocando un conflicto")
   e intentad subir los commits a la rama. El último que lo haga no podrá,
   tendrá que hacer un <code>pull</code> y se generará un conflicto. Resolved el conflicto
   y subir el fichero corregido.</p>
</li>
<li>
<p>Cread el pull request en GitHub, poniendo como responsable del PR al
  mismo responsable del <em>issue</em>.</p>
</li>
<li>
<p>Provocad otro conflicto y arregladlo. Para ello se debe añadir un
  commit en <code>main</code> que entre en conflicto con los cambios realizados
  en la rama. Podéis añadir el commit editando directamente el fichero en
  GitHub. Arreglad el conflicto tal y como se explica en el apartado anterior.</p>
</li>
<li>
<p>Por último, revisad el código, aceptadlo e integrad el PR en
   <em>main</em>.</p>
</li>
</ol>
<h2 id="4-contenedor-con-la-aplicacion-todolist">4. Contenedor con la aplicación ToDoList<a class="headerlink" href="#4-contenedor-con-la-aplicacion-todolist" title="Permanent link">&para;</a></h2>
<p>Una de las cosas que vamos a hacer en esta práctica (en el siguiente
apartado) es poner en producción en uno de vuestros ordenadores la
aplicación ToDoList conectándola con la base de datos. En las
prácticas 1 y 2 ya hemos construido el contenedor Docker de la
aplicación, con el siguiente fichero Dockerfile:</p>
<div class="highlight"><pre><span></span><code><span class="k">FROM</span><span class="w"> </span><span class="s">openjdk:8-jdk-alpine</span>
<span class="k">COPY</span><span class="w"> </span>target/*.jar<span class="w"> </span>app.jar
<span class="k">ENTRYPOINT</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;java&quot;</span><span class="p">,</span><span class="s2">&quot;-Djava.security.egd=file:/dev/urandom&quot;</span><span class="p">,</span><span class="s2">&quot;-jar&quot;</span><span class="p">,</span><span class="s2">&quot;/app.jar&quot;</span><span class="p">]</span>
</code></pre></div>
<p>Este Dockerfile tiene un problema importante. El comando de ejecución
es fijo y no permite definir ningún parámetro de ejecución. No es
posible, por ejemplo, definir el perfil de Postgres, ni definir
ningún parámetro de configuración.</p>
<p>Debemos cambiarlo de la siguiente forma:</p>
<div class="highlight"><pre><span></span><code><span class="k">FROM</span><span class="w"> </span><span class="s">openjdk:8-jdk-alpine</span>
<span class="k">COPY</span><span class="w"> </span>target/*.jar<span class="w"> </span>app.jar
<span class="hll"><span class="k">ENTRYPOINT</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;sh&quot;</span><span class="p">,</span><span class="s2">&quot;-c&quot;</span><span class="p">,</span><span class="s2">&quot;java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}&quot;</span><span class="p">]</span>
</span></code></pre></div>
<p>De esta forma podremos llamar al comando docker añadiendo al final
parámetros que se van a pasar al comando java. La forma de añadir
variables de entorno a ese comando java es precediéndolos con dos
guiones <code>--</code>. Por ejemplo:</p>
<div class="highlight"><pre><span></span><code>$ docker run --rm &lt;usuario&gt;/mads-todolist-equipoXX --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba 
</code></pre></div>
<p>Vamos a probarlo, creando y subiendo la nueva imagen a
DockerHub y desplegándola en uno de vuestros ordenadores. Este
despliegue es lo que haré yo para corregir la práctica.</p>
<h3 id="pasos-a-seguir_2">Pasos a seguir<a class="headerlink" href="#pasos-a-seguir_2" title="Permanent link">&para;</a></h3>
<p>Debéis hacer lo siguiente:</p>
<ol>
<li>
<p>Creamos un issue llamado <code>Configuración imagen docker</code> y
   trabajamos en la rama <code>imagen-docker</code>.</p>
</li>
<li>
<p>Cambiad el fichero Dockerfile de la aplicación tal y como se indica en el listado
   anterior:</p>
<div class="highlight"><span class="filename">./Dockerfile</span><pre><span></span><code><span class="k">FROM</span><span class="w"> </span><span class="s">openjdk:8-jdk-alpine</span>
<span class="k">COPY</span><span class="w"> </span>target/*.jar<span class="w"> </span>app.jar
<span class="k">ENTRYPOINT</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;sh&quot;</span><span class="p">,</span><span class="s2">&quot;-c&quot;</span><span class="p">,</span><span class="s2">&quot;java -Djava.security.egd=file:/dev/urandom -jar /app.jar ${0} ${@}&quot;</span><span class="p">]</span>
</code></pre></div>
</li>
<li>
<p>Modificad el fichero en el directorio <code>main</code> con el perfil <code>postgres</code> para
   incluir la opción de usar variables de entorno, al igual que
   hicimos en el perfil <code>postgres</code> de test.</p>
<div class="highlight"><span class="filename">src/main/resources/application-postgres.properties</span><pre><span></span><code>POSTGRES_HOST=localhost
POSTGRES_PORT=5432
DB_USER=mads
DB_PASSWD=mads
spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWD}
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect
</code></pre></div>
</li>
<li>
<p>Cread la nueva imagen Docker con el nombre
   <code>mads-todolist-equipoXX</code> y la etiqueta <code>1.3.0-snapshot</code>. El usuario puede ser cualquier miembro
   del equipo, no es necesario que sea el autor del proyecto original.</p>
<div class="highlight"><pre><span></span><code>$ ./mvnw package
$ docker build -t &lt;usuario-docker&gt;/mads-todolist-equipoXX:1.3.0-snapshot . 
</code></pre></div>
</li>
<li>
<p>Probad que funcionan correctamente los parámetros de configuración
   en la imagen Docker. Una forma sencilla de hacerlo es comprobar que
   se puede definir el perfil de Postgres y modificar alguno de sus
   parámetros. Deberá aparecer un mensaje de error de que no se puede
   conectar con la base de datos (lo que está bien, porque significa
   que sí que se ha cargado el perfil).</p>
<div class="highlight"><pre><span></span><code>$ docker run --rm &lt;usuario&gt;/mads-todolist-equipoXX:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=host-prueba 
</code></pre></div>
<p><img src="imagenes/perfil-contenedor.png" width="700px" />
<img src="imagenes/error-contenedor.png" width="700px" /></p>
</li>
<li>
<p>Subid, por último, la imagen a Docker Hub y cerrad el PR y el issue.</p>
<div class="highlight"><pre><span></span><code>$ docker login
$ docker push &lt;usuario-docker&gt;/mads-todolist-equipoXX:1.3.0-snapshot
</code></pre></div>
</li>
</ol>
<h2 id="5-despliegue-en-produccion-con-bd">5. Despliegue en producción con BD<a class="headerlink" href="#5-despliegue-en-produccion-con-bd" title="Permanent link">&para;</a></h2>
<p>Vamos a ver cómo ejecutar en producción el contenedor con la
aplicación de forma que se conecte con una base de datos postgres.</p>
<p>En las prácticas 1 y 2 vimos cómo construir una versión en forma de
contenedor de nuestra aplicación Spring Boot y en la práctica 3 vimos
como usar un contenedor de Postgres para definir un servicio de base
de datos con el que conectar la aplicación.</p>
<p>En esta práctica vamos a definir la configuración en producción
definitiva de nuestra aplicación. Veremos cómo poner en marcha dos
contenedores y conectarlos entre si. En nuestro caso un contenedor
tendrá la base de datos postgres y el otro la aplicación Spring Boot.</p>
<p><img src="imagenes/contenedores-produccion.png" width="600px"/></p>
<p>La imagen anterior muestra los dos contenedores conectados por una
red. Desde el contenedor con la aplicación se accederá a la dirección
<code>postgres:5432</code> para conectarse con la base de datos. Veremos los
comandos de docker para definir una red y para lanzar el contenedor de
base de datos en esa dirección de la red.</p>
<p>El contenedor de base de datos montará el directorio actual del host en el
directorio <code>/mi-host</code> del contenedor. De esta forma este directorio será
compartido y cualquier fichero que coloquemos en ese directorio del contenedor
será visible en el directorio actual del host (y viceversa). Usaremos este
directorio para guardar datos de la base de datos, como copias de seguridad o
ficheros de migración.</p>
<p>El contenedor de base de datos implementará la base de datos en
producción. </p>
<div class="admonition note">
<p class="admonition-title">Base de datos de producción</p>
<p>La base de datos de producción es la que mantiene los datos
introducidos por los usuarios de la misma. Hay que prestar una
atención especial a esta base de datos y definir políticas de
respaldo y de control de cambios para evitar que se produzca
cualquier pérdida de información. Veremos que una
de las cuestiones que hay que asegurar es que la aplicación no
puede modificar el esquema de datos de esta base de datos. </p>
<p>Habrá que definir también un flujo de trabajo para actualizar la base de
datos de producción con los cambios del modelo de datos
introducidos por la nuevas funcionalidades (nuevas tablas y nuevas
relaciones).</p>
</div>
<h3 id="pasos-a-seguir_3">Pasos a seguir<a class="headerlink" href="#pasos-a-seguir_3" title="Permanent link">&para;</a></h3>
<p>Veamos paso a paso cómo crear la configuración anterior en uno de
vuestros ordenadores, que usaréis como ordenador de despliegue.</p>
<ol>
<li>
<p>Creamos en nuestro ordenador de despliegue una red gestionada por
   Docker: </p>
<div class="highlight"><pre><span></span><code>$ docker network create network-equipo
</code></pre></div>
</li>
<li>
<p>Lanzamos el contenedor con la base de datos usando la red creada
  anteriormente y con el nombre <code>db-equipo</code>. Definimos el nombre del
  host creado en el contenedor como <code>postgres</code> con el modificador
  <code>--network-alias</code>.</p>
<div class="highlight"><pre><span></span><code>$ docker run -d --network network-equipo --network-alias postgres -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13
</code></pre></div>
<p>El modificador <code>-v</code> permite montar el directorio actual en el
directorio <code>/mi-host</code> del contenedor. </p>
<div class="admonition note">
<p class="admonition-title">Opción -v de Docker en Windows</p>
<p>Si estáis en Windows deberéis especificar el directorio actual explícitamente, sustituyendo las barras por barras dobles:
<div class="highlight"><pre><span></span><code>$ docker run -d --network network-equipo --network-alias postgres -v C:\\users\\domingo\\tmp:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13
</code></pre></div></p>
</div>
<p>Vamos a probar que funciona  correctamente. </p>
</li>
<li>
<p>Nos conectamos al contenedor lanzando un <code>bash</code>
   interactivo. Estando en el contenedor creamos un fichero en el
   directorio <code>/mi-host</code>, salimos del contenedor y comprobamos que
   está en el directorio actual</p>
<div class="highlight"><pre><span></span><code>$ docker exec -it db-equipo bash
root@e470db191dc6:/# cd /mi-host
root@e470db191dc6:/mi-host# echo &quot;Hola&quot; &gt; prueba.txt
root@e470db191dc6:/mi-host# exit
$ ls
prueba.txt
$ more prueba.txt
Hola
</code></pre></div>
</li>
<li>
<p>Con esto ya tenemos configurado y en marcha el contenedor con la
   base de datos Postgres. Esta va a ser nuestra base de datos de
   producción. Vamos ahora a poner en marcha la aplicación.</p>
<p>Descargamos la última versión de nuestra aplicación y lanzamos el
contenedor usando la red definida anteriormente. Los modificadores
<code>--spring.profiles.active</code> y <code>--POSTGRES_HOST</code> permiten pasar al
contenedor esas variables del entorno.</p>
<div class="highlight"><pre><span></span><code>$ docker pull &lt;usuario&gt;/mads-todolist-equipoXX:1.3.0-snapshot
$ docker run --rm --network network-equipo -p8080:8080 &lt;usuario&gt;/mads-todolist-equipoXX:1.3.0-snapshot --spring.profiles.active=postgres --POSTGRES_HOST=postgres
</code></pre></div>
<p>¡¡¡Enhorabuena!!! ¡Ya tenemos la aplicación en producción
trabajando con la base de datos!</p>
<p>Podremos conectarnos a la aplicación usando el puerto 8080.</p>
<p>Probamos la aplicación y creamos algún usuario de prueba. Por último
paramos el contenedor y lo volvemos a arrancar para comprobar que los
datos son persistentes.</p>
</li>
<li>
<p>Para comprobar que la base de datos está funcionando correctamente
   podemos conectarnos al contenedor y examinar la base de datos
   <code>mads</code> y alguna de sus tablas:</p>
<div class="highlight"><pre><span></span><code>$ docker exec -it db-equipo bash
# psql -U mads -W mads (nos pedirá la contraseña: mads)
# \l (lista las bases de datos)
# \dt (lista las tablas)
# SELECT * FROM usuarios;
</code></pre></div>
<p>La base de datos se mantendrá mientras que no borremos el
contenedor. Podemos pararlo y volver a ponerlo en marcha y seguiremos
conservando los datos:</p>
<div class="highlight"><pre><span></span><code>$ docker stop db-equipo
$ docker start db-equipo
</code></pre></div>
</li>
</ol>
<h2 id="6-perfil-de-produccion-y-mantenimiento-de-la-base-de-datos-de-produccion">6. Perfil de producción y mantenimiento de la base de datos de producción<a class="headerlink" href="#6-perfil-de-produccion-y-mantenimiento-de-la-base-de-datos-de-produccion" title="Permanent link">&para;</a></h2>
<h3 id="perfil-de-produccion">Perfil de producción<a class="headerlink" href="#perfil-de-produccion" title="Permanent link">&para;</a></h3>
<p>Una vez que vamos a trabajar en producción con una base de datos, esta
base de datos será un elemento clave de la aplicación. No debemos
bajo ningún concepto perder datos que se hayan introducido en ella,
ya que son datos de nuestros usuarios y clientes.</p>
<p>Es imprescindible para ello cambiar el modo con el que la aplicación
construye las tablas de la base de datos. Sabemos que nuestra
aplicación está trabajando con JPA/Hibernate y que las tablas de la
base de datos se construyen de forma automática. Si hay algún cambio
en las entidades (se añade algún atributo o alguna nueva entidad)
Spring Boot actualiza las tablas de la base de datos de forma
automática cuando se lanza la aplicación. Esto es razonable si estamos
trabajando en un entorno de desarrollo, pero está <strong>totalmente
desaconsejado</strong> en un entorno de producción.</p>
<p>El parámetro <code>spring.jpa.hibernate.ddl-auto</code> es el que determina el
funcionamiento de la actualización de las tablas de la base de
datos. Su valor puede ser:</p>
<ul>
<li>
<p><code>CREATE</code>: El esquema de datos se crea de nuevo cada vez que se lanza
  la aplicación. Una vez creado, se añaden los datos definidos en el
  fichero <code>data.sql</code> si el
  <code>spring.sql.init.mode</code> tiene como valor <code>always</code>.</p>
</li>
<li>
<p><code>UPDATE</code>: El esquema de datos de la base de datos se actualiza
  automáticamente cuando hay un cambio en las entidades de la
  aplicación. Así es como tenemos configurado el perfil por defecto de
  nuestra aplicación. Si estamos trabajando con la base de datos
  Postgres, se actualizará el esquema de datos. Pero esto no es
  recomendable para producción, porque no tenemos control de las
  instrucciones de actualización y pueden resultar en alguna pérdida
  de datos.</p>
</li>
<li>
<p><code>VALIDATE</code>: El esquema de datos de la base de datos se valida con
  respecto al esquema de datos definido por las entidades JPA. Si hay
  alguna diferencia, salta una excepción. Este es el valor que hay que
  usar cuando lanzamos la aplicación en producción.</p>
</li>
</ul>
<p>Vamos a definir en la aplicación un nuevo perfil de ejecución, llamado
<code>postgres-prod</code>, en el que pondremos el valor del parámetro
<code>spring.jpa.hibernate.ddl-auto</code> a <code>VALIDATE</code>. Y será este el perfil
que usaremos para lanzar la aplicación en uno de vuestros ordenadores,
que hará de servidor de producción.</p>
<h3 id="mantenimiento-de-la-base-de-datos-de-produccion">Mantenimiento de la base de datos de producción<a class="headerlink" href="#mantenimiento-de-la-base-de-datos-de-produccion" title="Permanent link">&para;</a></h3>
<p>En una aplicación en producción se deben configurar políticas
estrictas de realización de copias de seguridad y de integridad de los
datos. También en la gestión de las versiones y en la actualización
del esquema de datos. </p>
<p>Esto último se denomina una <em>migración</em> de la base de datos y
representa un elemento fundamental del mantenimiento en producción de
una aplicación, sobre todo cuando estamos trabajando de una forma ágil
e incremental. Es un tema avanzado muy importante, pero que no podemos
abordar en la asignatura por falta de tiempo. Un par de referencias
que os pueden ser de utilidad son el artículo <a href="https://martinfowler.com/articles/evodb.html">Evolutionary Database
Design</a> y herramientas
como
<a href="https://www.baeldung.com/database-migrations-with-flyway">Flyway</a> que
permiten automatizar las migraciones de la base de datos.</p>
<p>En la práctica vamos a trabajar con la base de datos de producción de
dos formas:</p>
<ol>
<li>Realizaremos una copia de seguridad antes de instalar una nueva
   versión.</li>
<li>Actualizaremos el esquema de datos aplicando un fichero de
   migración que construiremos manualmente.</li>
</ol>
<h4 id="copias-de-seguridad">Copias de seguridad<a class="headerlink" href="#copias-de-seguridad" title="Permanent link">&para;</a></h4>
<p>Si eliminamos el contenedor con la base de datos se perderán todos los
datos. Para evitar perder los datos, con el contenedor en marcha
podemos hacer una copia de seguridad de la base de datos <code>mads</code> en el
directorio compartido:</p>
<div class="highlight"><pre><span></span><code>$ docker exec -it db-equipo bash
# pg_dump -U mads --clean mads &gt; /mi-host/backup03092021.sql
</code></pre></div>
<p>La copia de seguridad se guarda en el directorio compartido. Podemos
poner la fecha en el nombre del fichero. Por ejemplo, la copia
anterior ha sido creada el 3 de septiembre del 2021.</p>
<p>Para restaurar una copia de seguridad basta con ejecutar el fichero
SQL en la base de datos:</p>
<div class="highlight"><pre><span></span><code>$ docker exec -it db-equipo bash
# psql -U mads mads &lt; /mi-host/backup03092021.sql
# exit
</code></pre></div>
<h4 id="migracion-de-la-base-de-datos">Migración de la base de datos<a class="headerlink" href="#migracion-de-la-base-de-datos" title="Permanent link">&para;</a></h4>
<p>Podemos obtener el esquema de datos de la aplicación (la definición de
las tablas, sin los datos) conectándonos al contenedor y ejecutando el
siguiente comando para guardar el fichero en el directorio compartido:</p>
<div class="highlight"><pre><span></span><code>$ docker exec -it db-equipo bash
# pg_dump -U mads -s mads &gt; /mi-host/schema.sql
# exit
</code></pre></div>
<p>Tendremos el esquema de datos en el directorio actual, que hemos
montado en el contenedor con la instrucción -V.</p>
<p>Los esquemas son instrucciones SQL en texto plano. Supongamos que
tenemos una nueva versión de la aplicación (<code>1.3.0</code>) en la que hemos
añadido el atributo <code>descripcion</code> a la entidad <code>Equipo</code>.</p>
<p>Si generamos el esquema de datos de esta nueva versión y lo llamamos
<code>schema-1.3.0.sql</code> lo podemos comparar con el esquema anterior usando
el comando de linux <code>diff</code>:</p>
<div class="highlight"><pre><span></span><code>% diff sql/schema-1.3.0.sql sql/schema-1.2.0.sql 
41,42c41
&lt;     nombre character varying(255),
&lt;     descripcion character varying(255)
---
&gt;     nombre character varying(255)
</code></pre></div>
<p>Por ejemplo, en el ejemplo mostrado, el fichero <code>schema-1.3.0.sql</code> tiene un
campo adicional que el fichero <code>schema-1.2.0.sql</code>. Se trata del
campo <code>descripcion</code>. En la versión anterior (<code>schema-1.2.0.sql</code>) la
tabla <code>equipo</code> se define como:</p>
<div class="highlight"><pre><span></span><code><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">public</span><span class="p">.</span><span class="n">equipos</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">bigint</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">nombre</span><span class="w"> </span><span class="nb">character</span><span class="w"> </span><span class="nb">varying</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>
<p>Mientras que en la versión nueva (<code>schema-1.3.0.sql</code>) se define como:</p>
<div class="highlight"><pre><span></span><code><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">public</span><span class="p">.</span><span class="n">equipos</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">bigint</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">nombre</span><span class="w"> </span><span class="nb">character</span><span class="w"> </span><span class="nb">varying</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
<span class="w">    </span><span class="n">descripcion</span><span class="w"> </span><span class="nb">character</span><span class="w"> </span><span class="nb">varying</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>
<p>Si queremos migrar la base de datos de producción de una versión a
otra, debemos crear un script de migración en el que modifiquemos
únicamente el esquema de datos anterior para adaptarlo al nuevo.</p>
<p>En este caso el script lo llamaremos <code>schema-1.2.0-1.3.0.sql</code> y
contendrá únicamente la siguiente instrucción:</p>
<div class="highlight"><pre><span></span><code><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">public</span><span class="p">.</span><span class="n">equipos</span>
<span class="k">ADD</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="n">descripcion</span><span class="w"> </span><span class="nb">character</span><span class="w"> </span><span class="nb">varying</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
</code></pre></div>
<p>Para actualizar la base de datos de producción sólo tenemos que
ejecutar el script anterior:</p>
<div class="highlight"><pre><span></span><code>$ docker exec -it db-equipo bash
$ psql -U mads mads &lt; /mi-host/schema-1.2.0-1.3.0.sql
ALTER TABLE
$ exit
</code></pre></div>
<p>De esta forma habremos añadido manualmente un campo en la tabla
<code>equipos</code>.</p>
<p>La aplicación deberá funcionar ahora perfectamente si la lanzamos en
modo producción, definiendo la variable que hemos mencionado antes con
el modo <code>validate</code>:</p>
<div class="highlight"><pre><span></span><code>spring.jpa.hibernate.ddl-auto=validate
</code></pre></div>
<h3 id="pasos-a-seguir_4">Pasos a seguir<a class="headerlink" href="#pasos-a-seguir_4" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>Creamos un issue llamado <code>Esquema de datos y perfil de producción</code> y trabajamos
   en la rama <code>esquema-datos</code> y en el pull request equivalente.</p>
<div class="highlight"><pre><span></span><code>$ git checkout -b esquema-datos
$ git push -u origin esquema-datos
</code></pre></div>
</li>
<li>
<p>Lanzamos la aplicación en local con el modo <code>postgres</code>, trabajando
   sobre la base de datos. Previamente hemos lanzado el contenedor postgres
   montando el directorio actual en su directorio <code>/mi-host/</code>:</p>
<div class="highlight"><pre><span></span><code>$ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13
$ ./mvnw spring-boot:run -D profiles=postgres
</code></pre></div>
</li>
<li>
<p>Al lanzar la aplicación se habrá creado en la base de datos el
   esquema de datos. Lo generamos y lo salvamos en el directorio
   actual:</p>
<div class="highlight"><pre><span></span><code>$ docker exec -it db-equipo bash
# pg_dump -U mads -s mads &gt; /mi-host/schema-1.2.0.sql
# exit
</code></pre></div>
</li>
<li>
<p>Comprobamos que el esquema de datos se ha creado correctamente y lo
   movemos al directorio <code>sql</code> en el directorio raíz:</p>
<div class="highlight"><pre><span></span><code>$ ls -l
Dockerfile
README.md
mvnw
mvnw.cmd
pom.xml
schema-1.2.0.sql
src
target
$ mkdir sql
$ mv schema-1.2.0.sql sql
</code></pre></div>
</li>
<li>
<p>Creamos un commit con el nuevo fichero con el esquema de datos.</p>
</li>
<li>
<p>Creamos un nuevo fichero con el perfil de producción, que contiene
    exactamente la misma configuración del perfil postgres, excepto la
    propiedad <code>spring.jpa.hibernate.ddl-auto</code> que tiene el valor
    <code>validate</code>.</p>
<p><strong>Fichero ``</strong>:</p>
<div class="highlight"><span class="filename">/src/main/resources/application-postgres-prod.properties</span><pre><span></span><code>POSTGRES_HOST=localhost
POSTGRES_PORT=5432
DB_USER=mads
DB_PASSWD=mads
spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/mads
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWD}
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL9Dialect
spring.jpa.hibernate.ddl-auto=validate
</code></pre></div>
</li>
<li>
<p>Probamos en local que el perfil funciona correctamente, lanzándolo:</p>
<div class="highlight"><pre><span></span><code>$ ./mvnw spring-boot:run -D profiles=postgres-prod
</code></pre></div>
<p>Probamos que realmente valida el esquema de datos, en lugar de
actualizarlo. Para ello, paramos y borramos el contenedor postgres
y lo lanzamos de nuevo. Esto creará una base de datos vacía:</p>
<div class="highlight"><pre><span></span><code>$ docker container stop db-equipo
$ docker container rm db-equipo
$ docker run -d -p 5432:5432 -v ${PWD}:/mi-host --name db-equipo -e POSTGRES_USER=mads -e POSTGRES_PASSWORD=mads -e POSTGRES_DB=mads postgres:13
</code></pre></div>
<p>Si ahora lanzamos la aplicación en modo <code>postgres-prod</code>
obtendremos un error:</p>
<p><div class="highlight"><pre><span></span><code>$ ./mvnw spring-boot:run -D profiles=postgres-prod
org.springframework.beans.factory.BeanCreationException: Error
creating bean with name &#39;entityManagerFactory&#39; defined in class
path resource  [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: 
Invocation of init method failed; nested exception is
javax.persistence.PersistenceException: [PersistenceUnit: default]
Unable to build Hibernate SessionFactory; nested exception is 
org.hibernate.tool.schema.spi.SchemaManagementException: 
Schema-validation: missing table [equipo_usuario]
</code></pre></div>
8. Actualizamos el contenedor postgres con el esquema de base de datos
   salvado anteriormente:</p>
<div class="highlight"><pre><span></span><code>$ docker exec -it db-equipo bash
# psql -U mads mads &lt; /mi-host/sql/schema-1.2.0.sql
# exit
</code></pre></div>
<p>Y arrancamos la aplicación y comprobamos que ahora sí que funciona
correctamente (la base de datos ya tiene el esquema de datos correcto).</p>
</li>
<li>
<p>Introducimos en la aplicación algunos datos de prueba y hacemos
    una copia de seguridad tal y como se explica
    anteriormente. Dejamos el fichero en el directorio <code>sql</code> del
    repositorio, indicando la fecha en el nombre del mismo. Por
    ejemplo <code>sql/backup15112022.sql</code>.</p>
</li>
<li>
<p>Hacemos un commit, subimos los cambios y cerramos el pull request y
   el issue.</p>
</li>
</ol>
<h2 id="7-desarrollo-de-la-nueva-version-con-gitflow">7. Desarrollo de la nueva versión con GitFlow<a class="headerlink" href="#7-desarrollo-de-la-nueva-version-con-gitflow" title="Permanent link">&para;</a></h2>
<p>El flujo de trabajo Git que vamos a seguir es muy similar al flujo de
trabajo GitFlow (recordad la <a href="https://github.com/domingogallardo/apuntes-mads/blob/main/apuntes/08-git-workflows/git-workflow.md#gitflow">clase de
teoría</a>)</p>
<h3 id="ramas-de-largo-recorrido">Ramas de largo recorrido<a class="headerlink" href="#ramas-de-largo-recorrido" title="Permanent link">&para;</a></h3>
<p>En GitFlow se publican las distintas versiones del proyecto en la rama
<em>long-lived</em> <code>main</code> y se hace el desarrollo en la rama
<code>develop</code>. A partir de ahora no desarrollaremos directamente en
<code>main</code> sino en <code>develop</code>.</p>
<p>En la página de configuración del repositorio en GitHub en <code>Settings &gt;
Branches &gt; Default branch</code> se puede configurar la rama por defecto
contra la que se realizarán los commits y la que aparecerá en la
página del proyecto. Tendréis que definir <code>develop</code>.</p>
<h3 id="ramas-de-feature">Ramas de feature<a class="headerlink" href="#ramas-de-feature" title="Permanent link">&para;</a></h3>
<p>Desde el comienzo de trabajo con Git en las prácticas 2 y 3 estamos
haciendo un desarrollo basado en ramas de corto recorrido,
equivalentes a las ramas de <em>features</em> de GitFlow. </p>
<p>Tal y como se comenta en GitFLow estas ramas saldrán de <code>develop</code> y se
integrarán en <code>develop</code>. La diferencia es que en GitFlow estas ramas
se integran con la rama de desarrollo manualmente haciendo <code>merge</code>,
mientras que nosotros las integramos haciendo un pull request.</p>
<h3 id="pasos-a-seguir_5">Pasos a seguir<a class="headerlink" href="#pasos-a-seguir_5" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>Cread la rama <strong><code>develop</code></strong> y configurarla como rama principal del
  proyecto en GitHub. Añadir en los ajustes del repositorio la regla
  para obligar a revisar todos los PR que se mezclen en esta rama. Todos
  los otros miembros deberán descargarla y moverse a ella en sus
  repositorios locales. Esta rama pasará a ser la de desarrollo
  principal.</p>
</li>
<li>
<p>Cread tres <em>issues</em> distintos, simulando tres nuevas
  funcionalidades. Deben ser issues sencillos, que no cuesten
  demasiado de implementar (mejorar algún defecto de la aplicación,
  cambiar algún elemento de alguna de las vistas, o algo
  similar). <strong>Uno de los cambios debe afectar a alguna entidad</strong>, por
  ejemplo añadir un campo de descripción a los equipos y actualizar
  las vistas correspondientes para permitir su inicialización y su
  actualización.</p>
<p>Cada uno de los miembros del equipo será el responsable de
uno de los issues.</p>
</li>
<li>
<p>Configurad el repositorio GitHub para obligar a que cualquier <em>pull
  request</em> tenga que tener la revisión de una persona distinta del
  responsable del PR.</p>
</li>
<li>
<p>Desarrollad e integrar los issues en <code>develop</code> siguiendo el flujo de
  trabajo planteado anteriormente. Debéis ir actualizando el tablero
  de GitHub se actualiza correctamente.</p>
</li>
</ol>
<h3 id="rama-de-release">Rama de release<a class="headerlink" href="#rama-de-release" title="Permanent link">&para;</a></h3>
<p>Hasta ahora hemos hecho los <em>releases</em> en la rama <code>main</code>. A partir
de ahora seguiremos la estrategia de GitFlow y haremos ramas de
<em>release</em> que salen de <code>develop</code> y se integran en <code>main</code> y en
<code>develop</code>.</p>
<p>Haremos también la integración haciendo pull request.</p>
<p>Una cosa importante que tendremos que hacer en el release es crear el
guardar el de datos de la nueva versión y crear el script de migración
de la base de datos.</p>
<h3 id="pasos-a-seguir_6">Pasos a seguir<a class="headerlink" href="#pasos-a-seguir_6" title="Permanent link">&para;</a></h3>
<p>Vamos a probar el lanzamiento de una release usando el flujo de
trabajo GitFlow.</p>
<ol>
<li>
<p>Cread un <em>issue</em> con la tarea <em>Lanzar release 1.3.0</em>.</p>
</li>
<li>
<p>Siguiendo las indicaciones de GitFlow, crear la rama local
   <code>release-1.3.0</code> a partir de <code>develop</code>.</p>
</li>
<li>
<p>En esta rama se deben realizar los cambios específicos de la
   versión. En nuestro caso:</p>
<ul>
<li>Cambiar en la página <code>Acerca de</code> "Versión 1.3.0-SNAPSHOT" a
      "Versión 1.3.0" y añadir la fecha de publicación.</li>
<li>Cambiar el fichero <code>pom.xml</code>.</li>
<li>Generad el <strong>esquema de datos</strong> de la base de datos postgres
  y guardarlo en <code>sql/schema-1.3.0.sql</code>. </li>
<li>Comparar este esquema con el esquema anterior y crear el script
  de migración con las instrucciones <code>ALTER TABLE</code> necesarias para
  actualizar la base de datos de producción de la versión 1.2.0 a
  la 1.3.0. Guardar el script en <code>sql/schema-1.2.0-1.3.0.sql</code>.</li>
</ul>
</li>
<li>
<p>Comprobad que funciona correctamente el script de migración. Para
   ello deberéis simular que ponéis en marcha la aplicación en modo
   producción trabajando con una actualización de la base de datos:</p>
<ul>
<li>Poner en marcha una base de datos de producción vacía.</li>
<li>Actualizar la base de datos con la copia de seguridad guardada en
  el directorio <code>sql</code>.</li>
<li>Actualizar la base de datos con el script de migración
  <code>sql/schema-1.2.0-1.3.0.sql</code>, tal y como se explica en el apartado
  anterior. </li>
<li>Lanzar el contenedor de la aplicación con el perfil
  <code>postgres-prod</code> y comprobar que funciona correctamente la
  aplicación en producción y que se mantienen los datos
  anteriores.</li>
<li>Añadir nuevos datos y hacer una nueva copia de seguridad que se
  debe guardar también en el directorio <code>src</code>, con la fecha actual
  como nombre como hicimos anteriormente. Por ejemplo,
  <code>src/backup-20112022.sql</code>.</li>
<li>Haced un commit para añadir esta nueva copia de seguridad al
  repositorio. </li>
</ul>
</li>
<li>
<p>Publicad la rama <code>release-1.3.0</code> en GitHub y hacer un pull
   request sobre <code>main</code>. Una vez mezclado el PR añadir la
   etiqueta con la nueva versión <code>1.3.0</code> en <code>main</code> creando la
   página de release en GitHub.</p>
</li>
<li>
<p>Mezclar también la rama de release con <code>develop</code> (se puede hacer
    también con un PR).</p>
</li>
<li>
<p>Subir la nueva versión de la imagen de docker a Docker Hub.</p>
</li>
<li>
<p>Una vez hecho esto ya se puede borrar la rama <code>release-1.3.0</code> y las
  ramas <code>main</code> y <code>develop</code> estarán actualizadas a la nueva
  versión.</p>
</li>
<li>
<p>Debemos comprobar que GitHub Actions pasa correctamente todos los
   tests de las nuevas características que se añaden.</p>
</li>
</ol>
<h2 id="9-documentacion-entrega-y-evaluacion">9. Documentación, entrega y evaluación<a class="headerlink" href="#9-documentacion-entrega-y-evaluacion" title="Permanent link">&para;</a></h2>
<p>Deberéis añadir una página de documentación <code>/doc/practica4.md</code> en la
que deberéis incluir:</p>
<ul>
<li>Breve documentación técnica de los cambios introducidos en la
  aplicación.</li>
<li>Detalles del despliegue de producción. Esquemas de datos de las
  versiones 1.2.0 y de la versión 1.3.0. Script de migración de la
  base de datos.</li>
<li>URL de la imagen Docker de la aplicación.</li>
</ul>
<p>Entrega:</p>
<ul>
<li>La práctica tiene una duración de 2 semanas y debe estar terminada
  el martes 28 de noviembre.</li>
<li>La calificación de la práctica tiene un peso de un 15% en la nota
  final de prácticas.</li>
<li>Para realizar la entrega <strong>uno de los miembros del equipo</strong> debe subir a
  Moodle un ZIP que contenga todo el proyecto, incluyendo el
  directorio <code>.git</code> que contiene la historia Git. Para ello comprime
  tu directorio local del proyecto después de haber hecho un <code>mvn
  clean</code> para eliminar el directorio <code>target</code> que contiene los
  binarios compilados.</li>
</ul>
<p>Para la evaluación se tendrá en cuenta:</p>
<ul>
<li>Desarrollo continuo (los <em>commits</em> deben realizarse a lo largo de
  las semanas y no dejar todo para la última).</li>
<li>Correcto desarrollo de la metodología.</li>
<li>Diseño e implementación del código y de los tests de las
  características desarrolladas.</li>
<li>Funcionamiento de la aplicación con las bases de datos de producción
  y funcionamiento del script de migración.</li>
<li>Documentación.</li>
</ul>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copiado al portapapeles", "clipboard.copy": "Copiar al portapapeles", "search.result.more.one": "1 m\u00e1s en esta p\u00e1gina", "search.result.more.other": "# m\u00e1s en esta p\u00e1gina", "search.result.none": "No se encontraron documentos", "search.result.one": "1 documento encontrado", "search.result.other": "# documentos encontrados", "search.result.placeholder": "Teclee para comenzar b\u00fasqueda", "search.result.term.missing": "Falta", "select.version": "Seleccionar versi\u00f3n"}}</script>
    
    
      <script src="../assets/javascripts/bundle.51198bba.min.js"></script>
      
    
  </body>
</html>